This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.repomix/bundles.json
include/BLE.h
include/config_manager.h
include/config.h
include/debug.h
include/HardwareManager.h
include/LoRaManager.h
include/ModbusMaster.h
include/ModbusSensorManager.h
include/PowerManager.h
include/sensor_types.h
include/SensorManager.h
include/sensors/BatterySensor.h
include/sensors/CO2Sensor.h
include/sensors/ConductivitySensor.h
include/sensors/DS18B20Sensor.h
include/sensors/HDS10Sensor.h
include/sensors/NtcManager.h
include/sensors/PHSensor.h
include/sensors/SHT30Sensor.h
include/sensors/SHT4xSensor.h
include/sensors/VEML7700Sensor.h
include/SHT31.h
include/SleepManager.h
include/util/crc16.h
include/util/word.h
include/utilities.h
lib/Arduino-Temperature-Control-Library-OneWireNg/.arduino_ci/.arduino-ci.cpp
lib/Arduino-Temperature-Control-Library-OneWireNg/.arduino_ci/util/crc16.h
lib/Arduino-Temperature-Control-Library-OneWireNg/.arduino-ci.yml
lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/arduino-cli.yaml
lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/devcontainer.json
lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/Dockerfile
lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/update-libraries.sh
lib/Arduino-Temperature-Control-Library-OneWireNg/.gitattributes
lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/arduino-ci.yml
lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/arduino-lint.yml
lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/jsoncheck.yml
lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/README.md
lib/Arduino-Temperature-Control-Library-OneWireNg/.gitignore
lib/Arduino-Temperature-Control-Library-OneWireNg/arduino-cli.yaml
lib/Arduino-Temperature-Control-Library-OneWireNg/build.sh
lib/Arduino-Temperature-Control-Library-OneWireNg/CMakeLists.txt
lib/Arduino-Temperature-Control-Library-OneWireNg/DallasTemperature.cpp
lib/Arduino-Temperature-Control-Library-OneWireNg/DallasTemperature.h
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Alarm/Alarm.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/AlarmHandler/AlarmHandler.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/ESP-WebServer/ESP-WebServer.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/ESP-WebServer/README.md
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/ExternalPullup/ExternalPullup.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Multibus_simple/Multibus_simple.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Multiple/Multiple.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/oneWireSearch/oneWireSearch.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/readPowerSupply/readPowerSupply.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/SaveRecallScratchPad/SaveRecallScratchPad.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/SetUserData/SetUserData.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Simple/Simple.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Single/Single.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Tester/Tester.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Timing/Timing.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/TwoPin_DS18B20/TwoPin_DS18B20.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/UserDataDemo/UserDataDemo.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/UserDataWriteBatch/UserDataWriteBatch.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/WaitForConversion/WaitForConversion.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/examples/WaitForConversion2/WaitForConversion2.ino
lib/Arduino-Temperature-Control-Library-OneWireNg/Gemfile
lib/Arduino-Temperature-Control-Library-OneWireNg/keywords.txt
lib/Arduino-Temperature-Control-Library-OneWireNg/library.json
lib/Arduino-Temperature-Control-Library-OneWireNg/library.properties
lib/Arduino-Temperature-Control-Library-OneWireNg/LICENSE
lib/Arduino-Temperature-Control-Library-OneWireNg/README.md
lib/Arduino-Temperature-Control-Library-OneWireNg/test/TestDallasTemperature.cpp
lib/Arduino-Temperature-Control-Library-OneWireNg/test/unit_test_001.cpp
lib/README
platformio.ini
src/BLE.cpp
src/config_manager.cpp
src/HardwareManager.cpp
src/LoRaManager.cpp
src/main.cpp
src/ModbusMaster.cpp
src/ModbusSensorManager.cpp
src/PowerManager.cpp
src/SensorManager.cpp
src/sensors/BatterySensor.cpp
src/sensors/CO2Sensor.cpp
src/sensors/ConductivitySensor.cpp
src/sensors/DS18B20Sensor.cpp
src/sensors/HDS10Sensor.cpp
src/sensors/NtcManager.cpp
src/sensors/NtcManager.h
src/sensors/PHSensor.cpp
src/sensors/SHT30Sensor.cpp
src/sensors/SHT4xSensor.cpp
src/sensors/VEML7700Sensor.cpp
src/SHT31.cpp
src/SleepManager.cpp
src/utilities.cpp
test/README

================================================================
Files
================================================================

================
File: .gitignore
================
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json
.vscode/ipch

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: include/BLE.h
================
#ifndef BLE_H
#define BLE_H

#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEAdvertising.h>
#include <BLECharacteristic.h>
#include <ArduinoJson.h>
#include "config.h"
#include "config_manager.h"
#include "debug.h"

// Clase para gestionar toda la funcionalidad BLE
class BLEHandler {
public:
    // Variables para control de estado BLE
    static bool isConnected;
    static unsigned long connectionStartTime;
    static const unsigned long connectionTimeout = CONFIG_BLE_MAX_CONN_TIME; // Usar constante de config.h
    static BLEServer* pBLEServer; // Referencia global al servidor BLE
    static bool shouldExitOnDisconnect; // Indica si debemos salir del modo configuración al desconectar
    
    /**
     * @brief Verifica si se mantuvo presionado el botón de configuración y activa el modo BLE.
     * @return true si se activó el modo BLE, false en caso contrario
     */
    static bool checkConfigMode();

    /**
     * @brief Inicializa el BLE con el nombre del dispositivo basado en el devEUI
     * @param devEUI Identificador único del dispositivo
     * @return Puntero al servidor BLE creado
     */
    static BLEServer* initBLE(const String& devEUI);

    /**
     * @brief Configura los servicios y características BLE
     * @param pServer Servidor BLE donde se configurarán los servicios
     * @return Puntero al servicio BLE creado
     */
    static BLEService* setupService(BLEServer* pServer);

    /**
     * @brief Ejecuta el bucle de parpadeo del LED en modo configuración
     */
    static void runConfigLoop();

private:
    // Callback para eventos del servidor BLE
    class ServerCallbacks: public BLEServerCallbacks {
    public:
        void onConnect(BLEServer* pServer) override;
        void onDisconnect(BLEServer* pServer) override;
    };

    // Callback para configuración del sistema
    class SystemConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para NTC 100K
    class NTC100KConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para NTC 10K
    class NTC10KConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para Conductividad
    class ConductivityConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para pH
    class PHConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para configuración de sensores
    class SensorsConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };

    // Callback para configuración de LoRa
    class LoRaConfigCallback: public BLECharacteristicCallbacks {
        void onWrite(BLECharacteristic *pCharacteristic) override;
        void onRead(BLECharacteristic *pCharacteristic) override;
    };
};

#endif // BLE_H

================
File: include/config_manager.h
================
#pragma once
#include <Preferences.h>
#include <vector>
#include <Arduino.h>  // Se incluye para utilizar el tipo String
#include "sensor_types.h"
#include <RadioLib.h> // Añadido para RADIOLIB_LORAWAN_SESSION_BUF_SIZE
#include "config.h"

// Definición de la estructura para la configuración de LoRa
struct LoRaConfig {
    //FOR OTAA
    String joinEUI;
    String devEUI;
    String nwkKey;
    String appKey;
};

class ConfigManager {
public:
    /* =========================================================================
       INICIALIZACIÓN Y CONFIGURACIÓN DEL SISTEMA
       ========================================================================= */
    // Verificación e inicialización
    static bool checkInitialized();
    static void initializeDefaultConfig();
    
    // Configuración del sistema
    static void getSystemConfig(bool &initialized, uint32_t &sleepTime, String &deviceId, String &stationId);
    static void setSystemConfig(bool initialized, uint32_t sleepTime, const String &deviceId, const String &stationId);

    /* =========================================================================
       CONFIGURACIÓN DE SENSORES NO-MODBUS
       ========================================================================= */
    // Gestión de sensores generales
    static void setSensorsConfigs(const std::vector<SensorConfig>& configs);
    static std::vector<SensorConfig> getAllSensorConfigs();
    static std::vector<SensorConfig> getEnabledSensorConfigs();

    /* =========================================================================
       CONFIGURACIÓN DE SENSORES MODBUS
       ========================================================================= */
    static void setModbusSensorsConfigs(const std::vector<ModbusSensorConfig>& configs);
    static std::vector<ModbusSensorConfig> getAllModbusSensorConfigs();
    static std::vector<ModbusSensorConfig> getEnabledModbusSensorConfigs();
    
    /* =========================================================================
       CONFIGURACIÓN DE LORA
       ========================================================================= */
    static LoRaConfig getLoRaConfig();
    static void setLoRaConfig(
        const String &joinEUI, 
        const String &devEUI, 
        const String &nwkKey, 
        const String &appKey);
    
    /* =========================================================================
       CONFIGURACIÓN DE SENSORES ANALÓGICOS
       ========================================================================= */
    // NTC 100K
    static void getNTC100KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3);
    static void setNTC100KConfig(double t1, double r1, double t2, double r2, double t3, double r3);
    
    // NTC 10K
    static void getNTC10KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3);
    static void setNTC10KConfig(double t1, double r1, double t2, double r2, double t3, double r3);
    
    // Conductividad
    static void getConductivityConfig(float& calTemp, float& coefComp, 
                                    float& v1, float& t1, float& v2, float& t2, float& v3, float& t3);
    static void setConductivityConfig(float calTemp, float coefComp,
                                    float v1, float t1, float v2, float t2, float v3, float t3);
    
    // pH
    static void getPHConfig(float& v1, float& t1, float& v2, float& t2, float& v3, float& t3, float& defaultTemp);
    static void setPHConfig(float v1, float t1, float v2, float t2, float v3, float t3, float defaultTemp);

private:
    // Configuraciones por defecto
    static const SensorConfig defaultConfigs[]; // Configs no-Modbus
    static const ModbusSensorConfig defaultModbusSensors[]; // Configs Modbus
};

================
File: include/debug.h
================
/*******************************************************************************************
 * Archivo: include/debug.h
 * Descripción: Sistema de depuración configurable para mensajes por Serial
 *******************************************************************************************/

#ifndef DEBUG_H
#define DEBUG_H

#include <Arduino.h>
#include "config.h"

// Si DEBUG_ENABLED está definido en config.h, las macros de depuración estarán activas
// Si no está definido, las macros se compilarán como código vacío

#ifdef DEBUG_ENABLED
    #define DEBUG_BEGIN(baud)     Serial.begin(baud)
    #define DEBUG_PRINT(...)      Serial.print(__VA_ARGS__)
    #define DEBUG_PRINTLN(...)    Serial.println(__VA_ARGS__)
    #define DEBUG_PRINTF(...)     Serial.printf(__VA_ARGS__)
    #define DEBUG_FLUSH()         Serial.flush()
    #define DEBUG_END()           Serial.end()
#else
    #define DEBUG_BEGIN(baud)     Serial.begin(baud)  // Mantenemos Serial.begin por compatibilidad
    #define DEBUG_PRINT(...)      {}
    #define DEBUG_PRINTLN(...)    {}
    #define DEBUG_PRINTF(...)     {}
    #define DEBUG_FLUSH()         Serial.flush()      // Mantenemos Serial.flush por seguridad
    #define DEBUG_END()           Serial.end()        // Mantenemos Serial.end por seguridad
#endif

#endif // DEBUG_H

================
File: include/LoRaManager.h
================
/*******************************************************************************************
 * Archivo: include/LoRaManager.h
 * Descripción: Gestión de comunicaciones LoRa y LoRaWAN para el sistema de sensores.
 * Incluye funciones para inicialización, activación y envío de datos.
 *******************************************************************************************/

#ifndef LORA_MANAGER_H
#define LORA_MANAGER_H

#include <Arduino.h>
#include <RadioLib.h>
#include <vector>
#include <ArduinoJson.h>
#include "config_manager.h"
#include "utilities.h"
#include "sensor_types.h"
#include <ESP32Time.h>
#include "SensorManager.h"

// Código de error personalizado para fallo en sincronización RTC
#define RADIOLIB_ERR_RTC_SYNC_FAILED -5000

class LoRaManager {
public:
    /**
     * @brief Inicializa el módulo LoRa con la configuración especificada
     * @param radio Puntero al módulo de radio SX1262
     * @param region Región LoRaWAN a utilizar
     * @param subBand Sub-banda para la región (relevante para US915)
     * @return Estado de la inicialización
     */
    static int16_t begin(SX1262* radio, const LoRaWANBand_t* region, uint8_t subBand);

    /**
     * @brief Activa el nodo LoRaWAN restaurando la sesión o realizando un nuevo join
     * @param node Referencia al nodo LoRaWAN
     * @return Estado de la activación
     */
    static int16_t lwActivate(LoRaWANNode& node);

    /**
     * @brief Crea un payload optimizado con formato delimitado por | y , en lugar de JSON.
     * @param readings Vector con lecturas de sensores.
     * @param deviceId ID del dispositivo.
     * @param stationId ID de la estación.
     * @param battery Valor de la batería.
     * @param timestamp Timestamp del sistema.
     * @param buffer Buffer donde se almacenará el payload.
     * @param bufferSize Tamaño del buffer.
     * @return Tamaño del payload generado.
     */
    static size_t createDelimitedPayload(
        const std::vector<SensorReading>& readings,
        const String& deviceId,
        const String& stationId,
        float battery,
        uint32_t timestamp,
        char* buffer,
        size_t bufferSize
    );

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    /**
     * @brief Crea un payload optimizado con formato delimitado para sensores normales y Modbus.
     * @param normalReadings Vector con lecturas de sensores normales.
     * @param modbusReadings Vector con lecturas de sensores Modbus.
     * @param deviceId ID del dispositivo.
     * @param stationId ID de la estación.
     * @param battery Valor de la batería.
     * @param timestamp Timestamp del sistema.
     * @param buffer Buffer donde se almacenará el payload.
     * @param bufferSize Tamaño del buffer.
     * @return Tamaño del payload generado.
     */
    static size_t createDelimitedPayload(
        const std::vector<SensorReading>& normalReadings,
        const std::vector<ModbusSensorReading>& modbusReadings,
        const String& deviceId,
        const String& stationId,
        float battery,
        uint32_t timestamp,
        char* buffer,
        size_t bufferSize
    );
#endif

    /**
     * @brief Envía el payload de sensores estándar usando formato delimitado.
     * @param readings Vector con todas las lecturas de sensores.
     * @param node Referencia al nodo LoRaWAN
     * @param deviceId ID del dispositivo
     * @param stationId ID de la estación
     * @param rtc Referencia al RTC para obtener timestamp
     */
    static void sendDelimitedPayload(const std::vector<SensorReading>& readings, 
                                   LoRaWANNode& node,
                                   const String& deviceId, 
                                   const String& stationId, 
                                   ESP32Time& rtc);

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
    /**
     * @brief Envía el payload de sensores estándar y Modbus usando formato delimitado.
     * @param normalReadings Vector con lecturas de sensores estándar
     * @param modbusReadings Vector con lecturas de sensores Modbus
     * @param node Referencia al nodo LoRaWAN
     * @param deviceId ID del dispositivo
     * @param stationId ID de la estación
     * @param rtc Referencia al RTC para obtener timestamp
     */
    static void sendDelimitedPayload(const std::vector<SensorReading>& normalReadings, 
                                   const std::vector<ModbusSensorReading>& modbusReadings,
                                   LoRaWANNode& node,
                                   const String& deviceId, 
                                   const String& stationId, 
                                   ESP32Time& rtc);
#endif

    /**
     * @brief Prepara el módulo LoRa para entrar en modo sleep
     * @param radio Puntero al módulo de radio SX1262
     */
    static void prepareForSleep(SX1262* radio);

    /**
     * @brief Configura el datarate para la transmisión
     * @param node Referencia al nodo LoRaWAN
     * @param datarate Valor del datarate a configurar
     */
    static void setDatarate(LoRaWANNode& node, uint8_t datarate);

private:
    static LoRaWANNode* node;
    static SX1262* radioModule;

};

#endif // LORA_MANAGER_H

================
File: include/ModbusMaster.h
================
/**
@file
Arduino library for communicating with Modbus slaves over RS232/485 (via RTU protocol).

@defgroup setup ModbusMaster Object Instantiation/Initialization
@defgroup buffer ModbusMaster Buffer Management
@defgroup discrete Modbus Function Codes for Discrete Coils/Inputs
@defgroup register Modbus Function Codes for Holding/Input Registers
@defgroup constant Modbus Function Codes, Exception Codes
*/
/*

  ModbusMaster.h - Arduino library for communicating with Modbus slaves
  over RS232/485 (via RTU protocol).

  Library:: ModbusMaster

  Copyright:: 2009-2016 Doc Walker

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*/

  
#ifndef ModbusMaster_h
#define ModbusMaster_h


/**
@def __MODBUSMASTER_DEBUG__ (0)
Set to 1 to enable debugging features within class:
  - PIN A cycles for each byte read in the Modbus response
  - PIN B cycles for each millisecond timeout during the Modbus response
*/
#define __MODBUSMASTER_DEBUG__ (0)
#define __MODBUSMASTER_DEBUG_PIN_A__ 4
#define __MODBUSMASTER_DEBUG_PIN_B__ 5

/* _____STANDARD INCLUDES____________________________________________________ */
// include types & constants of Wiring core API
#include "Arduino.h"

/* _____UTILITY MACROS_______________________________________________________ */


/* _____PROJECT INCLUDES_____________________________________________________ */
// functions to calculate Modbus Application Data Unit CRC
#include "util/crc16.h"

// functions to manipulate words
#include "util/word.h"


/* _____CLASS DEFINITIONS____________________________________________________ */
/**
Arduino class library for communicating with Modbus slaves over 
RS232/485 (via RTU protocol).
*/
class ModbusMaster
{
  public:
    ModbusMaster();
   
    void begin(uint8_t, Stream &serial);
    void idle(void (*)());
    void preTransmission(void (*)());
    void postTransmission(void (*)());

    // Modbus exception codes
    /**
    Modbus protocol illegal function exception.
    
    The function code received in the query is not an allowable action for
    the server (or slave). This may be because the function code is only
    applicable to newer devices, and was not implemented in the unit
    selected. It could also indicate that the server (or slave) is in the
    wrong state to process a request of this type, for example because it is
    unconfigured and is being asked to return register values.
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalFunction            = 0x01;

    /**
    Modbus protocol illegal data address exception.
    
    The data address received in the query is not an allowable address for 
    the server (or slave). More specifically, the combination of reference 
    number and transfer length is invalid. For a controller with 100 
    registers, the ADU addresses the first register as 0, and the last one 
    as 99. If a request is submitted with a starting register address of 96 
    and a quantity of registers of 4, then this request will successfully 
    operate (address-wise at least) on registers 96, 97, 98, 99. If a 
    request is submitted with a starting register address of 96 and a 
    quantity of registers of 5, then this request will fail with Exception 
    Code 0x02 "Illegal Data Address" since it attempts to operate on 
    registers 96, 97, 98, 99 and 100, and there is no register with address 
    100. 
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalDataAddress         = 0x02;
    
    /**
    Modbus protocol illegal data value exception.
    
    A value contained in the query data field is not an allowable value for 
    server (or slave). This indicates a fault in the structure of the 
    remainder of a complex request, such as that the implied length is 
    incorrect. It specifically does NOT mean that a data item submitted for 
    storage in a register has a value outside the expectation of the 
    application program, since the MODBUS protocol is unaware of the 
    significance of any particular value of any particular register.
    
    @ingroup constant
    */
    static const uint8_t ku8MBIllegalDataValue           = 0x03;
    
    /**
    Modbus protocol slave device failure exception.
    
    An unrecoverable error occurred while the server (or slave) was
    attempting to perform the requested action.
    
    @ingroup constant
    */
    static const uint8_t ku8MBSlaveDeviceFailure         = 0x04;

    // Class-defined success/exception codes
    /**
    ModbusMaster success.
    
    Modbus transaction was successful; the following checks were valid:
      - slave ID
      - function code
      - response code
      - data
      - CRC
      
    @ingroup constant
    */
    static const uint8_t ku8MBSuccess                    = 0x00;
    
    /**
    ModbusMaster invalid response slave ID exception.
    
    The slave ID in the response does not match that of the request.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidSlaveID             = 0xE0;
    
    /**
    ModbusMaster invalid response function exception.
    
    The function code in the response does not match that of the request.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidFunction            = 0xE1;
    
    /**
    ModbusMaster response timed out exception.
    
    The entire response was not received within the timeout period, 
    ModbusMaster::ku8MBResponseTimeout. 
    
    @ingroup constant
    */
    static const uint8_t ku8MBResponseTimedOut           = 0xE2;
    
    /**
    ModbusMaster invalid response CRC exception.
    
    The CRC in the response does not match the one calculated.
    
    @ingroup constant
    */
    static const uint8_t ku8MBInvalidCRC                 = 0xE3;
    
    uint16_t getResponseBuffer(uint8_t);
    void     clearResponseBuffer();
    uint8_t  setTransmitBuffer(uint8_t, uint16_t);
    void     clearTransmitBuffer();
    
    void beginTransmission(uint16_t);
    uint8_t requestFrom(uint16_t, uint16_t);
    void sendBit(bool);
    void send(uint8_t);
    void send(uint16_t);
    void send(uint32_t);
    uint8_t available(void);
    uint16_t receive(void);
    
    
    uint8_t  readCoils(uint16_t, uint16_t);
    uint8_t  readDiscreteInputs(uint16_t, uint16_t);
    uint8_t  readHoldingRegisters(uint16_t, uint16_t);
    uint8_t  readInputRegisters(uint16_t, uint8_t);
    uint8_t  writeSingleCoil(uint16_t, uint8_t);
    uint8_t  writeSingleRegister(uint16_t, uint16_t);
    uint8_t  writeMultipleCoils(uint16_t, uint16_t);
    uint8_t  writeMultipleCoils();
    uint8_t  writeMultipleRegisters(uint16_t, uint16_t);
    uint8_t  writeMultipleRegisters();
    uint8_t  maskWriteRegister(uint16_t, uint16_t, uint16_t);
    uint8_t  readWriteMultipleRegisters(uint16_t, uint16_t, uint16_t, uint16_t);
    uint8_t  readWriteMultipleRegisters(uint16_t, uint16_t);
    
  private:
    Stream* _serial;                                             ///< reference to serial port object
    uint8_t  _u8MBSlave;                                         ///< Modbus slave (1..255) initialized in begin()
    static const uint8_t ku8MaxBufferSize                = 64;   ///< size of response/transmit buffers    
    uint16_t _u16ReadAddress;                                    ///< slave register from which to read
    uint16_t _u16ReadQty;                                        ///< quantity of words to read
    uint16_t _u16ResponseBuffer[ku8MaxBufferSize];               ///< buffer to store Modbus slave response; read via GetResponseBuffer()
    uint16_t _u16WriteAddress;                                   ///< slave register to which to write
    uint16_t _u16WriteQty;                                       ///< quantity of words to write
    uint16_t _u16TransmitBuffer[ku8MaxBufferSize];               ///< buffer containing data to transmit to Modbus slave; set via SetTransmitBuffer()
    uint16_t* txBuffer; // from Wire.h -- need to clean this up Rx
    uint8_t _u8TransmitBufferIndex;
    uint16_t u16TransmitBufferLength;
    uint16_t* rxBuffer; // from Wire.h -- need to clean this up Rx
    uint8_t _u8ResponseBufferIndex;
    uint8_t _u8ResponseBufferLength;
    
    // Modbus function codes for bit access
    static const uint8_t ku8MBReadCoils                  = 0x01; ///< Modbus function 0x01 Read Coils
    static const uint8_t ku8MBReadDiscreteInputs         = 0x02; ///< Modbus function 0x02 Read Discrete Inputs
    static const uint8_t ku8MBWriteSingleCoil            = 0x05; ///< Modbus function 0x05 Write Single Coil
    static const uint8_t ku8MBWriteMultipleCoils         = 0x0F; ///< Modbus function 0x0F Write Multiple Coils

    // Modbus function codes for 16 bit access
    static const uint8_t ku8MBReadHoldingRegisters       = 0x03; ///< Modbus function 0x03 Read Holding Registers
    static const uint8_t ku8MBReadInputRegisters         = 0x04; ///< Modbus function 0x04 Read Input Registers
    static const uint8_t ku8MBWriteSingleRegister        = 0x06; ///< Modbus function 0x06 Write Single Register
    static const uint8_t ku8MBWriteMultipleRegisters     = 0x10; ///< Modbus function 0x10 Write Multiple Registers
    static const uint8_t ku8MBMaskWriteRegister          = 0x16; ///< Modbus function 0x16 Mask Write Register
    static const uint8_t ku8MBReadWriteMultipleRegisters = 0x17; ///< Modbus function 0x17 Read Write Multiple Registers
    
    // Modbus timeout [milliseconds]
    static const uint16_t ku16MBResponseTimeout          = 2000; ///< Modbus timeout [milliseconds]
    
    // master function that conducts Modbus transactions
    uint8_t ModbusMasterTransaction(uint8_t u8MBFunction);
    
    // idle callback function; gets called during idle time between TX and RX
    void (*_idle)();
    // preTransmission callback function; gets called before writing a Modbus message
    void (*_preTransmission)();
    // postTransmission callback function; gets called after a Modbus message has been sent
    void (*_postTransmission)();
};
#endif

/**
@example examples/Basic/Basic.pde
@example examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde
@example examples/RS485_HalfDuplex/RS485_HalfDuplex.ino
*/

================
File: include/ModbusSensorManager.h
================
#ifndef MODBUS_SENSOR_MANAGER_H
#define MODBUS_SENSOR_MANAGER_H

#include <Arduino.h>
#include <vector>
#include "sensor_types.h"
#include "config.h"  // Para las definiciones de tipo de dispositivo

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

/**
 * @brief Clase para manejar la lectura de sensores Modbus.
 *        Usa Serial2 con pines configurables para RX/TX.
 *        Utiliza la biblioteca ModbusMaster para comunicación.
 */
class ModbusSensorManager {
public:
    /**
     * @brief Inicializa el bus RS485/Modbus (configura Serial2 con los pines definidos)
     *        Debe llamarse una sola vez al principio.
     */
    static void beginModbus();

    /**
     * @brief Finaliza la comunicación Modbus (cierra Serial2)
     *        Debe llamarse después de completar todas las lecturas Modbus
     */
    static void endModbus();

    /**
     * @brief Lee un sensor Modbus de tipo ENV_SENSOR.
     *        Regresa la lectura con valores en el siguiente orden:
     *        [0]=Humedad(%), [1]=Temperatura(°C), [2]=Presión(kPa), [3]=Iluminación(lux)
     * @param cfg Configuración del sensor (dirección, etc.)
     * @return Estructura ModbusSensorReading con los valores en el orden establecido.
     */
    static ModbusSensorReading readEnvSensor(const ModbusSensorConfig &cfg);

private:
    /**
     * @brief Envía un frame Modbus (Función 0x03) y recibe la respuesta utilizando ModbusMaster.
     *        Para simplificar el ejemplo, se hace una lectura consecutiva de registros.
     * @param address Dirección Modbus del dispositivo
     * @param startReg Registro inicial
     * @param numRegs  Cantidad de registros
     * @param outData  Buffer de salida donde se almacenan los valores de cada registro
     * @return true si la lectura fue exitosa, false en caso de error
     */
    static bool readHoldingRegisters(uint8_t address, uint16_t startReg, uint16_t numRegs, uint16_t* outData);
};

#endif // defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

#endif // MODBUS_SENSOR_MANAGER_H

================
File: include/PowerManager.h
================
#ifndef POWER_MANAGER_H
#define POWER_MANAGER_H

#include <Arduino.h>
#include "config.h"

class PowerManager {
private:
    // No más dependencia del expansor de IO

public:
    PowerManager();
    void begin();

    // Métodos de control de energía
    void power3V3On();
    void power3V3Off();
    void power12VOn();
    void power12VOff();
    void allPowerOff();
};

#endif

================
File: include/sensors/CO2Sensor.h
================
#ifndef CO2_SENSOR_H
#define CO2_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include "SparkFun_SCD4x_Arduino_Library.h"

// Declaración externa del objeto del sensor (se definirá en src/main.cpp)
extern SCD4x scd4x;

/**
 * @brief Clase para manejar el sensor de CO2 SCD4x
 */
class CO2Sensor {
public:
    /**
     * @brief Lee CO2, temperatura y humedad del sensor SCD4x en modo single-shot.
     *
     * @param outCO2 Variable donde se almacenará la concentración de CO2 en ppm.
     * @param outTemp Variable donde se almacenará la temperatura en °C.
     * @param outHum Variable donde se almacenará la humedad relativa en %.
     * @return true si la lectura fue exitosa, false en caso contrario.
     */
    static bool read(float &outCO2, float &outTemp, float &outHum);

    /**
     * @brief Inicializa el sensor SCD4x.
     * @return true si la inicialización fue exitosa, false en caso contrario.
     */
    static bool begin();
};

#endif // CO2_SENSOR_H

================
File: include/sensors/ConductivitySensor.h
================
#ifndef CONDUCTIVITY_SENSOR_H
#define CONDUCTIVITY_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include "config_manager.h"

/**
 * @brief Clase para manejar el sensor de conductividad
 */
class ConductivitySensor {
public:
    /**
     * @brief Lee el sensor de conductividad conectado al canal AIN6 del ADC
     * 
     * @return float Valor de conductividad/TDS en ppm, o NAN si hay error
     */
    static float read();

    /**
     * @brief Convierte el voltaje medido a conductividad/TDS en ppm
     * 
     * @param voltage Voltaje medido del sensor
     * @param tempC Temperatura actual del agua para compensación
     * @return float Valor de TDS en ppm (partes por millón)
     */
    static float convertVoltageToConductivity(float voltage, float tempC);
};

#endif // CONDUCTIVITY_SENSOR_H

================
File: include/sensors/DS18B20Sensor.h
================
#ifndef DS18B20_SENSOR_H
#define DS18B20_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)
#include <DallasTemperature.h>

// Variable externa
extern DallasTemperature dallasTemp;

/**
 * @brief Clase para manejar el sensor de temperatura DS18B20
 */
class DS18B20Sensor {
public:
    /**
     * @brief Lee la temperatura del sensor DS18B20
     * 
     * @return float Temperatura en °C, o NAN si hay error
     */
    static float read();
};

#endif // defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)

#endif // DS18B20_SENSOR_H

================
File: include/sensors/HDS10Sensor.h
================
#ifndef HDS10_SENSOR_H
#define HDS10_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"

/**
 * @brief Clase para manejar el sensor de humedad HDS10
 */
class HDS10Sensor {
public:
    /**
     * @brief Lee el sensor HDS10 conectado al canal AIN5/AIN8 del ADC
     * 
     * @return float Porcentaje de humedad (0-100%) según calibración definida
     *               o NAN si ocurre un error o no es posible leer
     */
    static float read();

    /**
     * @brief Convierte la resistencia del sensor HDS10 a porcentaje de humedad
     * 
     * @param resistance Resistencia del sensor en ohms
     * @return float Porcentaje de humedad relativa (50-100%)
     */
    static float convertResistanceToHumidity(float resistance);
};

#endif // HDS10_SENSOR_H

================
File: include/sensors/NtcManager.h
================
#ifndef NTC_MANAGER_H
#define NTC_MANAGER_H

#include <Arduino.h>

/**
 * @brief Clase para gestionar los cálculos y lecturas de sensores NTC100K
 */
class NtcManager {
public:
    /**
     * @brief Calcula los coeficientes A, B y C de Steinhart-Hart usando 3 puntos (T, R).
     *        T debe estar en Kelvin. R en ohms.
     * @param T1 Temperatura en Kelvin en punto 1
     * @param R1 Resistencia en ohms en punto 1
     * @param T2 Temperatura en Kelvin en punto 2
     * @param R2 Resistencia en ohms en punto 2
     * @param T3 Temperatura en Kelvin en punto 3
     * @param R3 Resistencia en ohms en punto 3
     * @param A [out] Coeficiente A
     * @param B [out] Coeficiente B
     * @param C [out] Coeficiente C
     */
    static void calculateSteinhartHartCoeffs(double T1, double R1,
                                           double T2, double R2,
                                           double T3, double R3,
                                           double &A, double &B, double &C);

    /**
     * @brief Calcula la temperatura (°C) a partir de la resistencia usando la ecuación de Steinhart-Hart.
     * @param resistance Resistencia medida (ohms)
     * @param A Coeficiente A
     * @param B Coeficiente B
     * @param C Coeficiente C
     * @return Temperatura en °C
     */
    static double steinhartHartTemperature(double resistance, double A, double B, double C);

    /**
     * @brief Calcula la resistencia del NTC en el puente de Wheatstone según la disposición descrita
     * @param diffVoltage Voltaje diferencial = (Vneg - 1.25)
     * @return Resistencia medida del NTC (ohms)
     */
    static double computeNtcResistanceFromBridge(double diffVoltage);

    /**
     * @brief Calcula la resistencia del NTC en un divisor de tensión simple.
     * @param voltage Voltaje medido en el punto medio del divisor (V)
     * @param vRef Voltaje de referencia (V), típicamente 2.5V
     * @param rFixed Resistencia fija en el divisor (ohms), típicamente 10000 ohms
     * @param ntcTop Si true, el NTC está conectado a Vref; si false, está conectado a GND
     * @return Resistencia medida del NTC (ohms)
     */
    static double computeNtcResistanceFromVoltageDivider(double voltage, double vRef, double rFixed, bool ntcTop = true);

    /**
     * @brief Obtiene la temperatura de un sensor NTC100K
     * @param configKey "0" o "1"
     * @return Temperatura en °C o NAN en caso de error
     */
    static double readNtc100kTemperature(const char* configKey);

    /**
     * @brief Obtiene la temperatura de un sensor NTC10K
     * @return Temperatura en °C o NAN en caso de error
     */
    static double readNtc10kTemperature();
};

#endif // NTC_MANAGER_H

================
File: include/sensors/PHSensor.h
================
#ifndef PH_SENSOR_H
#define PH_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include "config_manager.h"

/**
 * @brief Clase para manejar el sensor de pH
 */
class PHSensor {
public:
    /**
     * @brief Lee el sensor de pH conectado al canal AIN7 del ADC
     * 
     * @return float Valor de pH (0-14), o NAN si hay error
     */
    static float read();

    /**
     * @brief Convierte el voltaje medido a valor de pH
     * 
     * @param voltage Voltaje medido del sensor de pH
     * @param tempC Temperatura del agua en grados Celsius para compensación
     * @return float Valor de pH (0-14)
     */
    static float convertVoltageToPH(float voltage, float tempC);
};

#endif // PH_SENSOR_H

================
File: include/sensors/SHT30Sensor.h
================
#ifndef SHT30_SENSOR_H
#define SHT30_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include "SHT31.h"

// Variable externa
extern SHT31 sht30Sensor;

/**
 * @brief Clase para manejar el sensor de temperatura y humedad SHT30
 */
class SHT30Sensor {
public:
    /**
     * @brief Lee temperatura y humedad del sensor SHT30
     * 
     * @param outTemp Variable donde se almacenará la temperatura en °C
     * @param outHum Variable donde se almacenará la humedad relativa en %
     */
    static void read(float &outTemp, float &outHum);
};

#endif // SHT30_SENSOR_H

================
File: include/sensors/SHT4xSensor.h
================
#ifndef SHT4X_SENSOR_H
#define SHT4X_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"
#include <SensirionI2cSht4x.h>

// Variable externa del sensor SHT4x que será declarada en otro lugar
extern SensirionI2cSht4x sht4xSensor;

/**
 * @brief Clase para manejar el sensor de temperatura y humedad SHT4x
 */
class SHT4xSensor {
public:
    /**
     * @brief Inicializa el sensor SHT4x
     * 
     * @return true si se inicializó correctamente, false en caso contrario
     */
    static bool begin();

    /**
     * @brief Lee temperatura y humedad del sensor SHT4x
     * 
     * @param outTemp Variable donde se almacenará la temperatura en °C
     * @param outHum Variable donde se almacenará la humedad relativa en %
     * @return true si la lectura fue exitosa, false en caso contrario
     */
    static bool read(float &outTemp, float &outHum);
};

#endif // SHT4X_SENSOR_H

================
File: include/sensors/VEML7700Sensor.h
================
#ifndef VEML7700_SENSOR_H
#define VEML7700_SENSOR_H

#include <Arduino.h>
#include <Adafruit_VEML7700.h>

/**
 * @brief Clase para manejar el sensor de luz VEML7700
 */
class VEML7700Sensor {
public:
    /**
     * @brief Inicializa el sensor VEML7700 con configuración optimizada
     * para entornos de luz brillante y lectura rápida
     * 
     * @return true si la inicialización fue exitosa, false en caso contrario
     */
    static bool begin();
    
    /**
     * @brief Lee el valor de luz en lux del sensor VEML7700
     * 
     * @return float Valor en lux, o NAN si hay error
     */
    static float read();
};

#endif // VEML7700_SENSOR_H

================
File: include/SHT31.h
================
#pragma once
//
//    FILE: SHT31.h
//  AUTHOR: Rob Tillaart
// VERSION: 0.5.0
//    DATE: 2019-02-08
// PURPOSE: Arduino library for the SHT31 temperature and humidity sensor
//          https://www.adafruit.com/product/2857
//     URL: https://github.com/RobTillaart/SHT31


#include "Arduino.h"
#include "Wire.h"


#define SHT31_LIB_VERSION             (F("0.5.0"))

#ifndef SHT_DEFAULT_ADDRESS
#define SHT_DEFAULT_ADDRESS           0x44
#endif

//  fields readStatus
#define SHT31_STATUS_ALERT_PENDING    (1 << 15)
#define SHT31_STATUS_HEATER_ON        (1 << 13)
#define SHT31_STATUS_HUM_TRACK_ALERT  (1 << 11)
#define SHT31_STATUS_TEMP_TRACK_ALERT (1 << 10)
#define SHT31_STATUS_SYSTEM_RESET     (1 << 4)
#define SHT31_STATUS_COMMAND_STATUS   (1 << 1)
#define SHT31_STATUS_WRITE_CRC_STATUS (1 << 0)

//  error codes
#define SHT31_OK                      0x00
#define SHT31_ERR_WRITECMD            0x81
#define SHT31_ERR_READBYTES           0x82
#define SHT31_ERR_HEATER_OFF          0x83
#define SHT31_ERR_NOT_CONNECT         0x84
#define SHT31_ERR_CRC_TEMP            0x85
#define SHT31_ERR_CRC_HUM             0x86
#define SHT31_ERR_CRC_STATUS          0x87
#define SHT31_ERR_HEATER_COOLDOWN     0x88
#define SHT31_ERR_HEATER_ON           0x89


class SHT31
{
public:
  SHT31(uint8_t address = SHT_DEFAULT_ADDRESS, TwoWire *wire = &Wire);

  bool    begin();
  uint8_t getAddress();

  //  check sensor is reachable over I2C
  virtual bool isConnected();

  //  blocks 15 milliseconds + actual read + math
  bool read(bool fast = true);

  //  details see datasheet; summary in SHT31.cpp file
  uint16_t readStatus();

  //  lastRead is in milliSeconds since start
  uint32_t lastRead() { return _lastRead; };

  bool reset(bool hard = false);

  //  do not use heater for long periods,
  //  use it for max 3 minutes to heat up
  //  and let it cool down at least 3 minutes.
  void setHeatTimeout(uint8_t seconds);
  uint8_t getHeatTimeout() { return _heatTimeout; };
  bool heatOn();
  bool heatOff();
  bool isHeaterOn();  // is the sensor still heating up?
  bool heatUp() { return isHeaterOn(); };   // will be obsolete in future

  float    getHumidity()       { return _rawHumidity    * (100.0 / 65535); };
  float    getTemperature()    { return _rawTemperature * (175.0 / 65535) - 45; };
  float    getFahrenheit()     { return _rawTemperature * (63.0 /13107.0) - 49; };
  uint16_t getRawHumidity()    { return _rawHumidity; };
  uint16_t getRawTemperature() { return _rawTemperature; };


  // ASYNC INTERFACE
  bool requestData();
  bool dataReady();
  bool readData(bool fast = true);

  int getError();  //  clears error flag

protected:
  uint8_t  _address;
  uint8_t  _heatTimeout;   //  seconds
  uint32_t _lastRead;
  uint32_t _lastRequest;   //  for async interface
  uint32_t _heaterStart;
  uint32_t _heaterStop;
  bool     _heaterOn;
  uint16_t _rawHumidity;
  uint16_t _rawTemperature;
  uint8_t  _error;

private:
  uint8_t crc8(const uint8_t *data, uint8_t len);
  virtual bool writeCmd(uint16_t cmd);
  virtual bool readBytes(uint8_t n, uint8_t *val);
  TwoWire* _wire;
};


//  -- END OF FILE --

================
File: include/util/crc16.h
================
/**
@file
CRC Computations

@defgroup util_crc16 "util/crc16.h": CRC Computations
@code#include "util/crc16.h"@endcode

This header file provides functions for calculating
cyclic redundancy checks (CRC) using common polynomials.
Modified by Doc Walker to be processor-independent (removed inline
assembler to allow it to compile on SAM3X8E processors).

@par References:
Jack Crenshaw's "Implementing CRCs" article in the January 1992 issue of @e
Embedded @e Systems @e Programming. This may be difficult to find, but it
explains CRC's in very clear and concise terms. Well worth the effort to
obtain a copy.

*/
/* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   Copyright (c) 2005, 2007 Joerg Wunsch
   Copyright (c) 2013 Dave Hylands
   Copyright (c) 2013 Frederic Nadeau
   Copyright (c) 2015 Doc Walker
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

   * Neither the name of the copyright holders nor the names of
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */


#ifndef _UTIL_CRC16_H_
#define _UTIL_CRC16_H_


/** @ingroup util_crc16
    Processor-independent CRC-16 calculation.

    Polynomial: x^16 + x^15 + x^2 + 1 (0xA001)<br>
    Initial value: 0xFFFF

    This CRC is normally used in disk-drive controllers.

    @param uint16_t crc (0x0000..0xFFFF)
    @param uint8_t a (0x00..0xFF)
    @return calculated CRC (0x0000..0xFFFF)
*/
static uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
      crc = (crc >> 1) ^ 0xA001;
    else
      crc = (crc >> 1);
  }

  return crc;
}


#endif /* _UTIL_CRC16_H_ */

================
File: include/util/word.h
================
/**
@file
Utility Functions for Manipulating Words

@defgroup util_word "util/word.h": Utility Functions for Manipulating Words
@code#include "util/word.h"@endcode

This header file provides utility functions for manipulating words.

*/
/*

  word.h - Utility Functions for Manipulating Words

  This file is part of ModbusMaster.

  ModbusMaster is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  ModbusMaster is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ModbusMaster.  If not, see <http://www.gnu.org/licenses/>.

  Written by Doc Walker (Rx)
  Copyright © 2009-2015 Doc Walker <4-20ma at wvfans dot net>

*/


#ifndef _UTIL_WORD_H_
#define _UTIL_WORD_H_


/** @ingroup util_word
    Return low word of a 32-bit integer.

    @param uint32_t ww (0x00000000..0xFFFFFFFF)
    @return low word of input (0x0000..0xFFFF)
*/
static inline uint16_t lowWord(uint32_t ww)
{
  return (uint16_t) ((ww) & 0xFFFF);
}


/** @ingroup util_word
    Return high word of a 32-bit integer.

    @param uint32_t ww (0x00000000..0xFFFFFFFF)
    @return high word of input (0x0000..0xFFFF)
*/
static inline uint16_t highWord(uint32_t ww)
{
  return (uint16_t) ((ww) >> 16);
}


#endif /* _UTIL_WORD_H_ */

================
File: include/utilities.h
================
#ifndef UTILITIES_H
#define UTILITIES_H

#include <Arduino.h>

void parseKeyString(const String &keyStr, uint8_t *outArray, size_t expectedSize);
bool parseEUIString(const char* euiStr, uint64_t* eui);

/**
 * @brief Formatea un valor flotante con hasta 3 decimales, eliminando ceros finales.
 * @param value Valor flotante a formatear.
 * @param buffer Buffer donde se almacenará la cadena formateada.
 * @param bufferSize Tamaño del buffer.
 */
void formatFloatTo3Decimals(float value, char* buffer, size_t bufferSize);

#endif // UTILITIES_H

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.arduino_ci/.arduino-ci.cpp
================
#define ARDUINO_CI 1

// Mock OneWire GPIO functions
uint8_t digitalPinToBitMask(uint8_t pin) { return 1 << (pin % 8); }
void* digitalPinToPort(uint8_t pin) { static uint8_t dummy; return &dummy; }
void* portModeRegister(void* port) { return port; }

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.arduino_ci/util/crc16.h
================
#ifndef CRC16_H
#define CRC16_H

#ifdef __cplusplus
extern "C" {
#endif

// Pure C implementation to replace the ASM version
static inline uint16_t _crc16_update(uint16_t crc, uint8_t data) {
    unsigned int i;
    crc ^= data;
    for (i = 0; i < 8; ++i) {
        if (crc & 1)
            crc = (crc >> 1) ^ 0xA001;
        else
            crc = (crc >> 1);
    }
    return crc;
}

#ifdef __cplusplus
}
#endif

#endif

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.arduino-ci.yml
================
# .arduino-ci.yml

# Compilation settings
compile:
  platforms:
    - uno
  libraries:
    - "OneWire"

# Unit testing settings
unittest:
  platforms:
    - uno
  libraries:
    - "OneWire"

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/arduino-cli.yaml
================
compile:
  # Choosing to run compilation tests on 2 different Arduino platforms
  platforms:
    - uno
    - due
    # - zero         # SAMD covered by M4
    # - leonardo     # AVR covered by UNO
    - m4
    # - esp32        # errors on OneWire =>  util/crc16.h  vs  rom/crc.h
    # - esp8266
    # - mega2560     # AVR covered by UNO
unittest:
  # These dependent libraries will be installed
  libraries:
    - "OneWire"
board_manager:
  additional_urls:
    - https://arduino.esp8266.com/stable/package_esp8266com_index.json
    - https://dl.espressif.com/dl/package_esp32_index.json

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/devcontainer.json
================
{
    "name": "Arduino Library Development",
    "dockerFile": "Dockerfile",
    "mounts": [
      "source=devcontainer_ssh,target=/home/vscode/.ssh,type=volume",
      "source=devcontainer_bash_history,target=/home/vscode/.bash_history,type=volume",
      "source=devcontainer_fish_history,target=/home/vscode/.local/share/fish/fish_history,type=volume"
    ],
    "customizations": {
      "vscode": {
        "extensions": [
          "vsciot-vscode.vscode-arduino",
          "ms-vscode.cpptools",
          "ms-azuretools.vscode-docker",
          "yzhang.markdown-all-in-one"
        ]
      }
    },
    "postCreateCommand": "arduino-cli core install arduino:avr && arduino-cli lib install ArduinoUnit && /usr/local/bin/update-libraries.sh",
    "updateContentCommand": "/usr/local/bin/update-libraries.sh",
    "remoteUser": "vscode"
  }

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/Dockerfile
================
FROM mcr.microsoft.com/vscode/devcontainers/cpp:debian

# Install required packages
RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
    && apt-get -y install --no-install-recommends \
    python3 \
    python3-pip \
    git \
    curl \
    fish \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

RUN mkdir -p /home/vscode/.local/share/CMakeTools \
&& chown -R vscode:vscode /home/vscode/.local/share/CMakeTools

RUN mkdir -p /home/vscode/.ssh \
    && chown vscode:vscode /home/vscode/.ssh \
    && chmod 700 /home/vscode/.ssh

# Install arduino-cli
RUN curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh

# Set up arduino-cli config
RUN arduino-cli config init

# Add arduino-cli to PATH
ENV PATH="/usr/local/bin:${PATH}"

# Create workspace directory
WORKDIR /workspace

# Copy arduino-cli configuration (customise to your actual path)
COPY arduino-cli.yaml /root/.arduino15/arduino-cli.yaml

# Install build essentials
RUN apt-get update && apt-get install -y build-essential && rm -rf /var/lib/apt/lists/*

# (Optional) Install Arduino cores for ESP8266 and ESP32 if needed
RUN arduino-cli core install esp8266:esp8266 esp32:esp32

# Install only required dependencies for DallasTemperature library and others
RUN arduino-cli lib install \
    "OneWire" \
    "ArduinoUnit"  # For testing

# Verify library installation
RUN arduino-cli lib list

# Copy update script
COPY update-libraries.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/update-libraries.sh

# Add aliases for build operations (for Bash)
RUN echo 'alias arduino-build="./build.sh build"' >> /home/vscode/.bashrc && \
    echo 'alias arduino-test="./build.sh test"' >> /home/vscode/.bashrc && \
    echo 'alias arduino-build-test="./build.sh all"' >> /home/vscode/.bashrc

# Add a welcome message to .bashrc
RUN echo '\n# Welcome to the dev container! Here are some useful aliases:' >> /home/vscode/.bashrc && \
    echo 'echo "  - arduino-build: Build the project"' >> /home/vscode/.bashrc && \
    echo 'echo "  - arduino-test: Run tests for the project"' >> /home/vscode/.bashrc && \
    echo 'echo "  - arduino-build-test: Build and test the project"' >> /home/vscode/.bashrc

# (Optional) Add fish-specific configuration if desired
# For example, you might add an alias file or welcome message for fish:
RUN mkdir -p /home/vscode/.config/fish && \
    echo 'set -gx PATH /usr/local/bin $PATH' >> /home/vscode/.config/fish/config.fish && \
    echo '# Welcome to the Fish shell inside the dev container!' >> /home/vscode/.config/fish/config.fish

# Generate SSH keys and set proper ownership and permissions
RUN if [ ! -f /home/vscode/.ssh/id_rsa ]; then \
        ssh-keygen -t rsa -b 4096 -N "" -C "devcontainer@local" -f /home/vscode/.ssh/id_rsa && \
        chmod 600 /home/vscode/.ssh/id_rsa && \
        chmod 644 /home/vscode/.ssh/id_rsa.pub && \
        chown vscode:vscode /home/vscode/.ssh/id_rsa /home/vscode/.ssh/id_rsa.pub ; \
    fi

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.devcontainer/update-libraries.sh
================
#!/bin/bash

echo "Updating arduino-cli core and index..."
arduino-cli core update-index
arduino-cli update

echo "Updating installed libraries..."
arduino-cli lib update-index
arduino-cli lib upgrade

# Update Arduino cores
echo "Updating ESP8266 and ESP32 cores..."
arduino-cli core install esp8266:esp8266
arduino-cli core install esp32:esp32

# List of libraries to ensure are installed/updated
LIBRARIES=(
    "OneWire"
    "ArduinoUnit"
)

echo "Checking and installing libraries..."
for lib in "${LIBRARIES[@]}"; do
    echo "Processing library: $lib"
    if ! arduino-cli lib list | grep -q "$lib"; then
        echo "Installing $lib..."
        arduino-cli lib install "$lib"
    else
        echo "$lib is already installed"
    fi
done

echo "Verifying all libraries are up to date..."
arduino-cli lib list

echo "Library update complete!"

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.gitattributes
================
*	text=auto

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/arduino-ci.yml
================
name: Arduino-Temperature-Control-Library Github Workflow

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install AVR dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-avr avr-libc

      - name: Create required directories
        run: |
          mkdir -p $GITHUB_WORKSPACE/libraries
          mkdir -p $GITHUB_WORKSPACE/.arduino15
          mkdir -p $GITHUB_WORKSPACE/Arduino

      - name: Setup Arduino CLI
        uses: arduino/setup-arduino-cli@v1

      - name: Configure Arduino CLI and install cores
        run: |
          arduino-cli config init
          arduino-cli config set library.enable_unsafe_install true
          arduino-cli config add board_manager.additional_urls https://arduino.esp8266.com/stable/package_esp8266com_index.json
          arduino-cli core update-index
          arduino-cli core install arduino:avr
          arduino-cli core install esp8266:esp8266

      - name: Install OneWire library
        run: |
          arduino-cli lib install OneWire
          # Replace the CRC implementation directly in the OneWire library
          cat > /home/runner/Arduino/libraries/OneWire/util/crc16.h << 'EOF'
          #ifndef CRC16_H
          #define CRC16_H
          #include <stdint.h>

          static inline uint16_t _crc16_update(uint16_t crc, uint8_t a)
          {
              crc ^= a;
              for (uint8_t i = 0; i < 8; ++i) {
                  if (crc & 1)
                      crc = (crc >> 1) ^ 0xA001;
                  else
                      crc = (crc >> 1);
              }
              return crc;
          }

          #endif
          EOF

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.0'

      - name: Install bundler
        run: |
          gem install bundler

      - name: Install dependencies
        run: |
          bundle install

      - name: List repository contents (for debugging)
        run: |
          ls -R

      - name: Run tests (skip example compilation)
        run: |
          # Run arduino_ci for unit tests only (skip example compilation)
          export ARDUINO_CI_SELECTED_BOARD="arduino:avr:uno"
          bundle exec arduino_ci.rb --skip-examples-compilation

      - name: Compile all sketches for AVR platform
        run: |
          # Compile all sketches for AVR platform (Arduino Uno), excluding ESP-WebServer
          for sketch in $(find examples -name "*.ino" ! -path "*/ESP-WebServer/*"); do
            arduino-cli compile --fqbn arduino:avr:uno $sketch
          done

      - name: Compile all sketches for ESP8266 platform
        run: |
          # Compile all sketches for ESP8266 platform (NodeMCU v2)
          for sketch in $(find examples -name "*.ino"); do
            arduino-cli compile --fqbn esp8266:esp8266:nodemcuv2 $sketch
          done

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/arduino-lint.yml
================
name: Arduino-lint

on: [push, pull_request]
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: arduino/arduino-lint-action@v1
        with:
          library-manager: update
          # compliance: strict

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/jsoncheck.yml
================
name: JSON check

on:
  push:
    paths:
      - '**.json'
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: json-syntax-check
        uses: limitusus/json-syntax-check@v1
        with:
          pattern: "\\.json$"

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.github/workflows/README.md
================
# 📂 GitHub Workflows for Arduino Temperature Control Library

Automate testing, compilation, and validation of the Arduino Temperature Control Library across multiple platforms using GitHub Actions.

## 🛠️ Workflows Overview

### 1. 📦 Arduino CI Workflow

**Purpose:**  
Compiles the library and its examples for both AVR and ESP8266 platforms.

**Trigger:**  
Runs on every `push` and `pull_request`.

**Key Features:**
- **AVR Compilation:** Compiles all examples for the AVR platform (e.g., Arduino Uno).
- **ESP8266 Compilation:** Compiles all examples for the ESP8266 platform (e.g., NodeMCU v2).
- **Selective Compilation:** Skips ESP-specific examples (e.g., ESP-WebServer) when compiling for AVR.
- **Unit Testing:** Executes unit tests using the `arduino_ci` framework.

### 2. 🔄 Why Separate AVR and ESP Platforms?

The library supports both AVR-based boards (e.g., Arduino Uno) and ESP8266-based boards (e.g., NodeMCU). Some examples utilize ESP-specific libraries like `ESP8266WiFi.h`, which are incompatible with AVR platforms. Separating the compilation ensures:

- **AVR Compatibility:** Skips ESP-specific examples to prevent compilation errors.
- **ESP Compatibility:** Compiles all examples, including ESP-specific ones, for the ESP8266 platform.

### 3. ⚙️ Workflow Steps

The workflow follows these steps:

1. **Setup Environment:**
   - Installs dependencies (e.g., `gcc-avr`, `avr-libc`).
   - Configures the Arduino CLI and installs required cores (`arduino:avr` and `esp8266:esp8266`).

2. **Install Libraries:**
   - Installs the OneWire library.
   - Applies a custom CRC implementation.

3. **Run Unit Tests:**
   - Executes unit tests using the `arduino_ci` framework for the AVR platform.

4. **Compile Examples for AVR:**
   - Compiles all examples (excluding ESP-specific ones) for the AVR platform.

5. **Compile Examples for ESP8266:**
   - Compiles all examples (including ESP-specific ones) for the ESP8266 platform.

### 4. 📁 File Structure

Understanding the project’s file structure is crucial for effective navigation and contribution. Below is an overview of the key files and directories:

- **`Gemfile`**
  - **Description:**  
    Manages Ruby dependencies required for the project. It ensures that the correct versions of gems (like `arduino_ci`) are used.
  - **Usage:**  
    Run `bundle install` to install the necessary gems.

- **`.arduino-ci.yml`**
  - **Description:**  
    Configuration file for the `arduino_ci` tool. It defines how the Arduino CI should run tests and compile sketches.
  - **Key Configurations:**
    - Specifies which boards to target.
    - Defines libraries and dependencies needed for testing.
    - Sets up compilation and testing parameters.

- **`.arduino_ci/`**
  - **Description:**  
    Contains supporting files and configurations for the `arduino_ci.rb` tool.
  - **Contents:**
    - **`config.rb`:**  
      Custom configuration settings for the Arduino CI.
    - **`helpers.rb`:**  
      Helper methods and utilities used by the CI scripts.
    - **Other supporting scripts and assets.**

- **`arduino-ci.yml`**
  - **Description:**  
    GitHub Actions workflow file that defines the CI pipeline for the project.
  - **Key Sections:**
    - **Jobs:**  
      Defines the sequence of steps for setting up the environment, installing dependencies, running tests, and compiling examples.
    - **Triggers:**  
      Specifies when the workflow should run (e.g., on push or pull request).

- **`examples/`**
  - **Description:**  
    Contains example sketches demonstrating how to use the Arduino Temperature Control Library.
  - **Structure:**
    - **`ESP-WebServer/`**  
      ESP-specific examples that utilize libraries like `ESP8266WiFi.h`.

- **`LICENSE`**
  - **Description:**  
    Contains the MIT License under which the project is released.

- **Other Files and Directories:**
  - **`.github/`**
    - Contains GitHub-specific configurations, issues templates, and additional workflows.
  - **`src/`**
    - Contains the source code of the Arduino Temperature Control Library.

### 5. 🔧 Workflow Configuration

The workflow is defined in the `arduino-ci.yml` file. Key configurations include:

- **Cores Installed:**
  ```yaml
  arduino-cli core install arduino:avr
  arduino-cli core install esp8266:esp8266
  ```

- **Skipping ESP-Specific Examples:**
  ```yaml
  export ARDUINO_CI_SKIP_EXAMPLES="ESP-WebServer"
  ```

- **Compiling for AVR and ESP Platforms:**
  ```yaml
  arduino-cli compile --fqbn arduino:avr:uno "$sketch"
  arduino-cli compile --fqbn esp8266:esp8266:nodemcuv2 "$sketch"
  ```

### 6. 🤝 Contributing

If you’re contributing to the workflows, please ensure that:

- **Compatibility:** New examples are compatible with both AVR and ESP platforms (if applicable).
- **Organization:** ESP-specific examples are placed in a clearly labeled directory (e.g., `examples/ESP-WebServer`).
- **Testing:** Unit tests are added or updated as needed.

### 7. 🐞 Troubleshooting

If the workflow fails:

1. **Check Logs:** Navigate to the Actions tab in GitHub for detailed logs.
2. **Local Replication:** Try to replicate the issue locally using the dev container.
3. **Dependencies:** Ensure all dependencies are installed correctly.

## 📄 License

This workflow configuration and scripts are released under the [MIT License](LICENSE).

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/.gitignore
================
.idea
classes
target
out
build
*.iml
*.ipr
*.iws
*.log
*.war
.idea
.project
.classpath
.settings
.gradle
.vscode

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/arduino-cli.yaml
================
board_manager:
  additional_urls: []
daemon:
  port: "50051"
directories:
  data: $GITHUB_WORKSPACE/.arduino15
  downloads: $GITHUB_WORKSPACE/.arduino15/staging
  user: $GITHUB_WORKSPACE/libraries
library:
  enable_unsafe_install: true
logging:
  file: ""
  format: text
  level: info
metrics:
  addr: :9090
  enabled: true
sketch:
  always_export_binaries: false

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/build.sh
================
#!/bin/bash

# Set error handling
set -e

# Function to display usage
show_usage() {
    echo "Usage: ./build.sh [option]"
    echo "Options:"
    echo "  build    - Only compile library and examples"
    echo "  test     - Only compile and run tests"
    echo "  all      - Build everything and run tests (default)"
}

# Function to compile for a specific board
compile_for_board() {
    local fqbn=$1
    local sketch=$2
    echo "📦 Compiling $sketch for $fqbn..."
    arduino-cli compile --fqbn $fqbn "$sketch" --library .
}

# Function to build library and examples
build() {
    echo "🔨 Building library and examples..."
    
    # Compile all examples
    echo "🔍 Compiling examples..."
    for example in examples/*/*.ino; do
        if [ -f "$example" ]; then
            echo "Building example: $example"
            compile_for_board "arduino:avr:uno" "$example"
        fi
    done
}

# Function to run tests
run_tests() {
    echo "🧪 Running tests..."
    for test in test/*/*.ino; do
        if [ -f "$test" ]; then
            echo "Running test: $test"
            compile_for_board "arduino:avr:uno" "$test"
        fi
    done
}

# Main execution
case "${1:-all}" in
    "build")
        build
        ;;
    "test")
        run_tests
        ;;
    "all")
        build
        run_tests
        ;;
    *)
        show_usage
        exit 1
        ;;
esac

echo "✅ Process completed!"

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/CMakeLists.txt
================
# Author: diplfranzhoepfinger 
# reference:  https://docs.espressif.com/projects/arduino-esp32/en/latest/esp-idf_component.html
# URL: https://github.com/milesburton/Arduino-Temperature-Control-Library
# DATE: 15.02.2023

idf_component_register(
    SRCS "DallasTemperature.cpp"
    INCLUDE_DIRS "."
    PRIV_REQUIRES OneWireNg arduino
    )

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/DallasTemperature.cpp
================
#include "DallasTemperature.h"

#if ARDUINO >= 100
#include "Arduino.h"
#else
extern "C" {
#include "WConstants.h"
}
#endif

// OneWire commands
#define STARTCONVO      0x44  // Tells device to take a temperature reading
#define COPYSCRATCH     0x48  // Copy scratchpad to EEPROM
#define READSCRATCH     0xBE  // Read from scratchpad
#define WRITESCRATCH    0x4E  // Write to scratchpad
#define RECALLSCRATCH   0xB8  // Recall from EEPROM to scratchpad
#define READPOWERSUPPLY 0xB4  // Determine if device needs parasite power
#define ALARMSEARCH     0xEC  // Query bus for devices with an alarm condition

// Scratchpad locations
#define TEMP_LSB        0
#define TEMP_MSB        1
#define HIGH_ALARM_TEMP 2
#define LOW_ALARM_TEMP  3
#define CONFIGURATION   4
#define INTERNAL_BYTE   5
#define COUNT_REMAIN    6
#define COUNT_PER_C     7
#define SCRATCHPAD_CRC  8

// Device resolution
#define TEMP_9_BIT  0x1F
#define TEMP_10_BIT 0x3F
#define TEMP_11_BIT 0x5F
#define TEMP_12_BIT 0x7F

#define NO_ALARM_HANDLER ((AlarmHandler *)0)

// DSROM FIELDS
#define DSROM_FAMILY    0
#define DSROM_CRC       7

DallasTemperature::DallasTemperature() {
    _wire = nullptr;
    devices = 0;
    ds18Count = 0;
    parasite = false;
    bitResolution = 9;
    waitForConversion = true;
    checkForConversion = true;
    autoSaveScratchPad = true;
    useExternalPullup = false;
#if REQUIRESALARMS
    setAlarmHandler(NO_ALARM_HANDLER);
    alarmSearchJunction = -1;
    alarmSearchExhausted = 0;
#endif
}

DallasTemperature::DallasTemperature(OneWire* _oneWire) : DallasTemperature() {
    setOneWire(_oneWire);
}

DallasTemperature::DallasTemperature(OneWire* _oneWire, uint8_t _pullupPin) : DallasTemperature(_oneWire) {
    setPullupPin(_pullupPin);
}

void DallasTemperature::setOneWire(OneWire* _oneWire) {
    _wire = _oneWire;
    devices = 0;
    ds18Count = 0;
    parasite = false;
    bitResolution = 9;
    waitForConversion = true;
    checkForConversion = true;
    autoSaveScratchPad = true;
}

void DallasTemperature::setPullupPin(uint8_t _pullupPin) {
    useExternalPullup = true;
    pullupPin = _pullupPin;
    pinMode(pullupPin, OUTPUT);
    deactivateExternalPullup();
}

void DallasTemperature::begin(void) {
    DeviceAddress deviceAddress;
    
    for (uint8_t retry = 0; retry < MAX_INITIALIZATION_RETRIES; retry++) {
        _wire->reset_search();
        devices = 0;
        ds18Count = 0;
        
        delay(INITIALIZATION_DELAY_MS);
        
        while (_wire->search(deviceAddress)) {
            if (validAddress(deviceAddress)) {
                devices++;
                
                if (validFamily(deviceAddress)) {
                    ds18Count++;
                    
                    if (!parasite && readPowerSupply(deviceAddress)) {
                        parasite = true;
                    }
                    
                    uint8_t b = getResolution(deviceAddress);
                    if (b > bitResolution) {
                        bitResolution = b;
                    }
                }
            }
        }
        
        if (devices > 0) break;
    }
}

void DallasTemperature::activateExternalPullup() {
    if (useExternalPullup) digitalWrite(pullupPin, LOW);
}

void DallasTemperature::deactivateExternalPullup() {
    if (useExternalPullup) digitalWrite(pullupPin, HIGH);
}

bool DallasTemperature::validFamily(const uint8_t* deviceAddress) {
    switch (deviceAddress[0]) {
        case DS18S20MODEL:
        case DS18B20MODEL:
        case DS1822MODEL:
        case DS1825MODEL:
        case DS28EA00MODEL:
            return true;
        default:
            return false;
    }
}

bool DallasTemperature::validAddress(const uint8_t* deviceAddress) {
    return (_wire->crc8(const_cast<uint8_t*>(deviceAddress), 7) == deviceAddress[7]);
}

bool DallasTemperature::getAddress(uint8_t* deviceAddress, uint8_t index) {
    if (index < devices) {
        uint8_t depth = 0;
        
        _wire->reset_search();
        
        while (depth <= index && _wire->search(deviceAddress)) {
            if (depth == index && validAddress(deviceAddress)) {
                return true;
            }
            depth++;
        }
    }
    return false;
}

uint8_t DallasTemperature::getDeviceCount(void) {
    return devices;
}

uint8_t DallasTemperature::getDS18Count(void) {
    return ds18Count;
}

bool DallasTemperature::isConnected(const uint8_t* deviceAddress) {
    ScratchPad scratchPad;
    return isConnected(deviceAddress, scratchPad);
}

bool DallasTemperature::isConnected(const uint8_t* deviceAddress, uint8_t* scratchPad) {
    bool b = readScratchPad(deviceAddress, scratchPad);
    return b && !isAllZeros(scratchPad) && (_wire->crc8(scratchPad, 8) == scratchPad[SCRATCHPAD_CRC]);
}

bool DallasTemperature::readPowerSupply(const uint8_t* deviceAddress) {
    bool parasiteMode = false;
    _wire->reset();
    if (deviceAddress == nullptr) {
        _wire->skip();
    } else {
        _wire->select(deviceAddress);
    }
    
    _wire->write(READPOWERSUPPLY);
    if (_wire->read_bit() == 0) {
        parasiteMode = true;
    }
    _wire->reset();
    return parasiteMode;
}

bool DallasTemperature::isParasitePowerMode(void) {
    return parasite;
}

bool DallasTemperature::isAllZeros(const uint8_t* const scratchPad, const size_t length) {
    for (size_t i = 0; i < length; i++) {
        if (scratchPad[i] != 0) return false;
    }
    return true;
}

bool DallasTemperature::readScratchPad(const uint8_t* deviceAddress, uint8_t* scratchPad) {
    int b = _wire->reset();
    if (b == 0) return false;
    
    _wire->select(deviceAddress);
    _wire->write(READSCRATCH);
    
    for (uint8_t i = 0; i < 9; i++) {
        scratchPad[i] = _wire->read();
    }
    
    b = _wire->reset();
    return (b == 1);
}

void DallasTemperature::writeScratchPad(const uint8_t* deviceAddress, const uint8_t* scratchPad) {
    _wire->reset();
    _wire->select(deviceAddress);
    _wire->write(WRITESCRATCH);
    _wire->write(scratchPad[HIGH_ALARM_TEMP]); // high alarm temp
    _wire->write(scratchPad[LOW_ALARM_TEMP]); // low alarm temp
    
    // DS1820 and DS18S20 have no configuration register
    if (deviceAddress[0] != DS18S20MODEL) {
        _wire->write(scratchPad[CONFIGURATION]);
    }
    
    if (autoSaveScratchPad) {
        saveScratchPad(deviceAddress);
    } else {
        _wire->reset();
    }
}

bool DallasTemperature::saveScratchPad(const uint8_t* deviceAddress) {
    if (_wire->reset() == 0) return false;
    
    if (deviceAddress == nullptr)
        _wire->skip();
    else
        _wire->select(deviceAddress);
    
    _wire->write(COPYSCRATCH, parasite);
    
    // Specification: NV Write Cycle Time is typically 2ms, max 10ms
    // Waiting 20ms to allow for sensors that take longer in practice
    if (!parasite) {
        delay(20);
    } else {
        activateExternalPullup();
        delay(20);
        deactivateExternalPullup();
    }
    
    return (_wire->reset() == 1);
}

bool DallasTemperature::recallScratchPad(const uint8_t* deviceAddress) {
    if (_wire->reset() == 0) return false;
    
    if (deviceAddress == nullptr)
        _wire->skip();
    else
        _wire->select(deviceAddress);
    
    _wire->write(RECALLSCRATCH, parasite);
    
    // Specification: Strong pullup only needed when writing to EEPROM
    unsigned long start = millis();
    while (_wire->read_bit() == 0) {
        if (millis() - start > 20) return false;
        yield();
    }
    
    return (_wire->reset() == 1);
}

int32_t DallasTemperature::getTemp(const uint8_t* deviceAddress, byte retryCount) {
    ScratchPad scratchPad;
    byte retries = 0;
    
    while (retries++ <= retryCount) {
        if (isConnected(deviceAddress, scratchPad)) {
            return calculateTemperature(deviceAddress, scratchPad);
        }
    }
    
    return DEVICE_DISCONNECTED_RAW;
}

float DallasTemperature::getTempC(const uint8_t* deviceAddress, byte retryCount) {
    return rawToCelsius(getTemp(deviceAddress, retryCount));
}

float DallasTemperature::getTempF(const uint8_t* deviceAddress) {
    return rawToFahrenheit(getTemp(deviceAddress));
}

float DallasTemperature::getTempCByIndex(uint8_t index) {
    DeviceAddress deviceAddress;
    if (!getAddress(deviceAddress, index)) {
        return DEVICE_DISCONNECTED_C;
    }
    return getTempC((uint8_t*)deviceAddress);
}

float DallasTemperature::getTempFByIndex(uint8_t index) {
    DeviceAddress deviceAddress;
    if (!getAddress(deviceAddress, index)) {
        return DEVICE_DISCONNECTED_F;
    }
    return getTempF((uint8_t*)deviceAddress);
}

void DallasTemperature::setResolution(uint8_t newResolution) {
    bitResolution = constrain(newResolution, 9, 12);
    DeviceAddress deviceAddress;
    _wire->reset_search();
    for (uint8_t i = 0; i < devices; i++) {
        if (_wire->search(deviceAddress) && validAddress(deviceAddress)) {
            setResolution(deviceAddress, bitResolution, true);
        }
    }
}

bool DallasTemperature::setResolution(const uint8_t* deviceAddress, uint8_t newResolution, bool skipGlobalBitResolutionCalculation) {
    bool success = false;
    
    if (deviceAddress[0] == DS18S20MODEL) {
        success = true;
    } else {
        newResolution = constrain(newResolution, 9, 12);
        uint8_t newValue = 0;
        ScratchPad scratchPad;
        
        if (isConnected(deviceAddress, scratchPad)) {
            switch (newResolution) {
                case 12: newValue = TEMP_12_BIT; break;
                case 11: newValue = TEMP_11_BIT; break;
                case 10: newValue = TEMP_10_BIT; break;
                case 9:
                default: newValue = TEMP_9_BIT; break;
            }
            
            if (scratchPad[CONFIGURATION] != newValue) {
                scratchPad[CONFIGURATION] = newValue;
                writeScratchPad(deviceAddress, scratchPad);
            }
            success = true;
        }
    }
    
    if (!skipGlobalBitResolutionCalculation && success) {
        bitResolution = newResolution;
        if (devices > 1) {
            DeviceAddress deviceAddr;
            _wire->reset_search();
            for (uint8_t i = 0; i < devices; i++) {
                if (bitResolution == 12) break;
                if (_wire->search(deviceAddr) && validAddress(deviceAddr)) {
                    uint8_t b = getResolution(deviceAddr);
                    if (b > bitResolution) bitResolution = b;
                }
            }
        }
    }
    return success;
}

uint8_t DallasTemperature::getResolution() {
    return bitResolution;
}

uint8_t DallasTemperature::getResolution(const uint8_t* deviceAddress) {
    if (deviceAddress[0] == DS18S20MODEL) return 12;
    
    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad)) {
        if (deviceAddress[0] == DS1825MODEL && scratchPad[CONFIGURATION] & 0x80) {
            return 12;
        }
        
        switch (scratchPad[CONFIGURATION]) {
            case TEMP_12_BIT: return 12;
            case TEMP_11_BIT: return 11;
            case TEMP_10_BIT: return 10;
            case TEMP_9_BIT: return 9;
        }
    }
    return 0;
}

float DallasTemperature::toFahrenheit(float celsius) {
    return (celsius * 1.8f) + 32.0f;
}

float DallasTemperature::toCelsius(float fahrenheit) {
    return (fahrenheit - 32.0f) * 0.555555556f;
}

float DallasTemperature::rawToCelsius(int32_t raw) {
    if (raw <= DEVICE_DISCONNECTED_RAW)
        return DEVICE_DISCONNECTED_C;
    return (float)raw * 0.0078125f;  // 1/128
}

float DallasTemperature::rawToFahrenheit(int32_t raw) {
    if (raw <= DEVICE_DISCONNECTED_RAW)
        return DEVICE_DISCONNECTED_F;
    return rawToCelsius(raw) * 1.8f + 32.0f;
}

int16_t DallasTemperature::celsiusToRaw(float celsius) {
    return static_cast<int16_t>(celsius * 128.0f);
}

uint16_t DallasTemperature::millisToWaitForConversion(uint8_t bitResolution) {
    switch (bitResolution) {
        case 9:  return 94;
        case 10: return 188;
        case 11: return 375;
        default: return 750;
    }
}

uint16_t DallasTemperature::millisToWaitForConversion() {
    return millisToWaitForConversion(bitResolution);
}

void DallasTemperature::setWaitForConversion(bool flag) {
    waitForConversion = flag;
}

bool DallasTemperature::getWaitForConversion() {
    return waitForConversion;
}

void DallasTemperature::setCheckForConversion(bool flag) {
    checkForConversion = flag;
}

bool DallasTemperature::getCheckForConversion() {
    return checkForConversion;
}

bool DallasTemperature::isConversionComplete() {
    uint8_t b = _wire->read_bit();
    return (b == 1);
}

void DallasTemperature::setAutoSaveScratchPad(bool flag) {
    autoSaveScratchPad = flag;
}

bool DallasTemperature::getAutoSaveScratchPad() {
    return autoSaveScratchPad;
}

DallasTemperature::request_t DallasTemperature::requestTemperatures() {
    request_t req = {};
    req.result = true;
    
    _wire->reset();
    _wire->skip();
    _wire->write(STARTCONVO, parasite);
    
    req.timestamp = millis();
    if (!waitForConversion) return req;
    
    blockTillConversionComplete(bitResolution, req.timestamp);
    return req;
}

DallasTemperature::request_t DallasTemperature::requestTemperaturesByAddress(const uint8_t* deviceAddress) {
    request_t req = {};
    uint8_t deviceBitResolution = getResolution(deviceAddress);
    if (deviceBitResolution == 0) {
        req.result = false;
        return req;
    }
    
    _wire->reset();
    _wire->select(deviceAddress);
    _wire->write(STARTCONVO, parasite);
    
    req.timestamp = millis();
    req.result = true;
    
    if (!waitForConversion) return req;
    
    blockTillConversionComplete(deviceBitResolution, req.timestamp);
    return req;
}

DallasTemperature::request_t DallasTemperature::requestTemperaturesByIndex(uint8_t index) {
    DeviceAddress deviceAddress;
    getAddress(deviceAddress, index);
    return requestTemperaturesByAddress(deviceAddress);
}

void DallasTemperature::blockTillConversionComplete(uint8_t bitResolution) {
    unsigned long start = millis();
    blockTillConversionComplete(bitResolution, start);
}

void DallasTemperature::blockTillConversionComplete(uint8_t bitResolution, unsigned long start) {
    if (checkForConversion && !parasite) {
        while (!isConversionComplete() && ((unsigned long)(millis() - start) < (unsigned long)MAX_CONVERSION_TIMEOUT)) {
            yield();
        }
    } else {
        unsigned long delayInMillis = millisToWaitForConversion(bitResolution);
        activateExternalPullup();
        delay(delayInMillis);
        deactivateExternalPullup();
    }
}

void DallasTemperature::blockTillConversionComplete(uint8_t bitResolution, request_t req) {
    if (req.result) {
        blockTillConversionComplete(bitResolution, req.timestamp);
    }
}

int32_t DallasTemperature::calculateTemperature(const uint8_t* deviceAddress, uint8_t* scratchPad) {
    int32_t fpTemperature = 0;

    // looking thru the spec sheets of all supported devices, bit 15 is always the signing bit
    int32_t neg = 0x0;
    if (scratchPad[TEMP_MSB] & 0x80)
        neg = 0xFFF80000;

    // detect MAX31850
    if (deviceAddress[0] == DS1825MODEL && scratchPad[CONFIGURATION] & 0x80) {
        if (scratchPad[TEMP_LSB] & 1) { // Fault Detected
            if (scratchPad[HIGH_ALARM_TEMP] & 1) {
                return DEVICE_FAULT_OPEN_RAW;
            } else if (scratchPad[HIGH_ALARM_TEMP] >> 1 & 1) {
                return DEVICE_FAULT_SHORTGND_RAW;
            } else if (scratchPad[HIGH_ALARM_TEMP] >> 2 & 1) {
                return DEVICE_FAULT_SHORTVDD_RAW;
            } else {
                return DEVICE_DISCONNECTED_RAW;
            }
        }
        // We must mask out bit 1 (reserved) and 0 (fault) on TEMP_LSB
        fpTemperature = (((int32_t)scratchPad[TEMP_MSB]) << 11)
                       | (((int32_t)scratchPad[TEMP_LSB] & 0xFC) << 3)
                       | neg;
    } else {
        fpTemperature = (((int16_t)scratchPad[TEMP_MSB]) << 11)
                       | (((int16_t)scratchPad[TEMP_LSB]) << 3)
                       | neg;
    }

  /*
   DS1820 and DS18S20 have a 9-bit temperature register.

   Resolutions greater than 9-bit can be calculated using the data from
   the temperature, and COUNT REMAIN and COUNT PER °C registers in the
   scratchpad.  The resolution of the calculation depends on the model.

   While the COUNT PER °C register is hard-wired to 16 (10h) in a
   DS18S20, it changes with temperature in DS1820.

   After reading the scratchpad, the TEMP_READ value is obtained by
   truncating the 0.5°C bit (bit 0) from the temperature data. The
   extended resolution temperature can then be calculated using the
   following equation:

                                    COUNT_PER_C - COUNT_REMAIN
   TEMPERATURE = TEMP_READ - 0.25 + --------------------------
                                           COUNT_PER_C

   Hagai Shatz simplified this to integer arithmetic for a 12 bits
   value for a DS18S20, and James Cameron added legacy DS1820 support.

   See - http://myarduinotoy.blogspot.co.uk/2013/02/12bit-result-from-ds18s20.html
   */
  
  if ((deviceAddress[DSROM_FAMILY] == DS18S20MODEL) && (scratchPad[COUNT_PER_C] != 0)) {
    fpTemperature = (((fpTemperature & 0xfff0) << 3) - 32
                    + (((scratchPad[COUNT_PER_C] - scratchPad[COUNT_REMAIN]) << 7)
                       / scratchPad[COUNT_PER_C])) | neg;
  }

    return fpTemperature;
}

#if REQUIRESALARMS

void DallasTemperature::setAlarmHandler(const AlarmHandler* handler) {
    _AlarmHandler = handler;
}

void DallasTemperature::setHighAlarmTemp(const uint8_t* deviceAddress, int8_t celsius) {
    // make sure the alarm temperature is within the device's range
    if (celsius > 125) celsius = 125;
    else if (celsius < -55) celsius = -55;

    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad)) {
        scratchPad[HIGH_ALARM_TEMP] = (uint8_t)celsius;
        writeScratchPad(deviceAddress, scratchPad);
    }
}

void DallasTemperature::setLowAlarmTemp(const uint8_t* deviceAddress, int8_t celsius) {
    // make sure the alarm temperature is within the device's range
    if (celsius > 125) celsius = 125;
    else if (celsius < -55) celsius = -55;

    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad)) {
        scratchPad[LOW_ALARM_TEMP] = (uint8_t)celsius;
        writeScratchPad(deviceAddress, scratchPad);
    }
}

int8_t DallasTemperature::getHighAlarmTemp(const uint8_t* deviceAddress) {
    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad))
        return (int8_t)scratchPad[HIGH_ALARM_TEMP];
    return DEVICE_DISCONNECTED_C;
}

int8_t DallasTemperature::getLowAlarmTemp(const uint8_t* deviceAddress) {
    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad))
        return (int8_t)scratchPad[LOW_ALARM_TEMP];
    return DEVICE_DISCONNECTED_C;
}

void DallasTemperature::resetAlarmSearch() {
    alarmSearchJunction = -1;
    alarmSearchExhausted = 0;
    for (uint8_t i = 0; i < 7; i++) {
        alarmSearchAddress[i] = 0;
    }
}

bool DallasTemperature::alarmSearch(uint8_t* newAddr) {
    uint8_t i;
    int8_t lastJunction = -1;
    uint8_t done = 1;

    if (alarmSearchExhausted)
        return false;

    if (!_wire->reset())
        return false;

    _wire->write(ALARMSEARCH);

    for (i = 0; i < 64; i++) {
        uint8_t a = _wire->read_bit();
        uint8_t nota = _wire->read_bit();
        uint8_t ibyte = i / 8;
        uint8_t ibit = 1 << (i & 7);

        if (a && nota)
            return false;

        if (!a && !nota) {
            if (i == alarmSearchJunction) {
                a = 1;
                alarmSearchJunction = lastJunction;
            } else if (i < alarmSearchJunction) {
                if (alarmSearchAddress[ibyte] & ibit) {
                    a = 1;
                } else {
                    a = 0;
                    done = 0;
                    lastJunction = i;
                }
            } else {
                a = 0;
                alarmSearchJunction = i;
                done = 0;
            }
        }

        if (a)
            alarmSearchAddress[ibyte] |= ibit;
        else
            alarmSearchAddress[ibyte] &= ~ibit;

        _wire->write_bit(a);
    }

    if (done)
        alarmSearchExhausted = 1;
    for (i = 0; i < 8; i++)
        newAddr[i] = alarmSearchAddress[i];
    return true;
}

bool DallasTemperature::hasAlarm(const uint8_t* deviceAddress) {
    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad)) {
        int8_t temp = calculateTemperature(deviceAddress, scratchPad) >> 7;
        return (temp <= (int8_t)scratchPad[LOW_ALARM_TEMP] || 
                temp >= (int8_t)scratchPad[HIGH_ALARM_TEMP]);
    }
    return false;
}

bool DallasTemperature::hasAlarm(void) {
    DeviceAddress deviceAddress;
    resetAlarmSearch();
    return alarmSearch(deviceAddress);
}

void DallasTemperature::processAlarms(void) {
    if (!hasAlarmHandler())
        return;

    resetAlarmSearch();
    DeviceAddress alarmAddr;

    while (alarmSearch(alarmAddr)) {
        if (validAddress(alarmAddr)) {
            _AlarmHandler(alarmAddr);
        }
    }
}

bool DallasTemperature::hasAlarmHandler() {
    return (_AlarmHandler != NO_ALARM_HANDLER);
}

#endif

#if REQUIRESNEW

void* DallasTemperature::operator new(unsigned int size) {
    void* p = malloc(size);
    memset(p, 0, size);
    return p;
}

void DallasTemperature::operator delete(void* p) {
    free(p);
}

#endif

bool DallasTemperature::verifyDeviceCount(void) {
    uint8_t actualCount = 0;
    float temp;
    
    requestTemperatures();
    
    do {
        temp = getTempCByIndex(actualCount);
        if (temp > DEVICE_DISCONNECTED_C) {
            actualCount++;
        }
    } while (temp > DEVICE_DISCONNECTED_C && actualCount < 255);
    
    if (actualCount > devices) {
        devices = actualCount;
        begin();
        return true;
    }
    
    return false;
}

void DallasTemperature::setUserData(const uint8_t* deviceAddress, int16_t data) {
    // return when stored value == new value
    if (getUserData(deviceAddress) == data)
        return;

    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad)) {
        scratchPad[HIGH_ALARM_TEMP] = data >> 8;
        scratchPad[LOW_ALARM_TEMP] = data & 255;
        writeScratchPad(deviceAddress, scratchPad);
    }
}

void DallasTemperature::setUserDataByIndex(uint8_t deviceIndex, int16_t data) {
    DeviceAddress deviceAddress;
    if (getAddress(deviceAddress, deviceIndex)) {
        setUserData((uint8_t*)deviceAddress, data);
    }
}

int16_t DallasTemperature::getUserData(const uint8_t* deviceAddress) {
    int16_t data = 0;
    ScratchPad scratchPad;
    if (isConnected(deviceAddress, scratchPad)) {
        data = scratchPad[HIGH_ALARM_TEMP] << 8;
        data += scratchPad[LOW_ALARM_TEMP];
    }
    return data;
}

int16_t DallasTemperature::getUserDataByIndex(uint8_t deviceIndex) {
    DeviceAddress deviceAddress;
    getAddress(deviceAddress, deviceIndex);
    return getUserData((uint8_t*)deviceAddress);
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/DallasTemperature.h
================
#ifndef DallasTemperature_h
#define DallasTemperature_h

#define DALLASTEMPLIBVERSION "4.0.4"

// Configuration
#ifndef REQUIRESNEW
#define REQUIRESNEW false
#endif

#ifndef REQUIRESALARMS
#define REQUIRESALARMS true
#endif

// Includes
#include <inttypes.h>
#include <Arduino.h>

#ifdef __STM32F1__
#include <OneWireSTM.h>
#else
#include <OneWire.h>
#endif

// Constants for device models
#define DS18S20MODEL 0x10  // also DS1820
#define DS18B20MODEL 0x28  // also MAX31820
#define DS1822MODEL  0x22
#define DS1825MODEL  0x3B  // also MAX31850
#define DS28EA00MODEL 0x42

// Error Codes
#define DEVICE_DISCONNECTED_C -127
#define DEVICE_DISCONNECTED_F -196.6
#define DEVICE_DISCONNECTED_RAW -7040

#define DEVICE_FAULT_OPEN_C -254
#define DEVICE_FAULT_OPEN_F -425.199982
#define DEVICE_FAULT_OPEN_RAW -32512

#define DEVICE_FAULT_SHORTGND_C -253
#define DEVICE_FAULT_SHORTGND_F -423.399994
#define DEVICE_FAULT_SHORTGND_RAW -32384

#define DEVICE_FAULT_SHORTVDD_C -252
#define DEVICE_FAULT_SHORTVDD_F -421.599976
#define DEVICE_FAULT_SHORTVDD_RAW -32256

// Configuration Constants
#define MAX_CONVERSION_TIMEOUT 750
#define MAX_INITIALIZATION_RETRIES 3
#define INITIALIZATION_DELAY_MS 50

typedef uint8_t DeviceAddress[8];

class DallasTemperature {
public:
    struct request_t {
        bool result;
        unsigned long timestamp;
        operator bool() { return result; }
    };
    
    // Constructors
    DallasTemperature();
    DallasTemperature(OneWire*);
    DallasTemperature(OneWire*, uint8_t);

    // Setup & Configuration
    void setOneWire(OneWire*);
    void setPullupPin(uint8_t);
    void begin(void);
    bool verifyDeviceCount(void);

    // Device Information
    uint8_t getDeviceCount(void);
    uint8_t getDS18Count(void);
    bool validAddress(const uint8_t*);
    bool validFamily(const uint8_t* deviceAddress);
    bool getAddress(uint8_t*, uint8_t);
    bool isConnected(const uint8_t*);
    bool isConnected(const uint8_t*, uint8_t*);

    // Scratchpad Operations
    bool readScratchPad(const uint8_t*, uint8_t*);
    void writeScratchPad(const uint8_t*, const uint8_t*);
    bool readPowerSupply(const uint8_t* deviceAddress = nullptr);

    // Resolution Control
    uint8_t getResolution();
    void setResolution(uint8_t);
    uint8_t getResolution(const uint8_t*);
    bool setResolution(const uint8_t*, uint8_t, bool skipGlobalBitResolutionCalculation = false);

    // Conversion Configuration
    void setWaitForConversion(bool);
    bool getWaitForConversion(void);
    void setCheckForConversion(bool);
    bool getCheckForConversion(void);

    // Temperature Operations
    request_t requestTemperatures(void);
    request_t requestTemperaturesByAddress(const uint8_t*);
    request_t requestTemperaturesByIndex(uint8_t);
    int32_t getTemp(const uint8_t*, byte retryCount = 0);
    float getTempC(const uint8_t*, byte retryCount = 0);
    float getTempF(const uint8_t*);
    float getTempCByIndex(uint8_t);
    float getTempFByIndex(uint8_t);

    // Conversion Status
    bool isParasitePowerMode(void);
    bool isConversionComplete(void);
    static uint16_t millisToWaitForConversion(uint8_t);
    uint16_t millisToWaitForConversion();

    // EEPROM Operations
    bool saveScratchPadByIndex(uint8_t);
    bool saveScratchPad(const uint8_t* = nullptr);
    bool recallScratchPadByIndex(uint8_t);
    bool recallScratchPad(const uint8_t* = nullptr);
    void setAutoSaveScratchPad(bool);
    bool getAutoSaveScratchPad(void);

#if REQUIRESALARMS
    typedef void AlarmHandler(const uint8_t*);
    void setHighAlarmTemp(const uint8_t*, int8_t);
    void setLowAlarmTemp(const uint8_t*, int8_t);
    int8_t getHighAlarmTemp(const uint8_t*);
    int8_t getLowAlarmTemp(const uint8_t*);
    void resetAlarmSearch(void);
    bool alarmSearch(uint8_t*);
    bool hasAlarm(const uint8_t*);
    bool hasAlarm(void);
    void processAlarms(void);
    void setAlarmHandler(const AlarmHandler*);
    bool hasAlarmHandler();
#endif

    // User Data Operations
    void setUserData(const uint8_t*, int16_t);
    void setUserDataByIndex(uint8_t, int16_t);
    int16_t getUserData(const uint8_t*);
    int16_t getUserDataByIndex(uint8_t);

    // Temperature Conversion Utilities
    static float toFahrenheit(float);
    static float toCelsius(float);
    static float rawToCelsius(int32_t);
    static int16_t celsiusToRaw(float);
    static float rawToFahrenheit(int32_t);

#if REQUIRESNEW
    void* operator new(unsigned int);
    void operator delete(void*);
#endif

    // Conversion Completion Methods
    void blockTillConversionComplete(uint8_t);
    void blockTillConversionComplete(uint8_t, unsigned long);
    void blockTillConversionComplete(uint8_t, request_t);

private:
    typedef uint8_t ScratchPad[9];

    // Internal State
    bool parasite;
    bool useExternalPullup;
    uint8_t pullupPin;
    uint8_t bitResolution;
    bool waitForConversion;
    bool checkForConversion;
    bool autoSaveScratchPad;
    uint8_t devices;
    uint8_t ds18Count;
    OneWire* _wire;

    // Internal Methods
    int32_t calculateTemperature(const uint8_t*, uint8_t*);
    bool isAllZeros(const uint8_t* const scratchPad, const size_t length = 9);
    void activateExternalPullup(void);
    void deactivateExternalPullup(void);

#if REQUIRESALARMS
    uint8_t alarmSearchAddress[8];
    int8_t alarmSearchJunction;
    uint8_t alarmSearchExhausted;
    AlarmHandler* _AlarmHandler;
#endif
};

#endif // DallasTemperature_h

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Alarm/Alarm.ino
================
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

// arrays to hold device addresses
DeviceAddress insideThermometer, outsideThermometer;

void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // Start up the library
  sensors.begin();

  // locate devices on the bus
  Serial.print("Found ");
  Serial.print(sensors.getDeviceCount(), DEC);
  Serial.println(" devices.");

  // search for devices on the bus and assign based on an index.
  if (!sensors.getAddress(insideThermometer, 0)) Serial.println("Unable to find address for Device 0");
  if (!sensors.getAddress(outsideThermometer, 1)) Serial.println("Unable to find address for Device 1");

  // show the addresses we found on the bus
  Serial.print("Device 0 Address: ");
  printAddress(insideThermometer);
  Serial.println();

  Serial.print("Device 0 Alarms: ");
  printAlarms(insideThermometer);
  Serial.println();

  Serial.print("Device 1 Address: ");
  printAddress(outsideThermometer);
  Serial.println();

  Serial.print("Device 1 Alarms: ");
  printAlarms(outsideThermometer);
  Serial.println();

  Serial.println("Setting alarm temps...");

  // alarm when temp is higher than 30C
  sensors.setHighAlarmTemp(insideThermometer, 30);

  // alarm when temp is lower than -10C
  sensors.setLowAlarmTemp(insideThermometer, -10);

  // alarm when temp is higher than 31C
  sensors.setHighAlarmTemp(outsideThermometer, 31);

  // alarn when temp is lower than 27C
  sensors.setLowAlarmTemp(outsideThermometer, 27);

  Serial.print("New Device 0 Alarms: ");
  printAlarms(insideThermometer);
  Serial.println();

  Serial.print("New Device 1 Alarms: ");
  printAlarms(outsideThermometer);
  Serial.println();
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

// function to print the temperature for a device
void printTemperature(DeviceAddress deviceAddress)
{
  float tempC = sensors.getTempC(deviceAddress);
  Serial.print("Temp C: ");
  Serial.print(tempC);
  Serial.print(" Temp F: ");
  Serial.print(DallasTemperature::toFahrenheit(tempC));
}

void printAlarms(uint8_t deviceAddress[])
{
  char temp;
  temp = sensors.getHighAlarmTemp(deviceAddress);
  Serial.print("High Alarm: ");
  Serial.print(temp, DEC);
  Serial.print("C/");
  Serial.print(DallasTemperature::toFahrenheit(temp));
  Serial.print("F | Low Alarm: ");
  temp = sensors.getLowAlarmTemp(deviceAddress);
  Serial.print(temp, DEC);
  Serial.print("C/");
  Serial.print(DallasTemperature::toFahrenheit(temp));
  Serial.print("F");
}

// main function to print information about a device
void printData(DeviceAddress deviceAddress)
{
  Serial.print("Device Address: ");
  printAddress(deviceAddress);
  Serial.print(" ");
  printTemperature(deviceAddress);
  Serial.println();
}

void checkAlarm(DeviceAddress deviceAddress)
{
  if (sensors.hasAlarm(deviceAddress))
  {
    Serial.print("ALARM: ");
    printData(deviceAddress);
  }
}

void loop(void)
{
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures();
  Serial.println("DONE");

  // Method 1:
  // check each address individually for an alarm condition
  checkAlarm(insideThermometer);
  checkAlarm(outsideThermometer);
/*
  // Alternate method:
  // Search the bus and iterate through addresses of devices with alarms

  // space for the alarm device's address
  DeviceAddress alarmAddr;

  Serial.println("Searching for alarms...");

  // resetAlarmSearch() must be called before calling alarmSearch()
  sensors.resetAlarmSearch();

  // alarmSearch() returns 0 when there are no devices with alarms
  while (sensors.alarmSearch(alarmAddr))
  {
    Serial.print("ALARM: ");
    printData(alarmAddr);
  }
*/

}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/AlarmHandler/AlarmHandler.ino
================
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

// arrays to hold device addresses
DeviceAddress insideThermometer, outsideThermometer;

// function that will be called when an alarm condition exists during DallasTemperatures::processAlarms();
void newAlarmHandler(const uint8_t* deviceAddress)
{
  Serial.println("Alarm Handler Start");
  printAlarmInfo(deviceAddress);
  printTemp(deviceAddress);
  Serial.println();
  Serial.println("Alarm Handler Finish");
}

void printCurrentTemp(DeviceAddress deviceAddress)
{
  printAddress(deviceAddress);
  printTemp(deviceAddress);
  Serial.println();
}

void printAddress(const DeviceAddress deviceAddress)
{
  Serial.print("Address: ");
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
  Serial.print(" ");
}

void printTemp(const DeviceAddress deviceAddress)
{
  float tempC = sensors.getTempC(deviceAddress);
  if (tempC != DEVICE_DISCONNECTED_C)
  {
    Serial.print("Current Temp C: ");
    Serial.print(tempC);
  }
  else Serial.print("DEVICE DISCONNECTED");
  Serial.print(" ");
}

void printAlarmInfo(const DeviceAddress deviceAddress)
{
  char temp;
  printAddress(deviceAddress);
  temp = sensors.getHighAlarmTemp(deviceAddress);
  Serial.print("High Alarm: ");
  Serial.print(temp, DEC);
  Serial.print("C");
  Serial.print(" Low Alarm: ");
  temp = sensors.getLowAlarmTemp(deviceAddress);
  Serial.print(temp, DEC);
  Serial.print("C");
  Serial.print(" ");
}

void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // Start up the library
  sensors.begin();

  // locate devices on the bus
  Serial.print("Found ");
  Serial.print(sensors.getDeviceCount(), DEC);
  Serial.println(" devices.");

  // search for devices on the bus and assign based on an index
  if (!sensors.getAddress(insideThermometer, 0)) Serial.println("Unable to find address for Device 0");
  if (!sensors.getAddress(outsideThermometer, 1)) Serial.println("Unable to find address for Device 1");

  Serial.print("Device insideThermometer ");
  printAlarmInfo(insideThermometer);
  Serial.println();

  Serial.print("Device outsideThermometer ");
  printAlarmInfo(outsideThermometer);
  Serial.println();

  // set alarm ranges
  Serial.println("Setting alarm temps...");
  sensors.setHighAlarmTemp(insideThermometer, 26);
  sensors.setLowAlarmTemp(insideThermometer, 22);
  sensors.setHighAlarmTemp(outsideThermometer, 25);
  sensors.setLowAlarmTemp(outsideThermometer, 21);

  Serial.print("New insideThermometer ");
  printAlarmInfo(insideThermometer);
  Serial.println();

  Serial.print("New outsideThermometer ");
  printAlarmInfo(outsideThermometer);
  Serial.println();

  // attach alarm handler
  sensors.setAlarmHandler(&newAlarmHandler);

}

void loop(void)
{
  // ask the devices to measure the temperature
  sensors.requestTemperatures();

  // if an alarm condition exists as a result of the most recent
  // requestTemperatures() request, it exists until the next time
  // requestTemperatures() is called AND there isn't an alarm condition
  // on the device
  if (sensors.hasAlarm())
  {
    Serial.println("Oh noes!  There is at least one alarm on the bus.");
  }

  // call alarm handler function defined by sensors.setAlarmHandler
  // for each device reporting an alarm
  sensors.processAlarms();

  if (!sensors.hasAlarm())
  {
    // just print out the current temperature
    printCurrentTemp(insideThermometer);
    printCurrentTemp(outsideThermometer);
  }

  delay(1000);
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/ESP-WebServer/ESP-WebServer.ino
================
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <OneWire.h>
#include <DallasTemperature.h>

/*
  SETUP INSTRUCTIONS
  
  1) Change WiFi SSID and Password:
      const char* ssid = "YourSSID";
      const char* password = "YourPassword";

  2) Polling Interval (milliseconds):
      const unsigned long READ_INTERVAL = 10000; // 10 seconds

  3) Number of Readings (History Length):
      const int HISTORY_LENGTH = 360; // 1 hour at 10-second intervals
*/

const char* ssid = "YourSSID";
const char* password = "YourPassword";

const int oneWireBus = 4;
const int MAX_SENSORS = 8;
const int HISTORY_LENGTH = 360; 
const unsigned long READ_INTERVAL = 10000;

DeviceAddress sensorAddresses[MAX_SENSORS];
float tempHistory[MAX_SENSORS][HISTORY_LENGTH];
int historyIndex = 0;
int numberOfDevices = 0;
unsigned long lastReadTime = 0;

OneWire oneWire(oneWireBus);
DallasTemperature sensors(&oneWire);
ESP8266WebServer server(80);

String getAddressString(DeviceAddress deviceAddress);
void handleRoot();
void handleSensorList();
void handleTemperature();
void handleHistory();
void updateHistory();

const char MAIN_page[] PROGMEM = R"=====(
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0">
  <title>Arduino Temperature Control Library - Sensor Data Graph</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.1.2/dist/tailwind.min.css"
        rel="stylesheet">
</head>
<body class="bg-gray-100 font-sans min-h-screen flex flex-col">
  <div class="container mx-auto p-6 flex-grow">
    <h1 class="text-2xl font-semibold text-gray-800 mb-4">
      Arduino Temperature Control Library - Sensor Data
    </h1>

    <div class="flex mb-6">
      <div class="cursor-pointer px-4 py-2 bg-blue-500 text-white rounded-lg shadow
                  hover:bg-blue-400 active:scale-95"
           onclick="showTab('dashboard')">
        Dashboard
      </div>
      <div class="cursor-pointer px-4 py-2 bg-gray-200 rounded-lg shadow
                  hover:bg-gray-300 active:scale-95 ml-4"
           onclick="showTab('api')">
        API Docs
      </div>
      <div class="cursor-pointer px-4 py-2 bg-gray-200 rounded-lg shadow
                  hover:bg-gray-300 active:scale-95 ml-4"
           onclick="showTab('setup')">
        Setup
      </div>
    </div>

    <div id="dashboard" class="tab-content">
      <button class="px-6 py-2 bg-green-500 text-white rounded-lg shadow
                     hover:bg-green-400 active:scale-95"
              onclick="refreshData()">
        Refresh Data
      </button>
      <div id="sensors" class="mt-6">
        <div class="text-gray-600">Loading sensor data...</div>
      </div>
    </div>

    <div id="api" class="tab-content hidden mt-8">
      <h2 class="text-xl font-semibold text-gray-800 mb-4">API</h2>
      <div class="bg-white p-6 rounded-lg shadow">
        <div class="mb-4">
          <span class="font-semibold text-blue-500">GET</span>
          <a href="/temperature" class="text-blue-500 hover:underline">/temperature</a>
          <pre class="bg-gray-100 p-4 rounded mt-2">
{
  "sensors": [
    {
      "id": 0,
      "address": "28FF457D1234AB12",
      "celsius": 23.45,
      "fahrenheit": 74.21
    }
  ]
}
          </pre>
        </div>
        <div class="mb-4">
          <span class="font-semibold text-blue-500">GET</span>
          <a href="/sensors" class="text-blue-500 hover:underline">/sensors</a>
          <pre class="bg-gray-100 p-4 rounded mt-2">
{
  "sensors": [
    {
      "id": 0,
      "address": "28FF457D1234AB12"
    }
  ]
}
          </pre>
        </div>
        <div>
          <span class="font-semibold text-blue-500">GET</span>
          <a href="/history" class="text-blue-500 hover:underline">/history</a>
          <pre class="bg-gray-100 p-4 rounded mt-2">
{
  "interval_ms": 10000,
  "sensors": [
    {
      "id": 0,
      "address": "28FF457D1234AB12",
      "history": [23.45, 23.50, 23.48]
    }
  ]
}
          </pre>
        </div>
      </div>
    </div>

    <div id="setup" class="tab-content hidden mt-8">
      <h2 class="text-xl font-semibold text-gray-800 mb-4">Setup Instructions</h2>
      <div class="bg-white p-6 rounded-lg shadow leading-relaxed">
        <p class="mb-4">
          Edit the .ino code to change SSID, password, read interval, and number
          of stored readings (HISTORY_LENGTH).
        </p>
      </div>
    </div>
  </div>

  <footer class="bg-gray-800 text-white p-4 mt-auto text-center">
    <p>&copy; 2025 Miles Burton. All Rights Reserved.</p>
    <p>
      Licensed under the 
      <a href="https://opensource.org/licenses/MIT" class="text-blue-400 hover:underline">
        MIT License
      </a>.
    </p>
  </footer>

  <script>
    const showTab = (name) => {
      document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
      document.getElementById(name).classList.remove('hidden');
    };
    const buildSensorsHTML = (sensors) => {
      return sensors.map(s => {
        const chartId = "chart-" + s.id;
        return `
          <div class="bg-white p-6 rounded-lg shadow mb-6">
            <div class="text-lg font-semibold text-blue-500">
              ${s.celsius.toFixed(2)}°C / ${s.fahrenheit.toFixed(2)}°F
            </div>
            <div class="text-sm text-gray-600 mt-2">
              Sensor ID: ${s.id} (${s.address})
            </div>
            <div class="mt-4" style="height: 300px;">
              <canvas id="${chartId}"></canvas>
            </div>
          </div>
        `;
      }).join('');
    };
    const drawChart = (chartId, dataPoints) => {
      const ctx = document.getElementById(chartId);
      if (!ctx) return;
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: dataPoints.map(p => p.x),
          datasets: [{
            label: 'Temp (°C)',
            data: dataPoints,
            borderColor: 'red',
            backgroundColor: 'rgba(255,0,0,0.1)',
            borderWidth: 2,
            pointRadius: 3,
            lineTension: 0.1,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: (ctx) => {
                  const t = ctx.parsed.x;
                  const d = new Date(t);
                  return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)}°C at ${d.toLocaleTimeString()}`;
                }
              }
            }
          },
          interaction: { mode: 'nearest', intersect: true },
          scales: {
            x: {
              type: 'linear',
              position: 'bottom',
              ticks: {
                autoSkip: true,
                maxTicksLimit: 10,
                callback: (v) => new Date(v).toLocaleTimeString()
              }
            },
            y: {
              grid: { color: 'rgba(0,0,0,0.05)' }
            }
          }
        }
      });
    };
    const refreshData = async () => {
      try {
        const sensorsDiv = document.getElementById('sensors');
        sensorsDiv.innerHTML = '<div class="text-gray-600">Loading sensor data...</div>';
        const td = await fetch('/temperature');
        const tempData = await td.json();
        const hd = await fetch('/history');
        const historyData = await hd.json();
        sensorsDiv.innerHTML = buildSensorsHTML(tempData.sensors);
        tempData.sensors.forEach(s => {
          const chartId = "chart-" + s.id;
          const sensorHist = historyData.sensors.find(h => h.id === s.id);
          if (!sensorHist) return;
          const total = sensorHist.history.length;
          const arr = sensorHist.history.map((v, i) => {
            return { x: Date.now() - (total - 1 - i)*10000, y: v };
          });
          drawChart(chartId, arr);
        });
      } catch(e) {
        console.error(e);
        document.getElementById('sensors').innerHTML = 
          '<div class="text-gray-600">Error loading data.</div>';
      }
    };
    refreshData();
    setInterval(refreshData, 30000);
  </script>
</body>
</html>
)=====";

void setup() {
  Serial.begin(115200);
  Serial.println(WiFi.localIP());
  sensors.begin();

  for (int i = 0; i < MAX_SENSORS; i++) {
    for (int j = 0; j < HISTORY_LENGTH; j++) {
      tempHistory[i][j] = 0;
    }
  }

  numberOfDevices = sensors.getDeviceCount();
  if (numberOfDevices > MAX_SENSORS) {
    numberOfDevices = MAX_SENSORS;
  }

  for (int i = 0; i < numberOfDevices; i++) {
    sensors.getAddress(sensorAddresses[i], i);
  }

  sensors.setResolution(12);

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }

  server.on("/", HTTP_GET, handleRoot);
  server.on("/temperature", HTTP_GET, handleTemperature);
  server.on("/sensors", HTTP_GET, handleSensorList);
  server.on("/history", HTTP_GET, handleHistory);

  server.begin();
}

void loop() {
  server.handleClient();
  unsigned long t = millis();
  if (t - lastReadTime >= READ_INTERVAL) {
    updateHistory();
    lastReadTime = t;
  }
}

void updateHistory() {
  sensors.requestTemperatures();
  for (int i = 0; i < numberOfDevices; i++) {
    float tempC = sensors.getTempC(sensorAddresses[i]);
    tempHistory[i][historyIndex] = tempC;
  }
  historyIndex = (historyIndex + 1) % HISTORY_LENGTH;
}

void handleRoot() {
  server.send(200, "text/html", MAIN_page);
}

void handleSensorList() {
  String json = "{\"sensors\":[";
  for (int i = 0; i < numberOfDevices; i++) {
    if (i > 0) json += ",";
    json += "{\"id\":" + String(i) + ",\"address\":\"" + getAddressString(sensorAddresses[i]) + "\"}";
  }
  json += "]}";
  server.send(200, "application/json", json);
}

void handleTemperature() {
  sensors.requestTemperatures();
  String json = "{\"sensors\":[";
  for (int i = 0; i < numberOfDevices; i++) {
    if (i > 0) json += ",";
    float c = sensors.getTempC(sensorAddresses[i]);
    float f = sensors.toFahrenheit(c);
    json += "{\"id\":" + String(i) + ",\"address\":\"" + getAddressString(sensorAddresses[i]) + "\",";
    json += "\"celsius\":" + String(c) + ",\"fahrenheit\":" + String(f) + "}";
  }
  json += "]}";
  server.send(200, "application/json", json);
}

void handleHistory() {
  String json = "{\"interval_ms\":" + String(READ_INTERVAL) + ",\"sensors\":[";
  for (int i = 0; i < numberOfDevices; i++) {
    if (i > 0) json += ",";
    json += "{\"id\":" + String(i) + ",\"address\":\"" + getAddressString(sensorAddresses[i]) + "\",\"history\":[";
    for (int j = 0; j < HISTORY_LENGTH; j++) {
      int idx = (historyIndex - j + HISTORY_LENGTH) % HISTORY_LENGTH;
      if (j > 0) json += ",";
      json += String(tempHistory[i][idx]);
    }
    json += "]}";
  }
  json += "]}";
  server.send(200, "application/json", json);
}

String getAddressString(DeviceAddress deviceAddress) {
  String addr;
  for (uint8_t i = 0; i < 8; i++) {
    if (deviceAddress[i] < 16) addr += "0";
    addr += String(deviceAddress[i], HEX);
  }
  return addr;
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/ESP-WebServer/README.md
================
# 🌡️ Arduino Sketch: DS18B20 Sensor via Wi-Fi (REST Endpoints & Dashboard)

This **example Sketch** demonstrates how to use the [Arduino Temperature Control Library](https://github.com/milesburton/Arduino-Temperature-Control-Library) on an **ESP8266** or **ESP32** to read temperature data from **Maxim (Dallas) DS18B20** sensors. The Sketch publishes the readings via Wi-Fi in two ways:

1. **REST Endpoints** - Ideal for Node-RED, Home Assistant, or other automation platforms.
2. **A Human-Friendly Dashboard** - A simple web interface, powered by [Chart.js](https://www.chartjs.org/) and [Tailwind CSS](https://tailwindcss.com/), displaying current and historical temperatures.

---

## 🔎 Features
- Reads from one or more **DS18B20** temperature sensors
- Configurable **polling interval** (in milliseconds) and **history length** (number of readings)
- **Lightweight dashboard** that visualises the last N readings
- **REST endpoints** for easy integration:
  - `/temperature` - current readings
  - `/sensors` - sensor addresses
  - `/history` - historical data

---

## 📚 Potential Use Cases
- **Node-RED** automation flows: Perform regular HTTP GET requests against `/temperature` or `/history`
- **Home Assistant** integrations: Use built-in REST sensors to track temperature over time
- **Extensible to other sensor types** (humidity, light, pressure, etc.) by following the same approach

---

## 🛠️ Getting Started
1. **Clone or download** this repository
2. **Open the Sketch** (the `.ino` file) in the Arduino IDE (or other environment)
3. **Install dependencies**:
   - [Arduino Temperature Control Library](https://github.com/milesburton/Arduino-Temperature-Control-Library)
   - ESP8266 or ESP32 core for Arduino
4. **Set your Wi-Fi credentials** in the code:
```cpp
const char* ssid = "YourNetwork";
const char* password = "YourPassword";
```
5. **Adjust** the interval and history:
```cpp
// Configuration
const unsigned long READ_INTERVAL = 10000; // e.g. 10 seconds
const int HISTORY_LENGTH = 360; // 1 hour at 10-second intervals
```
6. **Connect** the DS18B20 sensor(s) to the ESP, using OneWire with a pull-up resistor
7. **Upload** the Sketch to your device
8. **Check** the serial monitor for the IP
9. **Navigate** to that IP in your browser to see the chart-based interface

---

## ❓ Questions & Support
- **Library Matters**: If you have issues with the **Arduino Temperature Control Library** itself, please open a ticket in the [official repository](https://github.com/milesburton/Arduino-Temperature-Control-Library/issues)
- **This Sketch**: For help customising this example, dealing with Wi-Fi issues, or setting up the chart dashboard, and other device-specific tweaks, please visit the [Arduino Forum](https://forum.arduino.cc/). You will find many friendly developers there ready to help.

---

## 📜 License
This project is distributed under the [MIT License](https://opensource.org/licenses/MIT).

---

We hope you find this Sketch useful for monitoring temperatures - both in a machine-readable (REST) and human-friendly (web dashboard) format. Happy hacking! 🚀

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/ExternalPullup/ExternalPullup.ino
================
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino, while external pullup P-MOSFET gate into port 3
#define ONE_WIRE_BUS    2
#define ONE_WIRE_PULLUP 3

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire, ONE_WIRE_PULLUP);

void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // Start up the library
  sensors.begin();
}

void loop(void)
{
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures(); // Send the command to get temperatures
  Serial.println("DONE");

  for (int i = 0; i < sensors.getDeviceCount(); i++) {
    Serial.println("Temperature for Device " + String(i) + " is: " + String(sensors.getTempCByIndex(i)));
  }
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Multibus_simple/Multibus_simple.ino
================
#include <OneWire.h>
#include <DallasTemperature.h>

OneWire ds18x20[] = { 3, 7 };
const int oneWireCount = sizeof(ds18x20) / sizeof(OneWire);
DallasTemperature sensor[oneWireCount];

void setup(void) {
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature Multiple Bus Control Library Simple Demo");
  Serial.print("============Ready with ");
  Serial.print(oneWireCount);
  Serial.println(" Sensors================");

  // Start up the library on all defined bus-wires
  DeviceAddress deviceAddress;
  for (int i = 0; i < oneWireCount; i++) {
    sensor[i].setOneWire(&ds18x20[i]);
    sensor[i].begin();
    if (sensor[i].getAddress(deviceAddress, 0)) sensor[i].setResolution(deviceAddress, 12);
  }
}

void loop(void) {
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  for (int i = 0; i < oneWireCount; i++) {
    sensor[i].requestTemperatures();
  }
  Serial.println("DONE");

  delay(1000);
  for (int i = 0; i < oneWireCount; i++) {
    float temperature = sensor[i].getTempCByIndex(0);
    Serial.print("Temperature for the sensor ");
    Serial.print(i);
    Serial.print(" is ");
    Serial.println(temperature);
  }
  Serial.println();
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Multiple/Multiple.ino
================
// Include the libraries we need
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2
#define TEMPERATURE_PRECISION 9

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

// arrays to hold device addresses
DeviceAddress insideThermometer, outsideThermometer;

// Assign address manually. The addresses below will need to be changed
// to valid device addresses on your bus. Device address can be retrieved
// by using either oneWire.search(deviceAddress) or individually via
// sensors.getAddress(deviceAddress, index)
// DeviceAddress insideThermometer = { 0x28, 0x1D, 0x39, 0x31, 0x2, 0x0, 0x0, 0xF0 };
// DeviceAddress outsideThermometer   = { 0x28, 0x3F, 0x1C, 0x31, 0x2, 0x0, 0x0, 0x2 };

void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // Start up the library
  sensors.begin();

  // locate devices on the bus
  Serial.print("Locating devices...");
  Serial.print("Found ");
  Serial.print(sensors.getDeviceCount(), DEC);
  Serial.println(" devices.");

  // report parasite power requirements
  Serial.print("Parasite power is: ");
  if (sensors.isParasitePowerMode()) Serial.println("ON");
  else Serial.println("OFF");

  // Search for devices on the bus and assign based on an index. Ideally,
  // you would do this to initially discover addresses on the bus and then
  // use those addresses and manually assign them (see above) once you know
  // the devices on your bus (and assuming they don't change).
  //
  // method 1: by index
  if (!sensors.getAddress(insideThermometer, 0)) Serial.println("Unable to find address for Device 0");
  if (!sensors.getAddress(outsideThermometer, 1)) Serial.println("Unable to find address for Device 1");

  // method 2: search()
  // search() looks for the next device. Returns 1 if a new address has been
  // returned. A zero might mean that the bus is shorted, there are no devices,
  // or you have already retrieved all of them. It might be a good idea to
  // check the CRC to make sure you didn't get garbage. The order is
  // deterministic. You will always get the same devices in the same order
  //
  // Must be called before search()
  //oneWire.reset_search();
  // assigns the first address found to insideThermometer
  //if (!oneWire.search(insideThermometer)) Serial.println("Unable to find address for insideThermometer");
  // assigns the seconds address found to outsideThermometer
  //if (!oneWire.search(outsideThermometer)) Serial.println("Unable to find address for outsideThermometer");

  // show the addresses we found on the bus
  Serial.print("Device 0 Address: ");
  printAddress(insideThermometer);
  Serial.println();

  Serial.print("Device 1 Address: ");
  printAddress(outsideThermometer);
  Serial.println();

  // set the resolution to 9 bit per device
  sensors.setResolution(insideThermometer, TEMPERATURE_PRECISION);
  sensors.setResolution(outsideThermometer, TEMPERATURE_PRECISION);

  Serial.print("Device 0 Resolution: ");
  Serial.print(sensors.getResolution(insideThermometer), DEC);
  Serial.println();

  Serial.print("Device 1 Resolution: ");
  Serial.print(sensors.getResolution(outsideThermometer), DEC);
  Serial.println();
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    // zero pad the address if necessary
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

// function to print the temperature for a device
void printTemperature(DeviceAddress deviceAddress)
{
  float tempC = sensors.getTempC(deviceAddress);
  if (tempC == DEVICE_DISCONNECTED_C)
  {
    Serial.println("Error: Could not read temperature data");
    return;
  }
  Serial.print("Temp C: ");
  Serial.print(tempC);
  Serial.print(" Temp F: ");
  Serial.print(DallasTemperature::toFahrenheit(tempC));
}

// function to print a device's resolution
void printResolution(DeviceAddress deviceAddress)
{
  Serial.print("Resolution: ");
  Serial.print(sensors.getResolution(deviceAddress));
  Serial.println();
}

// main function to print information about a device
void printData(DeviceAddress deviceAddress)
{
  Serial.print("Device Address: ");
  printAddress(deviceAddress);
  Serial.print(" ");
  printTemperature(deviceAddress);
  Serial.println();
}

/*
   Main function, calls the temperatures in a loop.
*/
void loop(void)
{
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures();
  Serial.println("DONE");

  // print the device information
  printData(insideThermometer);
  printData(outsideThermometer);
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/oneWireSearch/oneWireSearch.ino
================
//
//    FILE: oneWireSearch.ino
//  AUTHOR: Rob Tillaart
// VERSION: 0.1.02
// PURPOSE: scan for 1-Wire devices + code snippet generator
//    DATE: 2015-june-30
//     URL: http://forum.arduino.cc/index.php?topic=333923
//
// inspired by http://www.hacktronics.com/Tutorials/arduino-1-wire-address-finder.html
//
// Released to the public domain
//
// 0.1.00 initial version
// 0.1.01 first published version
// 0.1.02 small output changes

#include <OneWire.h>

void setup()
{
  Serial.begin(115200);
  Serial.println("//\n// Start oneWireSearch.ino \n//");

  for (uint8_t pin = 2; pin < 13; pin++)
  {
    findDevices(pin);
  }
  Serial.println("\n//\n// End oneWireSearch.ino \n//");
}

void loop()
{
}

uint8_t findDevices(int pin)
{
  OneWire ow(pin);

  uint8_t address[8];
  uint8_t count = 0;


  if (ow.search(address))
  {
    Serial.print("\nuint8_t pin");
    Serial.print(pin, DEC);
    Serial.println("[][8] = {");
    do {
      count++;
      Serial.println("  {");
      for (uint8_t i = 0; i < 8; i++)
      {
        Serial.print("0x");
        if (address[i] < 0x10) Serial.print("0");
        Serial.print(address[i], HEX);
        if (i < 7) Serial.print(", ");
      }
      Serial.println("  },");
    } while (ow.search(address));

    Serial.println("};");
    Serial.print("// nr devices found: ");
    Serial.println(count);
  }

  return count;
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/readPowerSupply/readPowerSupply.ino
================
//
// FILE: readPowerSupply.ino
// AUTHOR: Rob Tillaart
// VERSION: 0.1.0
// PURPOSE: demo
// DATE: 2020-02-10
//
// Released to the public domain
//

// Include the libraries we need
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

// arrays to hold device addresses
DeviceAddress insideThermometer, outsideThermometer;
// Assign address manually. The addresses below will beed to be changed
// to valid device addresses on your bus. Device address can be retrieved
// by using either oneWire.search(deviceAddress) or individually via
// sensors.getAddress(deviceAddress, index)
// DeviceAddress insideThermometer = { 0x28, 0x1D, 0x39, 0x31, 0x2, 0x0, 0x0, 0xF0 };
// DeviceAddress outsideThermometer   = { 0x28, 0x3F, 0x1C, 0x31, 0x2, 0x0, 0x0, 0x2 };

int devCount = 0;

/*
 * The setup function. We only start the sensors here
 */
void setup(void)
{
  Serial.begin(115200);
  Serial.println("Arduino Temperature Control Library Demo - readPowerSupply");

  sensors.begin();

  devCount = sensors.getDeviceCount();
  Serial.print("#devices: ");
  Serial.println(devCount);

  // report parasite power requirements
  Serial.print("Parasite power is: ");
  if (sensors.readPowerSupply()) Serial.println("ON");  // no address means "scan all devices for parasite mode"
  else Serial.println("OFF");

  // Search for devices on the bus and assign based on an index.
  if (!sensors.getAddress(insideThermometer, 0)) Serial.println("Unable to find address for Device 0");
  if (!sensors.getAddress(outsideThermometer, 1)) Serial.println("Unable to find address for Device 1");

  // show the addresses we found on the bus
  Serial.print("Device 0 Address: ");
  printAddress(insideThermometer);
  Serial.println();
  Serial.print("Power = parasite: ");
  Serial.println(sensors.readPowerSupply(insideThermometer));
  Serial.println();
  Serial.println();

  Serial.print("Device 1 Address: ");
  printAddress(outsideThermometer);
  Serial.println();
  Serial.print("Power = parasite: ");
  Serial.println(sensors.readPowerSupply(outsideThermometer));
  Serial.println();
  Serial.println();
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    // zero pad the address if necessary
    if (deviceAddress[i] < 0x10) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

// empty on purpose
void loop(void)
{
}

// END OF FILE

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/SaveRecallScratchPad/SaveRecallScratchPad.ino
================
//
//    FILE: SaveRecallScratchPad.ino
//  AUTHOR: GitKomodo
// VERSION: 0.0.1
// PURPOSE: Show DallasTemperature lib functionality to
//          save/recall ScratchPad values to/from EEPROM
//
// HISTORY:
// 0.0.1 = 2020-02-18 initial version
//

#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS 2

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);
DeviceAddress deviceAddress;

void setup()
{
  Serial.begin(9600);
  Serial.println(__FILE__);
  Serial.println("Dallas Temperature Demo");

  sensors.begin();

  // Get ID of first sensor (at index 0)
  sensors.getAddress(deviceAddress, 0);

  // By default configuration and alarm/userdata registers are also saved to EEPROM
  // when they're changed. Sensors recall these values automatically when powered up.

  // Turn OFF automatic saving of configuration and alarm/userdata registers to EEPROM
  sensors.setAutoSaveScratchPad(false);

  // Change configuration and alarm/userdata registers on the scratchpad
  int8_t resolution = 12;
  sensors.setResolution(deviceAddress, resolution);
  int16_t userdata = 24680;
  sensors.setUserData(deviceAddress, userdata);

  // Save configuration and alarm/userdata registers to EEPROM
  sensors.saveScratchPad(deviceAddress);

  // saveScratchPad can also be used without a parameter to save the configuration
  // and alarm/userdata registers of ALL connected sensors to EEPROM:
  //
  //   sensors.saveScratchPad();
  //
  // Or the configuration and alarm/userdata registers of a sensor can be saved to
  // EEPROM by index:
  //
  //   sensors.saveScratchPadByIndex(0);

  // Print current values on the scratchpad (resolution = 12, userdata = 24680)
  printValues();

}

void loop() {

  // Change configuration and alarm/userdata registers on the scratchpad
  int8_t resolution = 10;
  sensors.setResolution(deviceAddress, resolution);
  int16_t userdata = 12345;
  sensors.setUserData(deviceAddress, userdata);

  // Print current values on the scratchpad (resolution = 10, userdata = 12345)
  printValues();

  delay(2000);

  // Recall configuration and alarm/userdata registers from EEPROM
  sensors.recallScratchPad(deviceAddress);

  // recallScratchPad can also be used without a parameter to recall the configuration
  // and alarm/userdata registers of ALL connected sensors from EEPROM:
  //
  //   sensors.recallScratchPad();
  //
  // Or the configuration and alarm/userdata registers of a sensor can be recalled
  // from EEPROM by index:
  //
  //   sensors.recallScratchPadByIndex(0);

  // Print current values on the scratchpad (resolution = 12, userdata = 24680)
  printValues();

  delay(2000);

}

void printValues() {

  Serial.println();
  Serial.println("Current values on the scratchpad:");

  Serial.print("Resolution:\t");
  Serial.println(sensors.getResolution(deviceAddress));

  Serial.print("User data:\t");
  Serial.println(sensors.getUserData(deviceAddress));

}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/SetUserData/SetUserData.ino
================
//
// This sketch does not use the ALARM registers and uses those 2 bytes as a counter
// these 2 bytes can be used for other purposes as well e.g. last temperature or
// a specific ID.
//

#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

int count = 0;

void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // Start up the library
  sensors.begin();

}

void loop(void)
{
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures(); // Send the command to get temperatures
  Serial.println("DONE");

  Serial.print("Temperature for the device 1 (index 0) is: ");
  Serial.println(sensors.getTempCByIndex(0));

  count++;
  sensors.setUserDataByIndex(0, count);
  int x = sensors.getUserDataByIndex(0);
  Serial.println(count);
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Simple/Simple.ino
================
// Include the libraries we need
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

/*
 * The setup function. We only start the sensors here
 */
void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // Start up the library
  sensors.begin();
}

/*
 * Main function, get and show the temperature
 */
void loop(void)
{
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures(); // Send the command to get temperatures
  Serial.println("DONE");
  delay(1500);
  // After we got the temperatures, we can print them here.
  // We use the function ByIndex, and as an example get the temperature from the first sensor only.
  float tempC = sensors.getTempCByIndex(0);

  // Check if reading was successful
  if (tempC != DEVICE_DISCONNECTED_C)
  {
    Serial.print("Temperature for the device 1 (index 0) is: ");
    Serial.println(tempC);
  }
  else
  {
    Serial.println("Error: Could not read temperature data");
  }
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Single/Single.ino
================
// Include the libraries we need
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

// arrays to hold device address
DeviceAddress insideThermometer;

/*
 * Setup function. Here we do the basics
 */
void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // locate devices on the bus
  Serial.print("Locating devices...");
  sensors.begin();
  Serial.print("Found ");
  Serial.print(sensors.getDeviceCount(), DEC);
  Serial.println(" devices.");

  // report parasite power requirements
  Serial.print("Parasite power is: ");
  if (sensors.isParasitePowerMode()) Serial.println("ON");
  else Serial.println("OFF");

  // Assign address manually. The addresses below will need to be changed
  // to valid device addresses on your bus. Device address can be retrieved
  // by using either oneWire.search(deviceAddress) or individually via
  // sensors.getAddress(deviceAddress, index)
  // Note that you will need to use your specific address here
  //insideThermometer = { 0x28, 0x1D, 0x39, 0x31, 0x2, 0x0, 0x0, 0xF0 };

  // Method 1:
  // Search for devices on the bus and assign based on an index. Ideally,
  // you would do this to initially discover addresses on the bus and then
  // use those addresses and manually assign them (see above) once you know
  // the devices on your bus (and assuming they don't change).
  if (!sensors.getAddress(insideThermometer, 0)) Serial.println("Unable to find address for Device 0");

  // method 2: search()
  // search() looks for the next device. Returns 1 if a new address has been
  // returned. A zero might mean that the bus is shorted, there are no devices,
  // or you have already retrieved all of them. It might be a good idea to
  // check the CRC to make sure you didn't get garbage. The order is
  // deterministic. You will always get the same devices in the same order
  //
  // Must be called before search()
  //oneWire.reset_search();
  // assigns the first address found to insideThermometer
  //if (!oneWire.search(insideThermometer)) Serial.println("Unable to find address for insideThermometer");

  // show the addresses we found on the bus
  Serial.print("Device 0 Address: ");
  printAddress(insideThermometer);
  Serial.println();

  // set the resolution to 9 bit (Each Dallas/Maxim device is capable of several different resolutions)
  sensors.setResolution(insideThermometer, 9);

  Serial.print("Device 0 Resolution: ");
  Serial.print(sensors.getResolution(insideThermometer), DEC);
  Serial.println();
}

// function to print the temperature for a device
void printTemperature(DeviceAddress deviceAddress)
{
  // method 1 - slower
  //Serial.print("Temp C: ");
  //Serial.print(sensors.getTempC(deviceAddress));
  //Serial.print(" Temp F: ");
  //Serial.print(sensors.getTempF(deviceAddress)); // Makes a second call to getTempC and then converts to Fahrenheit

  // method 2 - faster
  float tempC = sensors.getTempC(deviceAddress);
  if (tempC == DEVICE_DISCONNECTED_C)
  {
    Serial.println("Error: Could not read temperature data");
    return;
  }
  Serial.print("Temp C: ");
  Serial.print(tempC);
  Serial.print(" Temp F: ");
  Serial.println(DallasTemperature::toFahrenheit(tempC)); // Converts tempC to Fahrenheit
}
/*
 * Main function. It will request the tempC from the sensors and display on Serial.
 */
void loop(void)
{
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures(); // Send the command to get temperatures
  Serial.println("DONE");
  delay(1500);

  // It responds almost immediately. Let's print out the data
  printTemperature(insideThermometer); // Use a simple function to print out the data
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Tester/Tester.ino
================
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2
#define TEMPERATURE_PRECISION 9 // Lower resolution

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

int numberOfDevices; // Number of temperature devices found

DeviceAddress tempDeviceAddress; // We'll use this variable to store a found device address

void setup(void)
{
  // start serial port
  Serial.begin(9600);
  Serial.println("Dallas Temperature IC Control Library Demo");

  // Start up the library
  sensors.begin();

  // Grab a count of devices on the wire
  numberOfDevices = sensors.getDeviceCount();

  // locate devices on the bus
  Serial.print("Locating devices...");

  Serial.print("Found ");
  Serial.print(numberOfDevices, DEC);
  Serial.println(" devices.");

  // report parasite power requirements
  Serial.print("Parasite power is: ");
  if (sensors.isParasitePowerMode()) Serial.println("ON");
  else Serial.println("OFF");

  // Loop through each device, print out address
  for (int i = 0; i < numberOfDevices; i++)
  {
    // Search the wire for address
    if (sensors.getAddress(tempDeviceAddress, i))
    {
      Serial.print("Found device ");
      Serial.print(i, DEC);
      Serial.print(" with address: ");
      printAddress(tempDeviceAddress);
      Serial.println();

      Serial.print("Setting resolution to ");
      Serial.println(TEMPERATURE_PRECISION, DEC);

      // set the resolution to TEMPERATURE_PRECISION bit (Each Dallas/Maxim device is capable of several different resolutions)
      sensors.setResolution(tempDeviceAddress, TEMPERATURE_PRECISION);

      Serial.print("Resolution actually set to: ");
      Serial.print(sensors.getResolution(tempDeviceAddress), DEC);
      Serial.println();
    } else {
      Serial.print("Found ghost device at ");
      Serial.print(i, DEC);
      Serial.print(" but could not detect address. Check power and cabling");
    }
  }

}

// function to print the temperature for a device
void printTemperature(DeviceAddress deviceAddress)
{
  // method 1 - slower
  //Serial.print("Temp C: ");
  //Serial.print(sensors.getTempC(deviceAddress));
  //Serial.print(" Temp F: ");
  //Serial.print(sensors.getTempF(deviceAddress)); // Makes a second call to getTempC and then converts to Fahrenheit

  // method 2 - faster
  float tempC = sensors.getTempC(deviceAddress);
  if (tempC == DEVICE_DISCONNECTED_C)
  {
    Serial.println("Error: Could not read temperature data");
    return;
  }
  Serial.print("Temp C: ");
  Serial.print(tempC);
  Serial.print(" Temp F: ");
  Serial.println(DallasTemperature::toFahrenheit(tempC)); // Converts tempC to Fahrenheit
}

void loop(void)
{
  // call sensors.requestTemperatures() to issue a global temperature
  // request to all devices on the bus
  Serial.print("Requesting temperatures...");
  sensors.requestTemperatures(); // Send the command to get temperatures
  Serial.println("DONE");


  // Loop through each device, print out temperature data
  for (int i = 0; i < numberOfDevices; i++)
  {
    // Search the wire for address
    if (sensors.getAddress(tempDeviceAddress, i))
    {
      // Output the device ID
      Serial.print("Temperature for device: ");
      Serial.println(i, DEC);

      // It responds almost immediately. Let's print out the data
      printTemperature(tempDeviceAddress); // Use a simple function to print out the data
    }
    //else ghost device! Check your power requirements and cabling

  }
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/Timing/Timing.ino
================
//
//    FILE: Timing.ino
//  AUTHOR: Rob Tillaart
// VERSION: 0.0.3
// PURPOSE: show performance of DallasTemperature lib
//          compared to datasheet times per resolution
//
// HISTORY:
// 0.0.1    2017-07-25 initial version
// 0.0.2    2020-02-13 updates to work with current lib version
// 0.0.3    2020-02-20 added timing measurement of setResolution

#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS 2

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensor(&oneWire);

uint32_t start, stop;


void setup()
{
  Serial.begin(9600);
  Serial.println(__FILE__);
  Serial.print("DallasTemperature Library version: ");
  Serial.println(DALLASTEMPLIBVERSION);

  sensor.begin();
}

void loop()
{
  float ti[4] = { 94, 188, 375, 750 };

  Serial.println();
  Serial.println("Test takes about 30 seconds for 4 resolutions");
  Serial.println("RES\tTIME\tACTUAL\tGAIN");
  for (int r = 9; r < 13; r++)
  {
    start = micros();
    sensor.setResolution(r);
    Serial.println(micros() - start);

    start = micros();
    sensor.setResolution(r);
    Serial.println(micros() - start);

    uint32_t duration = run(20);
    float avgDuration = duration / 20.0;

    Serial.print(r);
    Serial.print("\t");
    Serial.print(ti[r - 9]);
    Serial.print("\t");
    Serial.print(avgDuration, 2);
    Serial.print("\t");
    Serial.print(avgDuration * 100 / ti[r - 9], 1);
    Serial.println("%");
  }
  delay(1000);
}

uint32_t run(int runs)
{
  float t;
  start = millis();
  for (int i = 0; i < runs; i++)
  {
    sensor.requestTemperatures();
    t = sensor.getTempCByIndex(0);
  }
  stop = millis();
  return stop - start;
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/TwoPin_DS18B20/TwoPin_DS18B20.ino
================
//
// FILE: TwoPin_DS18B20.ino
// AUTHOR: Rob Tillaart
// VERSION: 0.1.00
// PURPOSE: two pins for two sensors demo
// DATE: 2014-06-13
// URL: http://forum.arduino.cc/index.php?topic=216835.msg1764333#msg1764333
//
// Released to the public domain
//

#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS_1 2
#define ONE_WIRE_BUS_2 4

OneWire oneWire_in(ONE_WIRE_BUS_1);
OneWire oneWire_out(ONE_WIRE_BUS_2);

DallasTemperature sensor_inhouse(&oneWire_in);
DallasTemperature sensor_outhouse(&oneWire_out);

void setup(void)
{
  Serial.begin(9600);
  Serial.println("Dallas Temperature Control Library Demo - TwoPin_DS18B20");

  sensor_inhouse.begin();
  sensor_outhouse.begin();
}

void loop(void)
{
  Serial.print("Requesting temperatures...");
  sensor_inhouse.requestTemperatures();
  sensor_outhouse.requestTemperatures();
  Serial.println(" done");

  Serial.print("Inhouse: ");
  Serial.println(sensor_inhouse.getTempCByIndex(0));

  Serial.print("Outhouse: ");
  Serial.println(sensor_outhouse.getTempCByIndex(0));
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/UserDataDemo/UserDataDemo.ino
================
//
// FILE: UserDataDemo.ino
// AUTHOR: Rob Tillaart
// VERSION: 0.1.0
// PURPOSE: use of alarm field as user identification demo
// DATE: 2019-12-23
// URL:
//
// Released to the public domain
//

#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS      2

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

uint8_t deviceCount = 0;

// Add 4 prepared sensors to the bus
// use the UserDataWriteBatch demo to prepare 4 different labeled sensors
struct
{
  int id;
  DeviceAddress addr;
} T[4];

float getTempByID(int id)
{
  for (uint8_t index = 0; index < deviceCount; index++)
  {
    if (T[index].id == id)
    {
      return sensors.getTempC(T[index].addr);
    }
  }
  return -999;
}

void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    // zero pad the address if necessary
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

void setup(void)
{
  Serial.begin(115200);
  Serial.println(__FILE__);
  Serial.println("Dallas Temperature Demo");

  sensors.begin();

  // count devices
  deviceCount = sensors.getDeviceCount();
  Serial.print("#devices: ");
  Serial.println(deviceCount);

  // Read ID's per sensor
  // and put them in T array
  for (uint8_t index = 0; index < deviceCount; index++)
  {
    // go through sensors
    sensors.getAddress(T[index].addr, index);
    T[index].id = sensors.getUserData(T[index].addr);
  }

  // Check all 4 sensors are set
  for (uint8_t index = 0; index < deviceCount; index++)
  {
    Serial.println();
    Serial.println(T[index].id);
    printAddress(T[index].addr);
    Serial.println();
  }
  Serial.println();

}


void loop(void)
{
  Serial.println();
  Serial.print(millis());
  Serial.println("\treq temp");
  sensors.requestTemperatures();

  Serial.print(millis());
  Serial.println("\tGet temp by address");
  for (int i = 0; i < 4; i++)
  {
    Serial.print(millis());
    Serial.print("\t temp:\t");
    Serial.println(sensors.getTempC(T[i].addr));
  }

  Serial.print(millis());
  Serial.println("\tGet temp by ID");  // assume ID = 0, 1, 2, 3
  for (int id = 0; id < 4; id++)
  {
    Serial.print(millis());
    Serial.print("\t temp:\t");
    Serial.println(getTempByID(id));
  }

  delay(1000);
}

// END OF FILE

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/UserDataWriteBatch/UserDataWriteBatch.ino
================
//
// FILE: UserDataWriteBatch.ino
// AUTHOR: Rob Tillaart
// VERSION: 0.1.0
// PURPOSE: use of alarm field as user identification demo
// DATE: 2019-12-23
// URL:
//
// Released to the public domain
//

#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS      2

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

uint8_t deviceCount = 0;

void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    // zero pad the address if necessary
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}



void setup(void)
{
  Serial.begin(115200);
  Serial.println(__FILE__);
  Serial.println("Write user ID to DS18B20\n");

  sensors.begin();

  // count devices
  deviceCount = sensors.getDeviceCount();
  Serial.print("#devices: ");
  Serial.println(deviceCount);

  Serial.println();
  Serial.println("current ID's");
  for (uint8_t index = 0; index < deviceCount; index++)
  {
    DeviceAddress t;
    sensors.getAddress(t, index);
    printAddress(t);
    Serial.print("\t\tID: ");
    int id = sensors.getUserData(t);
    Serial.println(id);
  }

  Serial.println();
  Serial.print("Enter ID for batch: ");
  int c = 0;
  int id = 0;
  while (c != '\n' && c != '\r')
  {
    c = Serial.read();
    switch (c)
    {
    case '0'...'9':
      id *= 10;
      id += (c - '0');
      break;
    default:
      break;
    }
  }
  Serial.println();
  Serial.println(id);
  Serial.println();

  Serial.println("Start labeling ...");
  for (uint8_t index = 0; index < deviceCount; index++)
  {
    Serial.print(".");
    DeviceAddress t;
    sensors.getAddress(t, index);
    sensors.setUserData(t, id);
  }
  Serial.println();

  Serial.println();
  Serial.println("Show results ...");
  for (uint8_t index = 0; index < deviceCount; index++)
  {
    DeviceAddress t;
    sensors.getAddress(t, index);
    printAddress(t);
    Serial.print("\t\tID: ");
    int id = sensors.getUserData(t);
    Serial.println(id);
  }
  Serial.println("Done ...");

}

void loop(void) {}

// END OF FILE

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/WaitForConversion/WaitForConversion.ino
================
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

void setup(void)
{
  // start serial port
  Serial.begin(115200);
  Serial.println("Dallas Temperature Control Library - Async Demo");
  Serial.println("\nDemo shows the difference in length of the call\n\n");

  // Start up the library
  sensors.begin();
}

void loop(void)
{
  // Request temperature conversion (traditional)
  Serial.println("Before blocking requestForConversion");
  unsigned long start = millis();

  sensors.requestTemperatures();

  unsigned long stop = millis();
  Serial.println("After blocking requestForConversion");
  Serial.print("Time used: ");
  Serial.println(stop - start);

  // get temperature
  Serial.print("Temperature: ");
  Serial.println(sensors.getTempCByIndex(0));
  Serial.println("\n");

  // Request temperature conversion - non-blocking / async
  Serial.println("Before NON-blocking/async requestForConversion");
  start = millis();
  sensors.setWaitForConversion(false);  // makes it async
  sensors.requestTemperatures();
  sensors.setWaitForConversion(true);
  stop = millis();
  Serial.println("After NON-blocking/async requestForConversion");
  Serial.print("Time used: ");
  Serial.println(stop - start);


  // 9 bit resolution by default
  // Note the programmer is responsible for the right delay
  // we could do something usefull here instead of the delay
  int resolution = 9;
  delay(750 / (1 << (12 - resolution)));

  // get temperature
  Serial.print("Temperature: ");
  Serial.println(sensors.getTempCByIndex(0));
  Serial.println("\n\n\n\n");

  delay(1500);
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/examples/WaitForConversion2/WaitForConversion2.ino
================
//
// Sample of using Async reading of Dallas Temperature Sensors
//
#include <OneWire.h>
#include <DallasTemperature.h>

// Data wire is plugged into port 2 on the Arduino
#define ONE_WIRE_BUS 2

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);

// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

DeviceAddress tempDeviceAddress;

int  resolution = 12;
unsigned long lastTempRequest = 0;
int  delayInMillis = 0;
float temperature = 0.0;
int  idle = 0;
//
// SETUP
//
void setup(void)
{
  Serial.begin(115200);
  Serial.println("Dallas Temperature Control Library - Async Demo");
  Serial.print("Library Version: ");
  Serial.println(DALLASTEMPLIBVERSION);
  Serial.println("\n");

  sensors.begin();
  sensors.getAddress(tempDeviceAddress, 0);
  sensors.setResolution(tempDeviceAddress, resolution);

  sensors.setWaitForConversion(false);
  sensors.requestTemperatures();
  delayInMillis = 750 / (1 << (12 - resolution));
  lastTempRequest = millis();

  pinMode(13, OUTPUT);
}

void loop(void)
{

  if (millis() - lastTempRequest >= delayInMillis) // waited long enough??
  {
    digitalWrite(13, LOW);
    Serial.print(" Temperature: ");
    temperature = sensors.getTempCByIndex(0);
    Serial.println(temperature, resolution - 8);
    Serial.print("  Resolution: ");
    Serial.println(resolution);
    Serial.print("Idle counter: ");
    Serial.println(idle);
    Serial.println();

    idle = 0;

    // immediately after fetching the temperature we request a new sample
    // in the async modus
    // for the demo we let the resolution change to show differences
    resolution++;
    if (resolution > 12) resolution = 9;

    sensors.setResolution(tempDeviceAddress, resolution);
    sensors.requestTemperatures();
    delayInMillis = 750 / (1 << (12 - resolution));
    lastTempRequest = millis();
  }

  digitalWrite(13, HIGH);
  // we can do usefull things here
  // for the demo we just count the idle time in millis
  delay(1);
  idle++;
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/Gemfile
================
source "https://rubygems.org"

gem "arduino_ci", "~> 1.6.2"

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/keywords.txt
================
#######################################
# Syntax Coloring Map For DallasTemperature
#######################################

#######################################
# Datatypes (KEYWORD1)
#######################################
DallasTemperature	KEYWORD1
OneWire	KEYWORD1
AlarmHandler	KEYWORD1
DeviceAddress	KEYWORD1

#######################################
# Methods and Functions (KEYWORD2)
#######################################

setOneWire	KEYWORD2
setPullupPin	KEYWORD2
setResolution	KEYWORD2
getResolution	KEYWORD2
getTemp	KEYWORD2
getTempC	KEYWORD2
toFahrenheit	KEYWORD2
getTempF	KEYWORD2
getTempCByIndex	KEYWORD2
getTempFByIndex	KEYWORD2
rawToCelsius	KEYWORD2
rawToFahrenheit	KEYWORD2
setWaitForConversion	KEYWORD2
getWaitForConversion	KEYWORD2
requestTemperatures	KEYWORD2
requestTemperaturesByAddress	KEYWORD2
requestTemperaturesByIndex	KEYWORD2
setCheckForConversion	KEYWORD2
getCheckForConversion	KEYWORD2
isConversionComplete	KEYWORD2
millisToWaitForConversion	KEYWORD2
isParasitePowerMode	KEYWORD2
begin	KEYWORD2
getDeviceCount	KEYWORD2
getDS18Count	KEYWORD2
getAddress	KEYWORD2
validAddress	KEYWORD2
validFamily	KEYWORD2
isConnected	KEYWORD2
readScratchPad	KEYWORD2
writeScratchPad	KEYWORD2
readPowerSupply	KEYWORD2
saveScratchPadByIndex	KEYWORD2
saveScratchPad	KEYWORD2
recallScratchPadByIndex	KEYWORD2
recallScratchPad	KEYWORD2
setAutoSaveScratchPad	KEYWORD2
getAutoSaveScratchPad	KEYWORD2
setHighAlarmTemp	KEYWORD2
setLowAlarmTemp	KEYWORD2
getHighAlarmTemp	KEYWORD2
getLowAlarmTemp	KEYWORD2
resetAlarmSearch	KEYWORD2
alarmSearch	KEYWORD2
hasAlarm	KEYWORD2
toCelsius	KEYWORD2
processAlarms	KEYWORD2
setAlarmHandler	KEYWORD2
hasAlarmHandler	KEYWORD2
setUserData	KEYWORD2
setUserDataByIndex	KEYWORD2
getUserData	KEYWORD2
getUserDataByIndex	KEYWORD2
calculateTemperature	KEYWORD2

#######################################
# Constants (LITERAL1)
#######################################

DEVICE_DISCONNECTED_C	LITERAL1
DEVICE_DISCONNECTED_F	LITERAL1
DEVICE_DISCONNECTED_RAW	LITERAL1
DEVICE_FAULT_OPEN_C	LITERAL1
DEVICE_FAULT_OPEN_F	LITERAL1
DEVICE_FAULT_OPEN_RAW	LITERAL1
DEVICE_FAULT_SHORTGND_C	LITERAL1
DEVICE_FAULT_SHORTGND_F	LITERAL1
DEVICE_FAULT_SHORTGND_RAW	LITERAL1
DEVICE_FAULT_SHORTVDD_C	LITERAL1
DEVICE_FAULT_SHORTVDD_F	LITERAL1
DEVICE_FAULT_SHORTVDD_RAW	LITERAL1

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/library.json
================
{
  "name": "DallasTemperature",
  "keywords": "onewire, 1-wire, bus, sensor, temperature, DS18B20, DS18S20, DS1822, DS1820, MAX31850",
  "description": "Arduino Library for Dallas Temperature ICs (DS18B20, DS18S20, DS1822, DS1820, MAX31850)",
  "repository":
  {
    "type": "git",
    "url": "https://github.com/milesburton/Arduino-Temperature-Control-Library.git"
  },
  "authors": 
  [
    {
      "name": "Miles Burton",
      "email": "mail@milesburton.com",
      "url": "http://www.milesburton.com",
      "maintainer": true
    },
    {
      "name": "Tim Newsome",
      "email": "nuisance@casualhacker.net"
    },
    {
      "name": "Guil Barros",
      "email": "gfbarros@bappos.com"
    },
    {
      "name": "Rob Tillaart",
      "email": "rob.tillaart@gmail.com"
    }
  ],
  "dependencies":
  {
    "pstolarz/OneWireNg": ">=0.10.0"
  },
  "version": "4.0.4",
  "frameworks": "arduino",
  "platforms": "*"
}

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/library.properties
================
name=DallasTemperature
version=4.0.4
author=Miles Burton <mail@milesburton.com>, Tim Newsome <nuisance@casualhacker.net>, Guil Barros <gfbarros@bappos.com>, Rob Tillaart <rob.tillaart@gmail.com>
maintainer=Miles Burton <mail@milesburton.com>
sentence=Arduino library for Dallas/Maxim temperature ICs
paragraph=Support for DS18B20 and other Dallas/Maxim 1-Wire temperature sensors
category=Sensors
url=https://github.com/milesburton/Arduino-Temperature-Control-Library
architectures=*

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/LICENSE
================
MIT License

Copyright (c) 2024 Miles Burton

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/README.md
================
# 🌡️ Arduino Temperature Control Library

[![Arduino CI](https://github.com/milesburton/Arduino-Temperature-Control-Library/workflows/Arduino%20CI/badge.svg)](https://github.com/marketplace/actions/arduino_ci)
[![Arduino-lint](https://github.com/milesburton/Arduino-Temperature-Control-Library/actions/workflows/arduino-lint.yml/badge.svg)](https://github.com/RobTillaart/AS5600/actions/workflows/arduino-lint.yml)
[![JSON check](https://github.com/milesburton/Arduino-Temperature-Control-Library/actions/workflows/jsoncheck.yml/badge.svg)](https://github.com/RobTillaart/AS5600/actions/workflows/jsoncheck.yml)
[![License: MIT](https://img.shields.io/badge/license-MIT-green.svg)](https://github.com/milesburton/Arduino-Temperature-Control-Library/blob/master/LICENSE)
[![GitHub release](https://img.shields.io/github/release/milesburton/Arduino-Temperature-Control-Library.svg?maxAge=3600)](https://github.com/milesburton/Arduino-Temperature-Control-Library/releases)

This is a fork of
[DallasTemperature](https://github.com/milesburton/Arduino-Temperature-Control-Library)
library with [OneWireNg](https://github.com/pstolarz/OneWireNg) as a 1-wire
service. `OneWireNg` branch of the fork contains the ported library version.

The fork preserves upstream library sources with no modification. Only library side
files (library descriptors, build scripts) are updated to point into OneWireNg as
a 1-wire service library.

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/test/TestDallasTemperature.cpp
================
#include <DallasTemperature.h>
#include <ArduinoUnitTests.h>

unittest(test_initialization) {
    OneWire oneWire(2); // Simulate OneWire on pin 2
    DallasTemperature sensors(&oneWire);

    sensors.begin();
    assertEqual(0, sensors.getDeviceCount());
}

unittest(test_parasite_power_mode) {
    OneWire oneWire(2);
    DallasTemperature sensors(&oneWire);

    sensors.begin();
    assertFalse(sensors.isParasitePowerMode());
}

unittest_main()

================
File: lib/Arduino-Temperature-Control-Library-OneWireNg/test/unit_test_001.cpp
================
//    FILE: unit_test_001.cpp
//  AUTHOR: Miles Burton / Rob Tillaart
//    DATE: 2021-01-10
// PURPOSE: unit tests for the Arduino-Temperature-Control-Library
//          https://github.com/MilesBurton/Arduino-Temperature-Control-Library


#include <ArduinoUnitTests.h>
#include <Arduino.h>
#include <OneWire.h>
#include <DallasTemperature.h>

// Mock pin for testing
#define ONE_WIRE_BUS 2

unittest_setup() {
    fprintf(stderr, "VERSION: %s\n", DALLASTEMPLIBVERSION);
}

unittest_teardown() {
    fprintf(stderr, "\n");
}

// Test constants defined in the library
unittest(test_models) {
    assertEqual(0x10, DS18S20MODEL);
    assertEqual(0x28, DS18B20MODEL);
    assertEqual(0x22, DS1822MODEL);
    assertEqual(0x3B, DS1825MODEL);
    assertEqual(0x42, DS28EA00MODEL);
}

// Test error codes defined in the library
unittest(test_error_code) {
    assertEqual(DEVICE_DISCONNECTED_C, -127);
    assertEqual(DEVICE_DISCONNECTED_F, -196.6);
    assertEqual(DEVICE_DISCONNECTED_RAW, -7040);

    assertEqual(DEVICE_FAULT_OPEN_C, -254);
    assertEqualFloat(DEVICE_FAULT_OPEN_F, -425.2, 0.1);
    assertEqual(DEVICE_FAULT_OPEN_RAW, -32512);

    assertEqual(DEVICE_FAULT_SHORTGND_C, -253);
    assertEqualFloat(DEVICE_FAULT_SHORTGND_F, -423.4, 0.1);
    assertEqual(DEVICE_FAULT_SHORTGND_RAW, -32384);

    assertEqual(DEVICE_FAULT_SHORTVDD_C, -252);
    assertEqualFloat(DEVICE_FAULT_SHORTVDD_F, -421.6, 0.1);
    assertEqual(DEVICE_FAULT_SHORTVDD_RAW, -32256);
}

// Test basic initialization and functionality of the DallasTemperature library
unittest(test_initialization) {
    OneWire oneWire(ONE_WIRE_BUS);
    DallasTemperature sensors(&oneWire);

    sensors.begin();

    // Initially, there should be no devices detected
    assertEqual(0, sensors.getDeviceCount());
    assertFalse(sensors.isParasitePowerMode());
}

// Simulate a basic temperature read (mocked)
unittest(test_temperature_read) {
    OneWire oneWire(ONE_WIRE_BUS);
    DallasTemperature sensors(&oneWire);

    sensors.begin();

    // Mock reading temperature
    float tempC = sensors.getTempCByIndex(0);
    assertEqual(DEVICE_DISCONNECTED_C, tempC); // Simulated no device connected
}

unittest_main()

================
File: lib/README
================
This directory is intended for project specific (private) libraries.
PlatformIO will compile them to static libraries and link into the executable file.

The source code of each library should be placed in a separate directory
("lib/your_library_name/[Code]").

For example, see the structure of the following example libraries `Foo` and `Bar`:

|--lib
|  |
|  |--Bar
|  |  |--docs
|  |  |--examples
|  |  |--src
|  |     |- Bar.c
|  |     |- Bar.h
|  |  |- library.json (optional. for custom build options, etc) https://docs.platformio.org/page/librarymanager/config.html
|  |
|  |--Foo
|  |  |- Foo.c
|  |  |- Foo.h
|  |
|  |- README --> THIS FILE
|
|- platformio.ini
|--src
   |- main.c

Example contents of `src/main.c` using Foo and Bar:
```
#include <Foo.h>
#include <Bar.h>

int main (void)
{
  ...
}

```

The PlatformIO Library Dependency Finder will find automatically dependent
libraries by scanning project source files.

More information about PlatformIO Library Dependency Finder
- https://docs.platformio.org/page/librarymanager/ldf.html

================
File: src/config_manager.cpp
================
#include "config_manager.h"
#include <ArduinoJson.h>
#include <vector>
#include "config.h"
#include "sensor_types.h"
#include <Preferences.h>
#include <Arduino.h> // Incluido para usar Serial

/* =========================================================================
   FUNCIONES AUXILIARES
   ========================================================================= */
// Funciones auxiliares para leer y escribir el JSON completo en cada namespace.
static void writeNamespace(const char* ns, const StaticJsonDocument<JSON_DOC_SIZE_MEDIUM>& doc) {
    Preferences prefs;
    prefs.begin(ns, false);
    String jsonString;
    serializeJson(doc, jsonString);
    // Se usa el mismo nombre del namespace como clave interna
    prefs.putString(ns, jsonString.c_str());
    prefs.end();
}

static void readNamespace(const char* ns, StaticJsonDocument<JSON_DOC_SIZE_MEDIUM>& doc) {
    Preferences prefs;
    prefs.begin(ns, true);
    String jsonString = prefs.getString(ns, "{}");
    prefs.end();
    deserializeJson(doc, jsonString);
}

// Configuración por defecto de sensores NO-modbus
const SensorConfig ConfigManager::defaultConfigs[] = DEFAULT_SENSOR_CONFIGS;

/* =========================================================================
   INICIALIZACIÓN Y CONFIGURACIÓN DEL SISTEMA
   ========================================================================= */
bool ConfigManager::checkInitialized() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    return doc[KEY_INITIALIZED] | false;
}

void ConfigManager::initializeDefaultConfig() {
    /* -------------------------------------------------------------------------
       1. INICIALIZACIÓN DE CONFIGURACIÓN DEL SISTEMA
       ------------------------------------------------------------------------- */
    // Sistema unificado: NAMESPACE_SYSTEM (incluye system, sleep y device)
    // Común para todos los tipos de dispositivo
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_STATION_ID] = DEFAULT_STATION_ID;
        doc[KEY_INITIALIZED] = true;
        doc[KEY_SLEEP_TIME] = DEFAULT_TIME_TO_SLEEP;
        doc[KEY_DEVICE_ID] = DEFAULT_DEVICE_ID;
        writeNamespace(NAMESPACE_SYSTEM, doc);
    }
    
    /* -------------------------------------------------------------------------
       2. INICIALIZACIÓN DE SENSORES ANALÓGICOS
       ------------------------------------------------------------------------- */
    // NTC 100K: NAMESPACE_NTC100K
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_NTC100K_T1] = DEFAULT_T1_100K;
        doc[KEY_NTC100K_R1] = DEFAULT_R1_100K;
        doc[KEY_NTC100K_T2] = DEFAULT_T2_100K;
        doc[KEY_NTC100K_R2] = DEFAULT_R2_100K;
        doc[KEY_NTC100K_T3] = DEFAULT_T3_100K;
        doc[KEY_NTC100K_R3] = DEFAULT_R3_100K;
        writeNamespace(NAMESPACE_NTC100K, doc);
    }
    
    // NTC 10K: NAMESPACE_NTC10K
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_NTC10K_T1] = DEFAULT_T1_10K;
        doc[KEY_NTC10K_R1] = DEFAULT_R1_10K;
        doc[KEY_NTC10K_T2] = DEFAULT_T2_10K;
        doc[KEY_NTC10K_R2] = DEFAULT_R2_10K;
        doc[KEY_NTC10K_T3] = DEFAULT_T3_10K;
        doc[KEY_NTC10K_R3] = DEFAULT_R3_10K;
        writeNamespace(NAMESPACE_NTC10K, doc);
    }
    
    // Conductividad: NAMESPACE_COND
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_CONDUCT_CT] = CONDUCTIVITY_DEFAULT_TEMP;
        doc[KEY_CONDUCT_CC] = TEMP_COEF_COMPENSATION;
        doc[KEY_CONDUCT_V1] = CONDUCTIVITY_DEFAULT_V1;
        doc[KEY_CONDUCT_T1] = CONDUCTIVITY_DEFAULT_T1;
        doc[KEY_CONDUCT_V2] = CONDUCTIVITY_DEFAULT_V2;
        doc[KEY_CONDUCT_T2] = CONDUCTIVITY_DEFAULT_T2;
        doc[KEY_CONDUCT_V3] = CONDUCTIVITY_DEFAULT_V3;
        doc[KEY_CONDUCT_T3] = CONDUCTIVITY_DEFAULT_T3;
        writeNamespace(NAMESPACE_COND, doc);
    }
    
    // pH: NAMESPACE_PH
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_PH_V1] = PH_DEFAULT_V1;
        doc[KEY_PH_T1] = PH_DEFAULT_T1;
        doc[KEY_PH_V2] = PH_DEFAULT_V2;
        doc[KEY_PH_T2] = PH_DEFAULT_T2;
        doc[KEY_PH_V3] = PH_DEFAULT_V3;
        doc[KEY_PH_T3] = PH_DEFAULT_T3;
        doc[KEY_PH_CT] = PH_DEFAULT_TEMP;
        writeNamespace(NAMESPACE_PH, doc);
    }
    
    /* -------------------------------------------------------------------------
       3. INICIALIZACIÓN DE SENSORES NO-MODBUS
       ------------------------------------------------------------------------- */
    {
        Preferences prefs;
        prefs.begin(NAMESPACE_SENSORS, false);
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        JsonArray sensorArray = doc.to<JsonArray>(); // Array raíz

        for (const auto& config : ConfigManager::defaultConfigs) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj[KEY_SENSOR] = config.configKey;
            sensorObj[KEY_SENSOR_ID] = config.sensorId;
            sensorObj[KEY_SENSOR_TYPE] = static_cast<int>(config.type);
            sensorObj[KEY_SENSOR_ENABLE] = config.enable;
        }
        
        String jsonString;
        serializeJson(doc, jsonString);
        prefs.putString(NAMESPACE_SENSORS, jsonString.c_str());
        prefs.end();
    }
    
    /* -------------------------------------------------------------------------
       4. INICIALIZACIÓN DE CONFIGURACIÓN DE LORA
       ------------------------------------------------------------------------- */
    {
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        doc[KEY_LORA_JOIN_EUI]      = DEFAULT_JOIN_EUI;
        doc[KEY_LORA_DEV_EUI]       = DEFAULT_DEV_EUI;
        doc[KEY_LORA_NWK_KEY]       = DEFAULT_NWK_KEY;
        doc[KEY_LORA_APP_KEY]       = DEFAULT_APP_KEY;
        writeNamespace(NAMESPACE_LORAWAN, doc);
    }

    /* -------------------------------------------------------------------------
       5. INICIALIZACIÓN DE SENSORES MODBUS
       ------------------------------------------------------------------------- */
    {
        Preferences prefs;
        prefs.begin(NAMESPACE_SENSORS_MODBUS, false);
        StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
        JsonArray sensorArray = doc.to<JsonArray>(); 

        // Cargamos un default (definido en config.h)
        static const ModbusSensorConfig defaultModbusSensors[] = DEFAULT_MODBUS_SENSOR_CONFIGS;
        size_t count = sizeof(defaultModbusSensors)/sizeof(defaultModbusSensors[0]);

        for (size_t i = 0; i < count; i++) {
            JsonObject sensorObj = sensorArray.createNestedObject();
            sensorObj[KEY_MODBUS_SENSOR_ID]    = defaultModbusSensors[i].sensorId;
            sensorObj[KEY_MODBUS_SENSOR_TYPE]  = (int)defaultModbusSensors[i].type;
            sensorObj[KEY_MODBUS_SENSOR_ADDR] = defaultModbusSensors[i].address;
            sensorObj[KEY_MODBUS_SENSOR_ENABLE]   = defaultModbusSensors[i].enable;
        }
        
        String jsonString;
        serializeJson(doc, jsonString);
        prefs.putString(NAMESPACE_SENSORS_MODBUS, jsonString.c_str());
        prefs.end();
    }
}

void ConfigManager::getSystemConfig(bool &initialized, uint32_t &sleepTime, String &deviceId, String &stationId) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    initialized = doc[KEY_INITIALIZED] | false;
    sleepTime = doc[KEY_SLEEP_TIME] | DEFAULT_TIME_TO_SLEEP;
    deviceId = String(doc[KEY_DEVICE_ID] | DEFAULT_DEVICE_ID);
    stationId = String(doc[KEY_STATION_ID] | DEFAULT_STATION_ID);
}

void ConfigManager::setSystemConfig(bool initialized, uint32_t sleepTime, const String &deviceId, const String &stationId) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SYSTEM, doc);
    doc[KEY_INITIALIZED] = initialized;
    doc[KEY_SLEEP_TIME] = sleepTime;
    doc[KEY_DEVICE_ID] = deviceId;
    doc[KEY_STATION_ID] = stationId;
    writeNamespace(NAMESPACE_SYSTEM, doc);
}

/* =========================================================================
   CONFIGURACIÓN DE SENSORES NO-MODBUS
   ========================================================================= */
std::vector<SensorConfig> ConfigManager::getAllSensorConfigs() {
    std::vector<SensorConfig> configs;
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SENSORS, doc);
    
    if (!doc.is<JsonArray>()) {
        // Si no es un arreglo, no hay nada que leer
        return configs;
    }
    
    JsonArray sensorArray = doc.as<JsonArray>();
    for (JsonObject sensorObj : sensorArray) {
        SensorConfig config;
        const char* cKey = sensorObj[KEY_SENSOR] | "";
        strncpy(config.configKey, cKey, sizeof(config.configKey));
        const char* sensorId = sensorObj[KEY_SENSOR_ID] | "";
        strncpy(config.sensorId, sensorId, sizeof(config.sensorId));
        config.type = static_cast<SensorType>(sensorObj[KEY_SENSOR_TYPE] | 0);
        config.enable = sensorObj[KEY_SENSOR_ENABLE] | false;
        
        configs.push_back(config);
    }
    
    return configs;
}

std::vector<SensorConfig> ConfigManager::getEnabledSensorConfigs() {
    std::vector<SensorConfig> allSensors = getAllSensorConfigs();
    
    std::vector<SensorConfig> enabledSensors;
    for (const auto& sensor : allSensors) {
        if (sensor.enable && strlen(sensor.sensorId) > 0) {
            enabledSensors.push_back(sensor);
        }
    }
    
    return enabledSensors;
}

void ConfigManager::setSensorsConfigs(const std::vector<SensorConfig>& configs) {
    Preferences prefs;
    prefs.begin(NAMESPACE_SENSORS, false);
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    JsonArray sensorArray = doc.to<JsonArray>();
    
    for (const auto& sensor : configs) {
        JsonObject sensorObj = sensorArray.createNestedObject();
        sensorObj[KEY_SENSOR] = sensor.configKey;
        sensorObj[KEY_SENSOR_ID] = sensor.sensorId;
        sensorObj[KEY_SENSOR_TYPE] = static_cast<int>(sensor.type);
        sensorObj[KEY_SENSOR_ENABLE] = sensor.enable;
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    prefs.putString(NAMESPACE_SENSORS, jsonString.c_str());
    prefs.end();
}

/* =========================================================================
   CONFIGURACIÓN DE LORA
   ========================================================================= */
LoRaConfig ConfigManager::getLoRaConfig() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_LORAWAN, doc);
    
    LoRaConfig config;
    config.joinEUI  = doc[KEY_LORA_JOIN_EUI] | DEFAULT_JOIN_EUI;
    config.devEUI   = doc[KEY_LORA_DEV_EUI]  | DEFAULT_DEV_EUI;
    config.nwkKey   = doc[KEY_LORA_NWK_KEY]  | DEFAULT_NWK_KEY;
    config.appKey   = doc[KEY_LORA_APP_KEY]  | DEFAULT_APP_KEY;
    
    return config;
}

void ConfigManager::setLoRaConfig(
    const String &joinEUI, 
    const String &devEUI, 
    const String &nwkKey, 
    const String &appKey) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_LORAWAN, doc);
    
    doc[KEY_LORA_JOIN_EUI] = joinEUI;
    doc[KEY_LORA_DEV_EUI]  = devEUI;
    doc[KEY_LORA_NWK_KEY]  = nwkKey;
    doc[KEY_LORA_APP_KEY]  = appKey;
    
    writeNamespace(NAMESPACE_LORAWAN, doc);
}

/* =========================================================================
   CONFIGURACIÓN DE SENSORES MODBUS
   ========================================================================= */
// Definición de la variable estática
const ModbusSensorConfig ConfigManager::defaultModbusSensors[] = DEFAULT_MODBUS_SENSOR_CONFIGS;

void ConfigManager::setModbusSensorsConfigs(const std::vector<ModbusSensorConfig>& configs) {
    Preferences prefs;
    prefs.begin(NAMESPACE_SENSORS_MODBUS, false);
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    JsonArray sensorArray = doc.to<JsonArray>();
    
    for (const auto& sensor : configs) {
        JsonObject sensorObj = sensorArray.createNestedObject();
        sensorObj[KEY_MODBUS_SENSOR_ID] = sensor.sensorId;
        sensorObj[KEY_MODBUS_SENSOR_TYPE] = static_cast<int>(sensor.type);
        sensorObj[KEY_MODBUS_SENSOR_ADDR] = sensor.address;
        sensorObj[KEY_MODBUS_SENSOR_ENABLE] = sensor.enable;
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    prefs.putString(NAMESPACE_SENSORS_MODBUS, jsonString.c_str());
    prefs.end();
}

std::vector<ModbusSensorConfig> ConfigManager::getAllModbusSensorConfigs() {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_SENSORS_MODBUS, doc);
    
    std::vector<ModbusSensorConfig> configs;
    
    if (doc.is<JsonArray>()) {
        JsonArray array = doc.as<JsonArray>();
        
        for (JsonObject sensorObj : array) {
            ModbusSensorConfig config;
            strlcpy(config.sensorId, sensorObj[KEY_MODBUS_SENSOR_ID] | "", sizeof(config.sensorId));
            config.type = static_cast<SensorType>(sensorObj[KEY_MODBUS_SENSOR_TYPE] | 0);
            config.address = sensorObj[KEY_MODBUS_SENSOR_ADDR] | 1;
            config.enable = sensorObj[KEY_MODBUS_SENSOR_ENABLE] | false;
            
            configs.push_back(config);
        }
    }
    
    return configs;
}

std::vector<ModbusSensorConfig> ConfigManager::getEnabledModbusSensorConfigs() {
    std::vector<ModbusSensorConfig> all = getAllModbusSensorConfigs();
    std::vector<ModbusSensorConfig> enabled;
    for (auto &m : all) {
        if (m.enable) {
            enabled.push_back(m);
        }
    }
    return enabled;
}

/* =========================================================================
   CONFIGURACIÓN DE SENSORES ANALÓGICOS
   ========================================================================= */
void ConfigManager::getNTC100KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC100K, doc);
    t1 = doc[KEY_NTC100K_T1] | DEFAULT_T1_100K;
    r1 = doc[KEY_NTC100K_R1] | DEFAULT_R1_100K;
    t2 = doc[KEY_NTC100K_T2] | DEFAULT_T2_100K;
    r2 = doc[KEY_NTC100K_R2] | DEFAULT_R2_100K;
    t3 = doc[KEY_NTC100K_T3] | DEFAULT_T3_100K;
    r3 = doc[KEY_NTC100K_R3] | DEFAULT_R3_100K;
}

void ConfigManager::setNTC100KConfig(double t1, double r1, double t2, double r2, double t3, double r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC100K, doc);
    doc[KEY_NTC100K_T1] = t1;
    doc[KEY_NTC100K_R1] = r1;
    doc[KEY_NTC100K_T2] = t2;
    doc[KEY_NTC100K_R2] = r2;
    doc[KEY_NTC100K_T3] = t3;
    doc[KEY_NTC100K_R3] = r3;
    writeNamespace(NAMESPACE_NTC100K, doc);
}

void ConfigManager::getNTC10KConfig(double& t1, double& r1, double& t2, double& r2, double& t3, double& r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC10K, doc);
    t1 = doc[KEY_NTC10K_T1] | DEFAULT_T1_10K;
    r1 = doc[KEY_NTC10K_R1] | DEFAULT_R1_10K;
    t2 = doc[KEY_NTC10K_T2] | DEFAULT_T2_10K;
    r2 = doc[KEY_NTC10K_R2] | DEFAULT_R2_10K;
    t3 = doc[KEY_NTC10K_T3] | DEFAULT_T3_10K;
    r3 = doc[KEY_NTC10K_R3] | DEFAULT_R3_10K;
}

void ConfigManager::setNTC10KConfig(double t1, double r1, double t2, double r2, double t3, double r3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_NTC10K, doc);
    doc[KEY_NTC10K_T1] = t1;
    doc[KEY_NTC10K_R1] = r1;
    doc[KEY_NTC10K_T2] = t2;
    doc[KEY_NTC10K_R2] = r2;
    doc[KEY_NTC10K_T3] = t3;
    doc[KEY_NTC10K_R3] = r3;
    writeNamespace(NAMESPACE_NTC10K, doc);
}

void ConfigManager::getConductivityConfig(float& calTemp, float& coefComp, 
                                           float& v1, float& t1, float& v2, float& t2, float& v3, float& t3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_COND, doc);
    calTemp = doc[KEY_CONDUCT_CT] | CONDUCTIVITY_DEFAULT_TEMP;
    coefComp = doc[KEY_CONDUCT_CC] | TEMP_COEF_COMPENSATION;
    v1 = doc[KEY_CONDUCT_V1] | CONDUCTIVITY_DEFAULT_V1;
    t1 = doc[KEY_CONDUCT_T1] | CONDUCTIVITY_DEFAULT_T1;
    v2 = doc[KEY_CONDUCT_V2] | CONDUCTIVITY_DEFAULT_V2;
    t2 = doc[KEY_CONDUCT_T2] | CONDUCTIVITY_DEFAULT_T2;
    v3 = doc[KEY_CONDUCT_V3] | CONDUCTIVITY_DEFAULT_V3;
    t3 = doc[KEY_CONDUCT_T3] | CONDUCTIVITY_DEFAULT_T3;
}

void ConfigManager::setConductivityConfig(float calTemp, float coefComp,
                                           float v1, float t1, float v2, float t2, float v3, float t3) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_COND, doc);
    doc[KEY_CONDUCT_CT] = calTemp;
    doc[KEY_CONDUCT_CC] = coefComp;
    doc[KEY_CONDUCT_V1] = v1;
    doc[KEY_CONDUCT_T1] = t1;
    doc[KEY_CONDUCT_V2] = v2;
    doc[KEY_CONDUCT_T2] = t2;
    doc[KEY_CONDUCT_V3] = v3;
    doc[KEY_CONDUCT_T3] = t3;
    writeNamespace(NAMESPACE_COND, doc);
}

void ConfigManager::getPHConfig(float& v1, float& t1, float& v2, float& t2, float& v3, float& t3, float& defaultTemp) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_PH, doc);
    v1 = doc[KEY_PH_V1] | PH_DEFAULT_V1;
    t1 = doc[KEY_PH_T1] | PH_DEFAULT_T1;
    v2 = doc[KEY_PH_V2] | PH_DEFAULT_V2;
    t2 = doc[KEY_PH_T2] | PH_DEFAULT_T2;
    v3 = doc[KEY_PH_V3] | PH_DEFAULT_V3;
    t3 = doc[KEY_PH_T3] | PH_DEFAULT_T3;
    defaultTemp = doc[KEY_PH_CT] | PH_DEFAULT_TEMP;
}

void ConfigManager::setPHConfig(float v1, float t1, float v2, float t2, float v3, float t3, float defaultTemp) {
    StaticJsonDocument<JSON_DOC_SIZE_MEDIUM> doc;
    readNamespace(NAMESPACE_PH, doc);
    doc[KEY_PH_V1] = v1;
    doc[KEY_PH_T1] = t1;
    doc[KEY_PH_V2] = v2;
    doc[KEY_PH_T2] = t2;
    doc[KEY_PH_V3] = v3;
    doc[KEY_PH_T3] = t3;
    doc[KEY_PH_CT] = defaultTemp;
    writeNamespace(NAMESPACE_PH, doc);
}

================
File: src/ModbusMaster.cpp
================
/**
@file
Arduino library for communicating with Modbus slaves over RS232/485 (via RTU protocol).
*/
/*

  ModbusMaster.cpp - Arduino library for communicating with Modbus slaves
  over RS232/485 (via RTU protocol).

  Library:: ModbusMaster

  Copyright:: 2009-2016 Doc Walker

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*/


/* _____PROJECT INCLUDES_____________________________________________________ */
#include "ModbusMaster.h"


/* _____GLOBAL VARIABLES_____________________________________________________ */


/* _____PUBLIC FUNCTIONS_____________________________________________________ */
/**
Constructor.

Creates class object; initialize it using ModbusMaster::begin().

@ingroup setup
*/
ModbusMaster::ModbusMaster(void)
{
  _idle = 0;
  _preTransmission = 0;
  _postTransmission = 0;
}

/**
Initialize class object.

Assigns the Modbus slave ID and serial port.
Call once class has been instantiated, typically within setup().

@param slave Modbus slave ID (1..255)
@param &serial reference to serial port object (Serial, Serial1, ... Serial3)
@ingroup setup
*/
void ModbusMaster::begin(uint8_t slave, Stream &serial)
{
//  txBuffer = (uint16_t*) calloc(ku8MaxBufferSize, sizeof(uint16_t));
  _u8MBSlave = slave;
  _serial = &serial;
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
  
#if __MODBUSMASTER_DEBUG__
  pinMode(__MODBUSMASTER_DEBUG_PIN_A__, OUTPUT);
  pinMode(__MODBUSMASTER_DEBUG_PIN_B__, OUTPUT);
#endif
}


void ModbusMaster::beginTransmission(uint16_t u16Address)
{
  _u16WriteAddress = u16Address;
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
}

// eliminate this function in favor of using existing MB request functions
uint8_t ModbusMaster::requestFrom(uint16_t address, uint16_t quantity)
{
  uint8_t read;
  // clamp to buffer length
  if (quantity > ku8MaxBufferSize)
  {
    quantity = ku8MaxBufferSize;
  }
  // set rx buffer iterator vars
  _u8ResponseBufferIndex = 0;
  _u8ResponseBufferLength = read;

  return read;
}


void ModbusMaster::sendBit(bool data)
{
  uint8_t txBitIndex = u16TransmitBufferLength % 16;
  if ((u16TransmitBufferLength >> 4) < ku8MaxBufferSize)
  {
    if (0 == txBitIndex)
    {
      _u16TransmitBuffer[_u8TransmitBufferIndex] = 0;
    }
    bitWrite(_u16TransmitBuffer[_u8TransmitBufferIndex], txBitIndex, data);
    u16TransmitBufferLength++;
    _u8TransmitBufferIndex = u16TransmitBufferLength >> 4;
  }
}


void ModbusMaster::send(uint16_t data)
{
  if (_u8TransmitBufferIndex < ku8MaxBufferSize)
  {
    _u16TransmitBuffer[_u8TransmitBufferIndex++] = data;
    u16TransmitBufferLength = _u8TransmitBufferIndex << 4;
  }
}


void ModbusMaster::send(uint32_t data)
{
  send(lowWord(data));
  send(highWord(data));
}


void ModbusMaster::send(uint8_t data)
{
  send(word(data));
}









uint8_t ModbusMaster::available(void)
{
  return _u8ResponseBufferLength - _u8ResponseBufferIndex;
}


uint16_t ModbusMaster::receive(void)
{
  if (_u8ResponseBufferIndex < _u8ResponseBufferLength)
  {
    return _u16ResponseBuffer[_u8ResponseBufferIndex++];
  }
  else
  {
    return 0xFFFF;
  }
}








/**
Set idle time callback function (cooperative multitasking).

This function gets called in the idle time between transmission of data
and response from slave. Do not call functions that read from the serial
buffer that is used by ModbusMaster. Use of i2c/TWI, 1-Wire, other
serial ports, etc. is permitted within callback function.

@see ModbusMaster::ModbusMasterTransaction()
*/
void ModbusMaster::idle(void (*idle)())
{
  _idle = idle;
}

/**
Set pre-transmission callback function.

This function gets called just before a Modbus message is sent over serial.
Typical usage of this callback is to enable an RS485 transceiver's
Driver Enable pin, and optionally disable its Receiver Enable pin.

@see ModbusMaster::ModbusMasterTransaction()
@see ModbusMaster::postTransmission()
*/
void ModbusMaster::preTransmission(void (*preTransmission)())
{
  _preTransmission = preTransmission;
}

/**
Set post-transmission callback function.

This function gets called after a Modbus message has finished sending
(i.e. after all data has been physically transmitted onto the serial
bus).

Typical usage of this callback is to enable an RS485 transceiver's
Receiver Enable pin, and disable its Driver Enable pin.

@see ModbusMaster::ModbusMasterTransaction()
@see ModbusMaster::preTransmission()
*/
void ModbusMaster::postTransmission(void (*postTransmission)())
{
  _postTransmission = postTransmission;
}


/**
Retrieve data from response buffer.

@see ModbusMaster::clearResponseBuffer()
@param u8Index index of response buffer array (0x00..0x3F)
@return value in position u8Index of response buffer (0x0000..0xFFFF)
@ingroup buffer
*/
uint16_t ModbusMaster::getResponseBuffer(uint8_t u8Index)
{
  if (u8Index < ku8MaxBufferSize)
  {
    return _u16ResponseBuffer[u8Index];
  }
  else
  {
    return 0xFFFF;
  }
}


/**
Clear Modbus response buffer.

@see ModbusMaster::getResponseBuffer(uint8_t u8Index)
@ingroup buffer
*/
void ModbusMaster::clearResponseBuffer()
{
  uint8_t i;
  
  for (i = 0; i < ku8MaxBufferSize; i++)
  {
    _u16ResponseBuffer[i] = 0;
  }
}


/**
Place data in transmit buffer.

@see ModbusMaster::clearTransmitBuffer()
@param u8Index index of transmit buffer array (0x00..0x3F)
@param u16Value value to place in position u8Index of transmit buffer (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup buffer
*/
uint8_t ModbusMaster::setTransmitBuffer(uint8_t u8Index, uint16_t u16Value)
{
  if (u8Index < ku8MaxBufferSize)
  {
    _u16TransmitBuffer[u8Index] = u16Value;
    return ku8MBSuccess;
  }
  else
  {
    return ku8MBIllegalDataAddress;
  }
}


/**
Clear Modbus transmit buffer.

@see ModbusMaster::setTransmitBuffer(uint8_t u8Index, uint16_t u16Value)
@ingroup buffer
*/
void ModbusMaster::clearTransmitBuffer()
{
  uint8_t i;
  
  for (i = 0; i < ku8MaxBufferSize; i++)
  {
    _u16TransmitBuffer[i] = 0;
  }
}


/**
Modbus function 0x01 Read Coils.

This function code is used to read from 1 to 2000 contiguous status of 
coils in a remote device. The request specifies the starting address, 
i.e. the address of the first coil specified, and the number of coils. 
Coils are addressed starting at zero.

The coils in the response buffer are packed as one coil per bit of the 
data field. Status is indicated as 1=ON and 0=OFF. The LSB of the first 
data word contains the output addressed in the query. The other coils 
follow toward the high order end of this word and from low order to high 
order in subsequent words.

If the returned quantity is not a multiple of sixteen, the remaining 
bits in the final data word will be padded with zeros (toward the high 
order end of the word).

@param u16ReadAddress address of first coil (0x0000..0xFFFF)
@param u16BitQty quantity of coils to read (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::readCoils(uint16_t u16ReadAddress, uint16_t u16BitQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBReadCoils);
}


/**
Modbus function 0x02 Read Discrete Inputs.

This function code is used to read from 1 to 2000 contiguous status of 
discrete inputs in a remote device. The request specifies the starting 
address, i.e. the address of the first input specified, and the number 
of inputs. Discrete inputs are addressed starting at zero.

The discrete inputs in the response buffer are packed as one input per 
bit of the data field. Status is indicated as 1=ON; 0=OFF. The LSB of 
the first data word contains the input addressed in the query. The other 
inputs follow toward the high order end of this word, and from low order 
to high order in subsequent words.

If the returned quantity is not a multiple of sixteen, the remaining 
bits in the final data word will be padded with zeros (toward the high 
order end of the word).

@param u16ReadAddress address of first discrete input (0x0000..0xFFFF)
@param u16BitQty quantity of discrete inputs to read (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::readDiscreteInputs(uint16_t u16ReadAddress,
  uint16_t u16BitQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBReadDiscreteInputs);
}


/**
Modbus function 0x03 Read Holding Registers.

This function code is used to read the contents of a contiguous block of 
holding registers in a remote device. The request specifies the starting 
register address and the number of registers. Registers are addressed 
starting at zero.

The register data in the response buffer is packed as one word per 
register.

@param u16ReadAddress address of the first holding register (0x0000..0xFFFF)
@param u16ReadQty quantity of holding registers to read (1..125, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readHoldingRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  return ModbusMasterTransaction(ku8MBReadHoldingRegisters);
}


/**
Modbus function 0x04 Read Input Registers.

This function code is used to read from 1 to 125 contiguous input 
registers in a remote device. The request specifies the starting 
register address and the number of registers. Registers are addressed 
starting at zero.

The register data in the response buffer is packed as one word per 
register.

@param u16ReadAddress address of the first input register (0x0000..0xFFFF)
@param u16ReadQty quantity of input registers to read (1..125, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readInputRegisters(uint16_t u16ReadAddress,
  uint8_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  return ModbusMasterTransaction(ku8MBReadInputRegisters);
}


/**
Modbus function 0x05 Write Single Coil.

This function code is used to write a single output to either ON or OFF 
in a remote device. The requested ON/OFF state is specified by a 
constant in the state field. A non-zero value requests the output to be 
ON and a value of 0 requests it to be OFF. The request specifies the 
address of the coil to be forced. Coils are addressed starting at zero.

@param u16WriteAddress address of the coil (0x0000..0xFFFF)
@param u8State 0=OFF, non-zero=ON (0x00..0xFF)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::writeSingleCoil(uint16_t u16WriteAddress, uint8_t u8State)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = (u8State ? 0xFF00 : 0x0000);
  return ModbusMasterTransaction(ku8MBWriteSingleCoil);
}


/**
Modbus function 0x06 Write Single Register.

This function code is used to write a single holding register in a 
remote device. The request specifies the address of the register to be 
written. Registers are addressed starting at zero.

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16WriteValue value to be written to holding register (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::writeSingleRegister(uint16_t u16WriteAddress,
  uint16_t u16WriteValue)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = 0;
  _u16TransmitBuffer[0] = u16WriteValue;
  return ModbusMasterTransaction(ku8MBWriteSingleRegister);
}


/**
Modbus function 0x0F Write Multiple Coils.

This function code is used to force each coil in a sequence of coils to 
either ON or OFF in a remote device. The request specifies the coil 
references to be forced. Coils are addressed starting at zero.

The requested ON/OFF states are specified by contents of the transmit 
buffer. A logical '1' in a bit position of the buffer requests the 
corresponding output to be ON. A logical '0' requests it to be OFF.

@param u16WriteAddress address of the first coil (0x0000..0xFFFF)
@param u16BitQty quantity of coils to write (1..2000, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup discrete
*/
uint8_t ModbusMaster::writeMultipleCoils(uint16_t u16WriteAddress,
  uint16_t u16BitQty)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16BitQty;
  return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}
uint8_t ModbusMaster::writeMultipleCoils()
{
  _u16WriteQty = u16TransmitBufferLength;
  return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}


/**
Modbus function 0x10 Write Multiple Registers.

This function code is used to write a block of contiguous registers (1 
to 123 registers) in a remote device.

The requested written values are specified in the transmit buffer. Data 
is packed as one word per register.

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16WriteQty quantity of holding registers to write (1..123, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::writeMultipleRegisters(uint16_t u16WriteAddress,
  uint16_t u16WriteQty)
{
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16WriteQty;
  return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}

// new version based on Wire.h
uint8_t ModbusMaster::writeMultipleRegisters()
{
  _u16WriteQty = _u8TransmitBufferIndex;
  return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}


/**
Modbus function 0x16 Mask Write Register.

This function code is used to modify the contents of a specified holding 
register using a combination of an AND mask, an OR mask, and the 
register's current contents. The function can be used to set or clear 
individual bits in the register.

The request specifies the holding register to be written, the data to be 
used as the AND mask, and the data to be used as the OR mask. Registers 
are addressed starting at zero.

The function's algorithm is:

Result = (Current Contents && And_Mask) || (Or_Mask && (~And_Mask))

@param u16WriteAddress address of the holding register (0x0000..0xFFFF)
@param u16AndMask AND mask (0x0000..0xFFFF)
@param u16OrMask OR mask (0x0000..0xFFFF)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::maskWriteRegister(uint16_t u16WriteAddress,
  uint16_t u16AndMask, uint16_t u16OrMask)
{
  _u16WriteAddress = u16WriteAddress;
  _u16TransmitBuffer[0] = u16AndMask;
  _u16TransmitBuffer[1] = u16OrMask;
  return ModbusMasterTransaction(ku8MBMaskWriteRegister);
}


/**
Modbus function 0x17 Read Write Multiple Registers.

This function code performs a combination of one read operation and one 
write operation in a single MODBUS transaction. The write operation is 
performed before the read. Holding registers are addressed starting at 
zero.

The request specifies the starting address and number of holding 
registers to be read as well as the starting address, and the number of 
holding registers. The data to be written is specified in the transmit 
buffer.

@param u16ReadAddress address of the first holding register (0x0000..0xFFFF)
@param u16ReadQty quantity of holding registers to read (1..125, enforced by remote device)
@param u16WriteAddress address of the first holding register (0x0000..0xFFFF)
@param u16WriteQty quantity of holding registers to write (1..121, enforced by remote device)
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t ModbusMaster::readWriteMultipleRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty, uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  _u16WriteAddress = u16WriteAddress;
  _u16WriteQty = u16WriteQty;
  return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}
uint8_t ModbusMaster::readWriteMultipleRegisters(uint16_t u16ReadAddress,
  uint16_t u16ReadQty)
{
  _u16ReadAddress = u16ReadAddress;
  _u16ReadQty = u16ReadQty;
  _u16WriteQty = _u8TransmitBufferIndex;
  return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}


/* _____PRIVATE FUNCTIONS____________________________________________________ */
/**
Modbus transaction engine.
Sequence:
  - assemble Modbus Request Application Data Unit (ADU),
    based on particular function called
  - transmit request over selected serial port
  - wait for/retrieve response
  - evaluate/disassemble response
  - return status (success/exception)

@param u8MBFunction Modbus function (0x01..0xFF)
@return 0 on success; exception number on failure
*/
uint8_t ModbusMaster::ModbusMasterTransaction(uint8_t u8MBFunction)
{
  uint8_t u8ModbusADU[256];
  uint8_t u8ModbusADUSize = 0;
  uint8_t i, u8Qty;
  uint16_t u16CRC;
  uint32_t u32StartTime;
  uint8_t u8BytesLeft = 8;
  uint8_t u8MBStatus = ku8MBSuccess;
  
  // assemble Modbus Request Application Data Unit
  u8ModbusADU[u8ModbusADUSize++] = _u8MBSlave;
  u8ModbusADU[u8ModbusADUSize++] = u8MBFunction;
  
  switch(u8MBFunction)
  {
    case ku8MBReadCoils:
    case ku8MBReadDiscreteInputs:
    case ku8MBReadInputRegisters:
    case ku8MBReadHoldingRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadAddress);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadAddress);
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadQty);
      break;
  }
  
  switch(u8MBFunction)
  {
    case ku8MBWriteSingleCoil:
    case ku8MBMaskWriteRegister:
    case ku8MBWriteMultipleCoils:
    case ku8MBWriteSingleRegister:
    case ku8MBWriteMultipleRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteAddress);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteAddress);
      break;
  }
  
  switch(u8MBFunction)
  {
    case ku8MBWriteSingleCoil:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      break;
      
    case ku8MBWriteSingleRegister:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
      break;
      
    case ku8MBWriteMultipleCoils:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      u8Qty = (_u16WriteQty % 8) ? ((_u16WriteQty >> 3) + 1) : (_u16WriteQty >> 3);
      u8ModbusADU[u8ModbusADUSize++] = u8Qty;
      for (i = 0; i < u8Qty; i++)
      {
        switch(i % 2)
        {
          case 0: // i is even
            u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i >> 1]);
            break;
            
          case 1: // i is odd
            u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i >> 1]);
            break;
        }
      }
      break;
      
    case ku8MBWriteMultipleRegisters:
    case ku8MBReadWriteMultipleRegisters:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty << 1);
      
      for (i = 0; i < lowByte(_u16WriteQty); i++)
      {
        u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i]);
        u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i]);
      }
      break;
      
    case ku8MBMaskWriteRegister:
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
      u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[1]);
      u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[1]);
      break;
  }
  
  // append CRC
  u16CRC = 0xFFFF;
  for (i = 0; i < u8ModbusADUSize; i++)
  {
    u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
  }
  u8ModbusADU[u8ModbusADUSize++] = lowByte(u16CRC);
  u8ModbusADU[u8ModbusADUSize++] = highByte(u16CRC);
  u8ModbusADU[u8ModbusADUSize] = 0;

  // flush receive buffer before transmitting request
  while (_serial->read() != -1);

  // transmit request
  if (_preTransmission)
  {
    _preTransmission();
  }
  for (i = 0; i < u8ModbusADUSize; i++)
  {
    _serial->write(u8ModbusADU[i]);
  }
  
  u8ModbusADUSize = 0;
  _serial->flush();    // flush transmit buffer
  if (_postTransmission)
  {
    _postTransmission();
  }
  
  // loop until we run out of time or bytes, or an error occurs
  u32StartTime = millis();
  while (u8BytesLeft && !u8MBStatus)
  {
    if (_serial->available())
    {
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_A__, true);
#endif
      u8ModbusADU[u8ModbusADUSize++] = _serial->read();
      u8BytesLeft--;
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_A__, false);
#endif
    }
    else
    {
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_B__, true);
#endif
      if (_idle)
      {
        _idle();
      }
#if __MODBUSMASTER_DEBUG__
      digitalWrite(__MODBUSMASTER_DEBUG_PIN_B__, false);
#endif
    }
    
    // evaluate slave ID, function code once enough bytes have been read
    if (u8ModbusADUSize == 5)
    {
      // verify response is for correct Modbus slave
      if (u8ModbusADU[0] != _u8MBSlave)
      {
        u8MBStatus = ku8MBInvalidSlaveID;
        break;
      }
      
      // verify response is for correct Modbus function code (mask exception bit 7)
      if ((u8ModbusADU[1] & 0x7F) != u8MBFunction)
      {
        u8MBStatus = ku8MBInvalidFunction;
        break;
      }
      
      // check whether Modbus exception occurred; return Modbus Exception Code
      if (bitRead(u8ModbusADU[1], 7))
      {
        u8MBStatus = u8ModbusADU[2];
        break;
      }
      
      // evaluate returned Modbus function code
      switch(u8ModbusADU[1])
      {
        case ku8MBReadCoils:
        case ku8MBReadDiscreteInputs:
        case ku8MBReadInputRegisters:
        case ku8MBReadHoldingRegisters:
        case ku8MBReadWriteMultipleRegisters:
          u8BytesLeft = u8ModbusADU[2];
          break;
          
        case ku8MBWriteSingleCoil:
        case ku8MBWriteMultipleCoils:
        case ku8MBWriteSingleRegister:
        case ku8MBWriteMultipleRegisters:
          u8BytesLeft = 3;
          break;
          
        case ku8MBMaskWriteRegister:
          u8BytesLeft = 5;
          break;
      }
    }
    if ((millis() - u32StartTime) > ku16MBResponseTimeout)
    {
      u8MBStatus = ku8MBResponseTimedOut;
    }
  }
  
  // verify response is large enough to inspect further
  if (!u8MBStatus && u8ModbusADUSize >= 5)
  {
    // calculate CRC
    u16CRC = 0xFFFF;
    for (i = 0; i < (u8ModbusADUSize - 2); i++)
    {
      u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
    }
    
    // verify CRC
    if (!u8MBStatus && (lowByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 2] ||
      highByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 1]))
    {
      u8MBStatus = ku8MBInvalidCRC;
    }
  }

  // disassemble ADU into words
  if (!u8MBStatus)
  {
    // evaluate returned Modbus function code
    switch(u8ModbusADU[1])
    {
      case ku8MBReadCoils:
      case ku8MBReadDiscreteInputs:
        // load bytes into word; response bytes are ordered L, H, L, H, ...
        for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 4], u8ModbusADU[2 * i + 3]);
          }
          
          _u8ResponseBufferLength = i;
        }
        
        // in the event of an odd number of bytes, load last byte into zero-padded word
        if (u8ModbusADU[2] % 2)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(0, u8ModbusADU[2 * i + 3]);
          }
          
          _u8ResponseBufferLength = i + 1;
        }
        break;
        
      case ku8MBReadInputRegisters:
      case ku8MBReadHoldingRegisters:
      case ku8MBReadWriteMultipleRegisters:
        // load bytes into word; response bytes are ordered H, L, H, L, ...
        for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
        {
          if (i < ku8MaxBufferSize)
          {
            _u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 3], u8ModbusADU[2 * i + 4]);
          }
          
          _u8ResponseBufferLength = i;
        }
        break;
    }
  }
  
  _u8TransmitBufferIndex = 0;
  u16TransmitBufferLength = 0;
  _u8ResponseBufferIndex = 0;
  return u8MBStatus;
}

================
File: src/ModbusSensorManager.cpp
================
#include "ModbusSensorManager.h"
#include "config.h"    // Para MODBUS_BAUD_RATE y MODBUS_SERIAL_CONFIG

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

#include "ModbusMaster.h"
#include "debug.h"     // Para DEBUG_END
#include "sensor_types.h" // Para todos los tipos y constantes de sensores
#include "utilities.h"
#include <string.h>

// Crear una instancia global de ModbusMaster
ModbusMaster modbus;

// Definir Serial2 para la comunicación Modbus
HardwareSerial modbusSerial(2); // Usar Serial2 para comunicación Modbus

/**
 * @note 
 *  - Se usa la biblioteca ModbusMaster para la comunicación Modbus
 *  - Se asume que el pin DE/RE del transceiver RS485 está atado de forma que cuando
 *    se escribe en Serial, se habilita la transmisión, y al terminar, pasa a recepción.
 */

void ModbusSensorManager::beginModbus() {
    // Configurar Serial2 usando los parámetros definidos en config.h
    modbusSerial.begin(MODBUS_BAUD_RATE, MODBUS_SERIAL_CONFIG, MODBUS_RX_PIN, MODBUS_TX_PIN);
    
    // Inicializar ModbusMaster con Serial2
    modbus.begin(0, modbusSerial); // El slave ID se configurará en cada petición
}

void ModbusSensorManager::endModbus() {
    // Finalizar la comunicación Serial2 de Modbus
    modbusSerial.end();
}

bool ModbusSensorManager::readHoldingRegisters(uint8_t address, uint16_t startReg, uint16_t numRegs, uint16_t* outData) {
    // Guardar los bytes recibidos para depuración posterior
    uint8_t result;
    
    // Establecer el slave ID
    modbus.begin(address, modbusSerial);
    
    // Implementar reintentos de lectura
    for (uint8_t retry = 0; retry < MODBUS_MAX_RETRY; retry++) {
        // Registrar el tiempo de inicio para implementar timeout manual
        uint32_t startTime = millis();
        
        // Realizar la petición Modbus para leer registros holding
        result = modbus.readHoldingRegisters(startReg, numRegs);
        
        // Verificar si la lectura fue exitosa
        if (result == modbus.ku8MBSuccess) {
            // Extraer datos de los registros
            for (uint8_t i = 0; i < numRegs; i++) {
                outData[i] = modbus.getResponseBuffer(i);
            }
            
            return true;
        }
        
        // Verificar si se agotó el tiempo (timeout personalizado)
        if ((millis() - startTime) >= MODBUS_RESPONSE_TIMEOUT) {
            DEBUG_PRINTLN("Timeout en comunicación Modbus");
            break; // Salir del bucle de reintentos si se agota el tiempo
        }
        
        // Si no es el último intento, continuar con el siguiente intento
        DEBUG_PRINTF("Intento %d fallido, código: %d\n", retry + 1, result);
    }
    
    // Si llegamos aquí, todos los intentos fallaron
    DEBUG_PRINTF("Error Modbus después de %d intentos\n", MODBUS_MAX_RETRY);
    return false;
}

ModbusSensorReading ModbusSensorManager::readEnvSensor(const ModbusSensorConfig &cfg) {
    ModbusSensorReading reading;
    strncpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId));
    reading.type = cfg.type;
    reading.subValues.clear();

    // Lectura de 8 registros (500..507)
    const uint16_t startReg = 500;
    const uint16_t numRegs = 8;
    uint16_t rawData[8];
    memset(rawData, 0, sizeof(rawData));
    
    bool ok = readHoldingRegisters(cfg.address, startReg, numRegs, rawData);
    if (!ok) {
        // Llenar con NAN si falló
        // Respetamos el orden: [0]=Humedad, [1]=Temperatura, [2]=Presión, [3]=Iluminación
        for (int i=0; i<4; i++){
            SubValue sv;
            sv.value = NAN;
            reading.subValues.push_back(sv);
        }
        return reading;
    }

    // Extraer según datasheet (versión 4 en 1):
    // rawData[0] = Humedad entera *10
    // rawData[1] = Temp entera *10 (16 bits con posible signo)
    // rawData[5] = Presión *10 (en kPa)
    // rawData[6] = LuxHigh (32 bits -> parte alta)
    // rawData[7] = LuxLow  (32 bits -> parte baja)
    // Los demás registros (ruido, PM2.5, PM10) vienen en 0 y se ignoran

    // Agregar Humedad como primer valor [0]
    {
        SubValue sH;
        sH.value = rawData[0] / 10.0f;
        reading.subValues.push_back(sH);
    }
    
    // Agregar Temperatura como segundo valor [1]
    {
        SubValue sT;
        // Ver si es negativo
        int16_t temp16 = (int16_t)rawData[1];
        sT.value = temp16 / 10.0f;
        reading.subValues.push_back(sT);
    }
    
    // Agregar Presión Atmosférica como tercer valor [2]
    {
        SubValue sP;
        sP.value = rawData[5] / 10.0f;
        reading.subValues.push_back(sP);
    }
    
    // Agregar Iluminación como cuarto valor [3]
    {
        SubValue sL;
        uint32_t lux = ((uint32_t)rawData[6] << 16) | rawData[7];
        sL.value = (float)lux;
        reading.subValues.push_back(sL);
    }
    
    return reading;
}

#endif // defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)

================
File: src/PowerManager.cpp
================
#include "PowerManager.h"

PowerManager::PowerManager() {
    // Constructor sin dependencias externas
}

void PowerManager::begin() {
    // Configurar pines como salidas
    pinMode(POWER_3V3_PIN, OUTPUT);
    pinMode(POWER_12V_PIN, OUTPUT);
    
    // Asegurar que todas las fuentes están apagadas al inicio
    allPowerOff();
}

void PowerManager::power3V3On() {
    digitalWrite(POWER_3V3_PIN, LOW);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power3V3Off() {
    digitalWrite(POWER_3V3_PIN, HIGH);
}

void PowerManager::power12VOn() {
    digitalWrite(POWER_12V_PIN, HIGH);
    delay(POWER_STABILIZE_DELAY);
}

void PowerManager::power12VOff() {
    digitalWrite(POWER_12V_PIN, LOW);
}

void PowerManager::allPowerOff() {
    power3V3Off();
    power12VOff();
}

================
File: src/sensors/ConductivitySensor.cpp
================
#include "sensors/ConductivitySensor.h"

#include <cmath>
#include "sensors/NtcManager.h"
#include "config.h"

/**
 * @brief Convierte el voltaje medido a valor de conductividad/TDS en ppm
 * 
 * @param voltage Voltaje medido del sensor
 * @param tempC Temperatura del agua en grados Celsius para compensación
 * @return float Valor de TDS en ppm (partes por millón)
 */
float ConductivitySensor::convertVoltageToConductivity(float voltage, float tempC) {
    float calTemp, coefComp, V1, T1, V2, T2, V3, T3;
    ConfigManager::getConductivityConfig(calTemp, coefComp, V1, T1, V2, T2, V3, T3);

    // Si tempC es NAN, usar la temperatura de calibración como valor por defecto
    if (isnan(tempC)) {
        tempC = calTemp;
    }

    // Matriz para resolver el sistema de ecuaciones
    // Basado en 3 puntos de calibración
    const double det = V1*V1*(V2 - V3) - V1*(V2*V2 - V3*V3) + (V2*V2*V3 - V2*V3*V3);
    
    // Calcular coeficientes solo si el determinante no es cero
    if(fabs(det) > 1e-6) {
        const double a = (T1*(V2 - V3) - T2*(V1 - V3) + T3*(V1 - V2)) / det;
        const double b = (T1*(V3*V3 - V2*V2) + T2*(V1*V1 - V3*V3) + T3*(V2*V2 - V1*V1)) / det;
        const double c = (T1*(V2*V2*V3 - V2*V3*V3) - T2*(V1*V1*V3 - V1*V3*V3) + T3*(V1*V1*V2 - V1*V2*V2)) / det;
        
        // Aplicar compensación de temperatura
        const double compensation = 1.0 + coefComp * (tempC - calTemp);
        double compensatedVoltage = voltage / compensation;
        double conductivity = a * (compensatedVoltage * compensatedVoltage) 
                    + b * compensatedVoltage 
                    + c;

        return fmax(conductivity, 0.0);
    }
    else {
        return NAN;
    }
}

/**
 * @brief Lee el sensor de conductividad conectado al pin analógico
 * 
 * @return float Valor de conductividad/TDS en ppm, o NAN si hay error
 */
float ConductivitySensor::read() {
    // Leer el valor del pin analógico
    int adcValue = analogRead(COND_SENSOR_PIN);
    
    // Convertir el valor ADC a voltaje (0-3.3V con resolución de 12 bits)
    float voltage = adcValue * (3.3f / 4095.0f);
    
    // Verificar si el voltaje es válido
    if (isnan(voltage) || voltage <= 0.0f || voltage >= 3.3f) {
        return NAN;
    }
    
    // Obtener temperatura únicamente del sensor NTC10K
    float waterTemp = NtcManager::readNtc10kTemperature();
    
    // Convertir a conductividad con compensación de temperatura
    float tdsValue = convertVoltageToConductivity(voltage, waterTemp);
    return tdsValue;
}

================
File: src/sensors/DS18B20Sensor.cpp
================
#include "sensors/DS18B20Sensor.h"

#if defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)

/**
 * @brief Lee la temperatura del sensor DS18B20
 * 
 * @return float Temperatura en °C, o NAN si hay error
 */
float DS18B20Sensor::read() {
    dallasTemp.requestTemperatures();
    float temp = dallasTemp.getTempCByIndex(0);
    if (temp == DEVICE_DISCONNECTED_C) {
        return NAN;
    }
    return temp;
}


#endif // defined(DEVICE_TYPE_BASIC) || defined(DEVICE_TYPE_ANALOGIC)

================
File: src/sensors/HDS10Sensor.cpp
================
#include "sensors/HDS10Sensor.h"

#include <cmath>
#include "config.h"

/**
 * @brief Convierte la resistencia del sensor HDS10 a porcentaje de humedad usando interpolación logarítmica
 * @param sensorR Resistencia del sensor en ohms
 * @return Porcentaje de humedad relativa (50-100%)
 */
float HDS10Sensor::convertResistanceToHumidity(float sensorR) {
    // Tabla de valores aproximados de la curva "Average" del sensor
    // Valores en kΩ vs. %HR
    static const float Rvals[] = { 1.0f,   2.0f,   5.0f,   10.0f,  50.0f,  100.0f, 200.0f };
    static const float Hvals[] = { 50.0f, 60.0f, 70.0f,  80.0f, 90.0f, 95.0f, 100.0f };
    static const int   NPOINTS = sizeof(Rvals)/sizeof(Rvals[0]);
    
    // Pasar ohms a kΩ
    float Rk = sensorR * 1e-3f;
    
    // Si está por debajo de la primera resistencia, limitamos a Hvals[0]
    if (Rk <= Rvals[0]) {
        return Hvals[0];
    }
    
    // Si está por encima de la última resistencia, limitamos a Hvals[NPOINTS-1]
    if (Rk >= Rvals[NPOINTS-1]) {
        return Hvals[NPOINTS-1];
    }

    // Buscar en qué tramo cae Rk
    for (int i=0; i < NPOINTS-1; i++) {
        float R1 = Rvals[i];
        float R2 = Rvals[i+1];
        if (Rk >= R1 && Rk <= R2) {
            // Interpolación logarítmica entre R1 y R2
            float logR   = log10(Rk);
            float logR1  = log10(R1);
            float logR2  = log10(R2);

            float HR1 = Hvals[i];
            float HR2 = Hvals[i+1];

            float humidity = HR1 + (HR2 - HR1) * ((logR - logR1) / (logR2 - logR1));
            return humidity;
        }
    }

    // Deberíamos haber retornado dentro del for, pero por seguridad:
    return Hvals[NPOINTS-1];
}

/**
 * @brief Lee el sensor HDS10 conectado al pin analógico
 * 
 * @return float Porcentaje de humedad (0-100%) según calibración definida
 *               o NAN si ocurre un error o no es posible leer
 */
float HDS10Sensor::read() {
    // Leer el valor del pin analógico
    int adcValue = analogRead(HDS10_SENSOR_PIN);
    
    // Convertir el valor ADC a voltaje (0-3.3V con resolución de 12 bits)
    float voltage = adcValue * (3.3f / 4095.0f);
    
    // Verificar si el voltaje está en rango válido
    if (voltage <= 0.0f || voltage >= 3.3f) {
        return NAN; // Valor fuera de rango
    }
    
    // Calcular la resistencia del sensor basado en el divisor de voltaje
    // El circuito es: 3.3V --- R1(220K) --- [Punto de medición] --- R2(220K) --- HDS10 --- GND
    // Y estamos midiendo la caída de voltaje en R2+HDS10
    
    float r1 = 220000.0f; // Primera resistencia de 220K
    float r2 = 220000.0f; // Segunda resistencia de 220K
    
    // Calculamos la corriente en el circuito (que es la misma en toda la serie)
    // I = (3.3V - voltage) / R1
    float current = (3.3f - voltage) / r1;
    
    // El voltaje medido es la caída en R2+HDS10
    // voltage = I * (R2 + HDS10)
    // Por lo tanto, HDS10 = voltage/I - R2
    float sensorR = (voltage / current) - r2;
    
    if (sensorR < 0.0f) {
        return NAN; // Valor no válido
    }
    
    // Usar la función de conversión basada en interpolación logarítmica
    float percentage = convertResistanceToHumidity(sensorR);
    
    return percentage;
}

================
File: src/sensors/NtcManager.h
================
#ifndef NTC_MANAGER_H
#define NTC_MANAGER_H

class NtcManager {
public:
    /**
     * Lee la temperatura del sensor NTC100K
     * @param configKey Identificador de la configuración del sensor (0 o 1)
     * @return Temperatura en grados Celsius, o NAN si hay error
     */
    static double readNtc100kTemperature(const char* configKey);
    
    /**
     * Lee la temperatura del sensor NTC10K
     * @return Temperatura en grados Celsius, o NAN si hay error
     */
    static double readNtc10kTemperature();

private:
    /**
     * Calcula los coeficientes A, B, C para la ecuación de Steinhart-Hart
     * basado en tres pares de puntos temperatura-resistencia
     */
    static void calculateSteinhartHartCoeffs(double T1, double R1,
                                          double T2, double R2,
                                          double T3, double R3,
                                          double &A, double &B, double &C);
    
    /**
     * Calcula la temperatura usando la ecuación de Steinhart-Hart
     * @param resistance La resistencia del termistor en ohms
     * @param A,B,C Los coeficientes de Steinhart-Hart
     * @return Temperatura en grados Celsius
     */
    static double steinhartHartTemperature(double resistance, double A, double B, double C);
    
    /**
     * Calcula la resistencia del NTC basado en un divisor de voltaje
     * @param voltage Voltaje medido en el punto medio del divisor
     * @param vRef Voltaje de referencia
     * @param rFixed Resistencia fija del divisor
     * @param ntcTop true si el NTC está conectado a Vref, false si está conectado a GND
     * @return Resistencia del NTC en ohms, o -1 si hay error
     */
    static double computeNtcResistanceFromVoltageDivider(double voltage, double vRef, double rFixed, bool ntcTop);
};

#endif // NTC_MANAGER_H

================
File: src/sensors/PHSensor.cpp
================
#include "sensors/PHSensor.h"

#include <cmath>
#include "sensors/NtcManager.h"
#include "config.h"

/**
 * @brief Convierte el voltaje medido a valor de pH
 * 
 * @param voltage Voltaje medido del sensor de pH
 * @param tempC Temperatura del agua en grados Celsius para compensación
 * @return float Valor de pH (0-14)
 */
float PHSensor::convertVoltageToPH(float voltage, float tempC) {
    float V1, T1, V2, T2, V3, T3, TEMP_CAL;
    ConfigManager::getPHConfig(V1, T1, V2, T2, V3, T3, TEMP_CAL);

    // Si solutionTemp es NAN, usar la temperatura de calibración como valor por defecto
    if (isnan(tempC)) {
        tempC = TEMP_CAL;
    }

    // Datos de calibración (pH, voltaje)
    const double pH_calib[] = {T1, T2, T3};
    const double V_calib[] = {V1, V2, V3};
    const int n = 3; // Número de puntos de calibración

    // Calcular sumatorias necesarias para mínimos cuadrados
    double sum_pH = 0.0;
    double sum_V = 0.0;
    double sum_pHV = 0.0;
    double sum_pH2 = 0.0;

    for (int i = 0; i < n; i++) {
        sum_pH += pH_calib[i];
        sum_V += V_calib[i];
        sum_pHV += pH_calib[i] * V_calib[i];
        sum_pH2 += pH_calib[i] * pH_calib[i];
    }

    // Calcular la pendiente S usando mínimos cuadrados
    double S_CAL = ((n * sum_pHV) - (sum_pH * sum_V)) / ((n * sum_pH2) - (sum_pH * sum_pH));

    // Calcular el offset E0 usando mínimos cuadrados
    double E0 = ((sum_V) + (S_CAL * sum_pH)) / n;

    // Ajustar la pendiente según la temperatura actual usando la ecuación de Nernst
    const double tempK = (tempC + 273.15);
    const double tempCalK = (TEMP_CAL + 273.15);
    const double S_T = S_CAL * (tempK / tempCalK);

    // Calcular pH usando la ecuación de Nernst ajustada: pH = (E0 - E) / S(T)
    double pH = ((E0 + voltage) / S_T);
    // Limitar el pH a un rango físicamente posible (0-14)
    pH = constrain(pH, 0.0, 14.0);

    return pH;
}

/**
 * @brief Lee el sensor de pH conectado al pin analógico
 * 
 * @return float Valor de pH (0-14), o NAN si hay error
 */
float PHSensor::read() {
    // Leer el valor del pin analógico
    int adcValue = analogRead(PH_SENSOR_PIN);
    
    // Convertir el valor ADC a voltaje (0-3.3V con resolución de 12 bits)
    float voltage = adcValue * (3.3f / 4095.0f);
    
    // Ajuste del offset: en el sistema anterior, un pH neutro daba un voltaje
    // cercano a 0V, pero ahora puede necesitar un offset diferente
    // dependiendo de cómo esté conectado el circuito
    voltage = voltage - 1.65f; // Restar punto medio para obtener voltaje diferencial
    
    // Verificar si el voltaje es válido
    if (isnan(voltage) || voltage < -2.5f || voltage > 2.5f) {
        return NAN;
    }
    
    // Obtener temperatura únicamente del sensor NTC10K
    float waterTemp = NtcManager::readNtc10kTemperature();
    
    // Convertir a pH con compensación de temperatura
    float pHValue = convertVoltageToPH(voltage, waterTemp);
    
    return pHValue;
}

================
File: src/sensors/SHT30Sensor.cpp
================
#include "sensors/SHT30Sensor.h"

/**
 * @brief Lee temperatura y humedad del sensor SHT30
 * 
 * @param outTemp Variable donde se almacenará la temperatura en °C
 * @param outHum Variable donde se almacenará la humedad relativa en %
 */
void SHT30Sensor::read(float &outTemp, float &outHum) {
    // Intentar hasta 10 veces obtener una lectura válida
    for (int i = 0; i < 15; i++) {
        if (sht30Sensor.read()) {
            float temp = sht30Sensor.getTemperature();
            float hum = sht30Sensor.getHumidity();
            
            // Verificar que los valores sean válidos (no cero y dentro de rangos razonables)
            if (temp != 0.0f && hum != 0.0f && temp > -40.0f && temp < 125.0f && hum > 0.0f && hum <= 100.0f) {
                outTemp = temp;
                outHum = hum;
                return; // Retornar inmediatamente con la primera lectura válida
            }
        }
        delay(1); // Pausa entre mediciones
    }

    // Si no se encontró ninguna lectura válida
    outTemp = NAN;
    outHum = NAN;
}

================
File: src/sensors/VEML7700Sensor.cpp
================
#include "sensors/VEML7700Sensor.h"

// Variable externa del sensor VEML7700
extern Adafruit_VEML7700 veml7700;

/**
 * @brief Inicializa el sensor VEML7700 y lo configura para luz brillante/exterior
 * 
 * @return true si la inicialización fue exitosa, false en caso contrario
 */
bool VEML7700Sensor::begin() {
    bool success = false;
    
    // Intentar inicializar hasta 3 veces si falla
    for (int i = 0; i < 3; i++) {
        success = veml7700.begin();
        if (success) break;
        delay(5); // Pequeña pausa entre intentos
    }
    
    if (!success) {
        return false;
    }
    
    // Configurar para entornos de luz brillante (exterior/solar)
    // Usar la ganancia más baja para manejar la alta intensidad del sol sin saturar
    veml7700.setGain(VEML7700_GAIN_1_8);
    
    // Usar el tiempo de integración más corto para una lectura rápida
    veml7700.setIntegrationTime(VEML7700_IT_25MS);
    
    return true;
}

/**
 * @brief Lee el nivel de luz en lux del sensor VEML7700
 * 
 * @return float Valor en lux, o NAN si hay error
 */
float VEML7700Sensor::read() {
    // Leer el valor de luz en lux utilizando la configuración fija (no el modo automático)
    // para maximizar la velocidad y minimizar el consumo de energía
    float lux = veml7700.readLux();
    
    // Verificar si la lectura es válida
    if (isnan(lux) || lux < 0.0f) {
        return NAN;
    }
    
    return lux;
}

================
File: src/SHT31.cpp
================
//
//    FILE: SHT31.cpp
//  AUTHOR: Rob Tillaart
// VERSION: 0.5.0
//    DATE: 2019-02-08
// PURPOSE: Arduino library for the SHT31 temperature and humidity sensor
//          https://www.adafruit.com/product/2857
//     URL: https://github.com/RobTillaart/SHT31


#include "SHT31.h"


//  SUPPORTED COMMANDS - single shot mode only
#define SHT31_READ_STATUS       0xF32D
#define SHT31_CLEAR_STATUS      0x3041

#define SHT31_SOFT_RESET        0x30A2
#define SHT31_HARD_RESET        0x0006

#define SHT31_MEASUREMENT_FAST  0x2416     //  page 10 datasheet
#define SHT31_MEASUREMENT_SLOW  0x2400     //  no clock stretching

#define SHT31_HEAT_ON           0x306D
#define SHT31_HEAT_OFF          0x3066
#define SHT31_HEATER_TIMEOUT    180000UL   //  milliseconds


SHT31::SHT31(uint8_t address, TwoWire *wire)
{
  _wire           = wire;
  _address        = address;
  _lastRead       = 0;
  _rawTemperature = 0;
  _rawHumidity    = 0;
  _heatTimeout    = 0;
  _heaterStart    = 0;
  _heaterStop     = 0;
  _heaterOn       = false;
  _error          = SHT31_OK;
}


bool SHT31::begin()
{
  if ((_address != 0x44) && (_address != 0x45))
  {
    return false;
  }
  return reset();
}


bool SHT31::isConnected()
{
  _wire->beginTransmission(_address);
  int rv = _wire->endTransmission();
  if (rv != 0) _error = SHT31_ERR_NOT_CONNECT;
  return (rv == 0);
}


uint8_t SHT31::getAddress()
{
  return _address;
}


bool SHT31::read(bool fast)
{
  if (writeCmd(fast ? SHT31_MEASUREMENT_FAST : SHT31_MEASUREMENT_SLOW) == false)
  {
    return false;
  }
  delay(fast ? 4 : 15);   //  table 4 datasheet
  return readData(fast);
}


#ifdef doc
//  bit - description
//  ==================
//  15   Alert pending status
//        '0': no pending alerts
//        '1': at least one pending alert - default
//  14  Reserved ‘0’
//  13  Heater status
//        '0’ : Heater OFF - default
//        '1’ : Heater ON
//  12  Reserved '0’
//  11  Humidity tracking alert
//        '0’ : no alert - default
//        '1’ : alert
//  10  Temp tracking alert
//        '0’ : no alert - default
//        '1’ : alert
//  9:5 Reserved '00000’
//  4   System reset detected
//        '0': no reset since last ‘clear status register’ command
//        '1': reset detected (hard or soft reset command or supply fail) - default
//  3:2 Reserved ‘00’
//  1   Command status
//        '0': last command executed successfully
//        '1': last command not processed. Invalid or failed checksum
//  0   Write data checksum status
//        '0': checksum of last write correct
//        '1': checksum of last write transfer failed
#endif


uint16_t SHT31::readStatus()
{
  uint8_t status[3] = { 0, 0, 0 };
  //  page 13 datasheet
  if (writeCmd(SHT31_READ_STATUS) == false)
  {
    return 0xFFFF;
  }
  //  16 bit status + CRC
  if (readBytes(3, (uint8_t*) &status[0]) == false)
  {
    return 0xFFFF;
  }

  if (status[2] != crc8(status, 2))
  {
    _error = SHT31_ERR_CRC_STATUS;
    return 0xFFFF;
  }

  return (uint16_t) (status[0] << 8) + status[1];
}


bool SHT31::reset(bool hard)
{
  bool b = writeCmd(hard ? SHT31_HARD_RESET : SHT31_SOFT_RESET);
  if (b == false)
  {
    return false;
  }
  delay(1);   //  table 4 datasheet
  return true;
}


void SHT31::setHeatTimeout(uint8_t seconds)
{
  _heatTimeout = seconds;
  if (_heatTimeout > 180) _heatTimeout = 180;
}


bool SHT31::heatOn()
{
  if (isHeaterOn()) return true;
  if ((_heaterStop > 0) && (millis() - _heaterStop < SHT31_HEATER_TIMEOUT))
  {
    _error = SHT31_ERR_HEATER_COOLDOWN;
    return false;
  }
  if (writeCmd(SHT31_HEAT_ON) == false)
  {
    _error = SHT31_ERR_HEATER_ON;
    return false;
  }
  _heaterStart = millis();
  _heaterOn    = true;
  return true;
}


bool SHT31::heatOff()
{
  //  always switch off the heater - ignore _heaterOn flag.
  if (writeCmd(SHT31_HEAT_OFF) == false)
  {
    _error = SHT31_ERR_HEATER_OFF;  // can be serious!
    return false;
  }
  _heaterStop = millis();
  _heaterOn   = false;
  return true;
}


bool SHT31::isHeaterOn()
{
  if (_heaterOn == false)
  {
    return false;
  }
  //  did not exceed time out
  if (millis() - _heaterStart < (_heatTimeout * 1000UL))
  {
    return true;
  }
  heatOff();
  return false;
}


bool SHT31::requestData()
{
  if (writeCmd(SHT31_MEASUREMENT_SLOW) == false)
  {
    return false;
  }
  _lastRequest = millis();
  return true;
}


bool SHT31::dataReady()
{
  return ((millis() - _lastRequest) > 15);  //  TODO MAGIC NR
}


bool SHT31::readData(bool fast)
{
  uint8_t buffer[6];
  if (readBytes(6, (uint8_t*) &buffer[0]) == false)
  {
    return false;
  }

  if (!fast)
  {
    if (buffer[2] != crc8(buffer, 2))
    {
      _error = SHT31_ERR_CRC_TEMP;
      return false;
    }
    if (buffer[5] != crc8(buffer + 3, 2))
    {
      _error = SHT31_ERR_CRC_HUM;
      return false;
    }
  }

  _rawTemperature = (buffer[0] << 8) + buffer[1];
  _rawHumidity    = (buffer[3] << 8) + buffer[4];

  _lastRead = millis();

  return true;
}


int SHT31::getError()
{
  int rv = _error;
  _error = SHT31_OK;
  return rv;
}


//////////////////////////////////////////////////////////

uint8_t SHT31::crc8(const uint8_t *data, uint8_t len)
{
  //  CRC-8 formula from page 14 of SHT spec pdf
  const uint8_t POLY(0x31);
  uint8_t crc(0xFF);

  for (uint8_t j = len; j; --j)
  {
    crc ^= *data++;

    for (uint8_t i = 8; i; --i)
    {
      crc = (crc & 0x80) ? (crc << 1) ^ POLY : (crc << 1);
    }
  }
  return crc;
}


bool SHT31::writeCmd(uint16_t cmd)
{
  _wire->beginTransmission(_address);
  _wire->write(cmd >> 8 );
  _wire->write(cmd & 0xFF);
  if (_wire->endTransmission() != 0)
  {
    _error = SHT31_ERR_WRITECMD;
    return false;
  }
  return true;
}


bool SHT31::readBytes(uint8_t n, uint8_t *val)
{
  int rv = _wire->requestFrom(_address, (uint8_t) n);
  if (rv == n)
  {
    for (uint8_t i = 0; i < n; i++)
    {
      val[i] = _wire->read();
    }
    return true;
  }
  _error = SHT31_ERR_READBYTES;
  return false;
}


//  -- END OF FILE --

================
File: src/utilities.cpp
================
#include <Arduino.h>  // Agregar esta línea para definir la clase String
#include <cmath>     // Necesario para pow, round y fabs
#include "utilities.h"

// Función auxiliar para convertir un string tipo 
// "EE,F1,30,98,6A,11,4E,69,D0,DE,8A,DC,D6,8D,28,A6"
// en un array de 16 bytes
void parseKeyString(const String &keyStr, uint8_t *outArray, size_t expectedSize) {
    int index = 0;
    int start = 0;
    while (index < expectedSize && start < keyStr.length()) {
        int comma = keyStr.indexOf(',', start);
        String byteStr;
        if (comma == -1) {
            byteStr = keyStr.substring(start);
            start = keyStr.length();
        } else {
            byteStr = keyStr.substring(start, comma);
            start = comma + 1;
        }
        outArray[index] = (uint8_t)strtol(byteStr.c_str(), NULL, 16);
        index++;
    }
}

bool parseEUIString(const char* euiStr, uint64_t* eui) {
    char temp[3];
    uint8_t bytes[8];
    const char* ptr = euiStr;
    
    // Parsear 8 bytes
    for (int i = 0; i < 8; i++) {
        // Copiar dos caracteres hexadecimales
        strncpy(temp, ptr, 2);
        temp[2] = '\0';
        
        // Convertir string hex a byte
        bytes[i] = strtoul(temp, nullptr, 16);
        
        // Avanzar al siguiente par de caracteres, saltando la coma si existe
        ptr += (ptr[2] == ',') ? 3 : 2;
    }
    
    // Convertir los 8 bytes a uint64_t
    *eui = 0;
    for (int i = 0; i < 8; i++) {
        *eui = (*eui << 8) | bytes[i];
    }
    
    return true;
} 

/**
 * @brief Formatea un valor flotante con hasta 3 decimales, eliminando ceros finales.
 * @param value Valor flotante a formatear.
 * @param buffer Buffer donde se almacenará la cadena formateada.
 * @param bufferSize Tamaño del buffer.
 */
void formatFloatTo3Decimals(float value, char* buffer, size_t bufferSize) {
    // Primero formateamos con 3 decimales
    snprintf(buffer, bufferSize, "%.3f", value);
    
    // Luego eliminamos los ceros a la derecha y el punto si no hay decimales
    int len = strlen(buffer);
    int i = len - 1;
    
    // Retroceder mientras haya ceros al final
    while (i >= 0 && buffer[i] == '0') {
        i--;
    }
    
    // Si el último carácter es un punto, también lo eliminamos
    if (i >= 0 && buffer[i] == '.') {
        buffer[i] = '\0';
    } else {
        // Si no, terminamos la cadena después del último dígito no cero
        buffer[i + 1] = '\0';
    }
}

================
File: test/README
================
This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html

================
File: include/sensor_types.h
================
#ifndef SENSOR_TYPES_H
#define SENSOR_TYPES_H

#include <stdint.h>
#include <vector>
#include "config.h"
#include <map>

/************************************************************************
 * TIEMPOS DE ESTABILIZACIÓN PARA SENSORES MODBUS (en ms)
 ************************************************************************/
 
#define MODBUS_ENV4_STABILIZATION_TIME 5000   // Tiempo de estabilización para sensor ENV4 Modbus
// Añadir aquí otros tiempos de estabilización para sensores Modbus

/**
 * @brief Estructura para variables múltiples en un solo sensor.
 *        Por ejemplo, un sensor SHT30 que da Temperature y Humidity.
 */
struct SubValue {
    float value;     // El orden de los valores en el vector es importante
};

/************************************************************************
 * SECCIÓN PARA SENSORES ESTÁNDAR (NO MODBUS)
 ************************************************************************/

/**
 * @brief Enumeración de tipos de sensores disponibles.
 */
enum SensorType {
    // Sensores estándar (no-Modbus)
    N100K,    // NTC 100K
    N10K,     // NTC 10K
    HDS10,    // Condensation Humidity
    RTD,      // RTD
    DS18B20,  // DS18B20
    PH,       // pH
    COND,     // Conductividad
    CONDH,    // Humedad de Condensación
    SOILH,    // Soil Humidity
    TEMP_A,   // Temperatura ambiente
    HUM_A,    // Humedad ambiente
    PRESS_A,  // Presión atmosférica
    VEML7700, // Sensor de luz VEML7700 (Lux)
    ROOTH,    // Humedad de Raíz
    LEAFH,    // Humedad de Hoja
    
    // Sensores múltiples (valor 100 en el mapa)
    SHT30 = 100,  // Sensor SHT30: [0]=Temperatura(°C), [1]=Humedad(%)
    BME680 = 101, // Sensor BME680: [0]=Temp(°C), [1]=Hum(%), [2]=Press(hPa), [3]=Gas(KOhms)
    CO2 = 102,    // Sensor CO2 SCD4x: [0]=CO2(ppm), [1]=Temp(°C), [2]=Hum(%)
    BME280 = 103, // Sensor BME280: [0]=Temp(°C), [1]=Hum(%), [2]=Press(hPa)
    SHT4X = 104,  // Sensor SHT4x: [0]=Temperatura(°C), [1]=Humedad(%)
    
    // Sensores Modbus
    ENV4 = 110,   // Sensor ambiental 4 en 1: [0]=Humedad(%), [1]=Temperatura(°C), [2]=Presión(kPa), [3]=Iluminación(lux)
    // Aquí se pueden agregar más tipos de sensores Modbus
};

/**
 * @brief Estructura básica para almacenar una lectura de sensor.
 *        Para sensores con múltiples variables, se utilizará 'subValues'.
 */
struct SensorReading {
    char sensorId[20];         // Identificador del sensor (ej. "SHT30_1")
    SensorType type;           // Tipo de sensor
    float value;               // Valor único (si aplica)
    std::vector<SubValue> subValues; // Subvalores, si el sensor genera varias mediciones
};

/**
 * @brief Estructura de configuración para sensores "normales" (no Modbus).
 */
struct SensorConfig {
    char configKey[20];
    char sensorId[20];
    SensorType type;
    bool enable;
};

/************************************************************************
 * SECCIÓN PARA SENSORES MODBUS
 ************************************************************************/

/**
 * @brief Estructura de configuración para sensores Modbus.
 */
struct ModbusSensorConfig {
    char sensorId[20];         // Identificador del sensor
    SensorType type;           // Tipo de sensor Modbus
    uint8_t address;           // Dirección Modbus del dispositivo
    bool enable;               // Si está habilitado o no
};

/**
 * @brief Estructura para almacenar la lectura completa de un sensor Modbus.
 */
struct ModbusSensorReading {
    char sensorId[20];         // Identificador del sensor
    SensorType type;           // Tipo de sensor Modbus
    std::vector<SubValue> subValues; // Subvalores reportados por el sensor
};

#endif // SENSOR_TYPES_H

================
File: include/sensors/BatterySensor.h
================
#ifndef BATTERY_SENSOR_H
#define BATTERY_SENSOR_H

#include <Arduino.h>
#include "config.h"
#include "debug.h"

/**
 * @brief Clase para manejar la lectura del voltaje de la batería
 */
class BatterySensor {
public:
    /**
     * @brief Lee el voltaje de la batería
     * 
     * Activa el pin de control BATTERY_CONTROL_PIN para habilitar
     * la medición a través del divisor de voltaje y luego lo desactiva
     * para ahorrar energía.
     * 
     * @return float Voltaje de la batería en voltios, o NAN si hay error
     */
    static float readVoltage();

private:
    /**
     * @brief Calcula el voltaje real de la batería a partir de la lectura del ADC
     * 
     * El circuito es un divisor de voltaje:
     * 
     * Batería (+) ---- R2 (390k) ---- | ---- R1 (100k) ---- GND
     *                                 |
     *                                 +--- ADC Pin
     * 
     * La fórmula es:
     * VBAT = VADC_IN1 / (R1 / (R1 + R2))
     * 
     * @param adcVoltage Voltaje medido por el ADC
     * @return float Voltaje real de la batería
     */
    static float calculateBatteryVoltage(float adcVoltage);
};

#endif // BATTERY_SENSOR_H

================
File: include/SleepManager.h
================
/*******************************************************************************************
 * Archivo: include/SleepManager.h
 * Descripción: Gestión del modo deep sleep para el ESP32.
 * Incluye funciones para configurar y entrar en modo de bajo consumo.
 *******************************************************************************************/

#ifndef SLEEP_MANAGER_H
#define SLEEP_MANAGER_H

#include <Arduino.h>
#include "esp_sleep.h"
#include "driver/gpio.h"
#include "PowerManager.h"
#include "config.h"
#include <RadioLib.h>
#include <SPI.h>
#include <Wire.h>

class SleepManager {
public:
    /**
     * @brief Configura y entra en modo deep sleep.
     * @param timeToSleep Tiempo en segundos para permanecer en deep sleep
     * @param powerManager Referencia al gestor de energía
     * @param radio Puntero al módulo de radio LoRa
     * @param node Referencia al nodo LoRaWAN para guardar sesión
     * @param LWsession Buffer para almacenar la sesión LoRaWAN
     * @param spiLora Referencia al objeto SPI para LoRa
     */
    static void goToDeepSleep(uint32_t timeToSleep, 
                             PowerManager& powerManager,
                             SX1262* radio,
                             LoRaWANNode& node,
                             uint8_t* LWsession,
                             SPIClass& spiLora);
    
    /**
     * @brief Configura los pines no utilizados en alta impedancia para reducir el consumo durante deep sleep.
     */
    static void configurePinsForDeepSleep();

    /**
     * @brief Libera el estado de retención (hold) de los pines que fueron configurados para deep sleep.
     * Esto permite que los pines puedan ser reconfigurados adecuadamente tras salir del deep sleep.
     */
    static void releaseHeldPins();
};

#endif // SLEEP_MANAGER_H

================
File: src/BLE.cpp
================
/*******************************************************************************************
 * Archivo: src/BLE.cpp
 * Descripción: Implementación unificada de la gestión BLE para el ESP32.
 *******************************************************************************************/

#include "BLE.h"
#include "config.h" // Asegúrate de incluir config.h para CONFIG_PIN y CONFIG_TRIGGER_TIME
#include "debug.h"  // Para los mensajes DEBUG_*

// Inicialización de variables estáticas
bool BLEHandler::isConnected = false;
unsigned long BLEHandler::connectionStartTime = 0;
BLEServer* BLEHandler::pBLEServer = nullptr;
bool BLEHandler::shouldExitOnDisconnect = false;

// --- INICIO: Declarar variable global externa ---
extern bool wokeFromConfigPin;
// --- FIN: Declarar variable global externa ---

// Implementación de los métodos de la clase ServerCallbacks
void BLEHandler::ServerCallbacks::onConnect(BLEServer* pServer) {
    BLEHandler::isConnected = true;
    BLEHandler::connectionStartTime = millis();
    BLEHandler::shouldExitOnDisconnect = true; // Establecer que debemos salir al desconectar
}

void BLEHandler::ServerCallbacks::onDisconnect(BLEServer* pServer) {
    BLEHandler::isConnected = false;
    pServer->getAdvertising()->start();
    // No reiniciamos shouldExitOnDisconnect aquí, eso lo manejamos en runConfigLoop
}

// Implementación de los métodos de BLEHandler
bool BLEHandler::checkConfigMode() {
    bool enterConfig = false;
    int initialPinState = digitalRead(CONFIG_PIN);

    // Entrar en modo config si:
    // 1. Despertamos por el pin Y el pin SIGUE bajo ahora
    // 2. O si el pin está bajo AHORA (independientemente de cómo despertamos)
    if (initialPinState == LOW) {
        unsigned long startTime = millis();

        // Pequeño delay para debounce básico - crucial para pulsadores mecánicos
        delay(50);

        // Verificar si sigue presionado después del debounce
        if (digitalRead(CONFIG_PIN) == LOW) {
            while (digitalRead(CONFIG_PIN) == LOW) {
                if (millis() - startTime >= CONFIG_TRIGGER_TIME) {
                    DEBUG_PRINTLN("INFO: Entrando en modo configuración BLE");
                    enterConfig = true;
                    break; // Salir del while
                }
                delay(10); // Pequeña pausa para no saturar
            }
        }
    }

    // Si decidimos entrar en modo config
    if (enterConfig) {
        // Reiniciar variables de estado BLE
        isConnected = false;
        shouldExitOnDisconnect = false;

        // Obtener configuración LoRa para el nombre BLE
        LoRaConfig loraConfig = ConfigManager::getLoRaConfig();
        String bleName = BLE_DEVICE_PREFIX + String(loraConfig.devEUI);

        // Inicializar BLE
        BLEDevice::init(bleName.c_str());
        pBLEServer = BLEDevice::createServer();
        pBLEServer->setCallbacks(new ServerCallbacks());

        // Configurar servicio BLE
        BLEService* pService = setupService(pBLEServer);

        // Configurar publicidad BLE
        BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
        pAdvertising->addServiceUUID(pService->getUUID());
        pAdvertising->setScanResponse(true);
        pAdvertising->setMinPreferred(0x06);
        pAdvertising->setMinPreferred(0x12);
        pAdvertising->start();

        // Entrar en bucle de configuración
        runConfigLoop();
        DEBUG_PRINTLN("INFO: Saliendo del modo configuración BLE");
        
        wokeFromConfigPin = false; // Importante: Resetear el flag después de usarlo
        return true; // Indicar que entramos (y salimos) del modo config
    }

    // Si no entramos en modo config, reseteamos el flag por si acaso estaba activo
    wokeFromConfigPin = false;
    return false; // No se entró en modo config
}

BLEServer* BLEHandler::initBLE(const String& devEUI) {
    String bleName = BLE_DEVICE_PREFIX + devEUI;
    BLEDevice::init(bleName.c_str());
    BLEServer* pServer = BLEDevice::createServer();
    pServer->setCallbacks(new ServerCallbacks());
    return pServer;
}

void BLEHandler::runConfigLoop() {
    unsigned long startTime = millis();
    const unsigned long timeout = CONFIG_BLE_WAIT_TIMEOUT; // Usar constante de config.h

    while (true) {
        // Verificar si debemos salir por desconexión de cliente
        if (shouldExitOnDisconnect && !isConnected) {
            BLEDevice::getAdvertising()->stop();
            shouldExitOnDisconnect = false; // Resetear la bandera
            break;
        }
        
        // Timeout para esperar conexión
        if (millis() - startTime >= timeout && !BLEHandler::isConnected) {
            BLEDevice::getAdvertising()->stop();
            break;
        }
        
        // Timeout para conexión activa
        if (BLEHandler::isConnected && (millis() - BLEHandler::connectionStartTime >= BLEHandler::connectionTimeout)) {
            if (pBLEServer) {
                pBLEServer->disconnect(0); // Desconectar todos los clientes
                BLEHandler::isConnected = false;
                BLEDevice::getAdvertising()->start();
            }
        }
        
        // Control del LED según estado de conexión
        if (BLEHandler::isConnected) {
            // Cliente conectado, LED fijo
            digitalWrite(CONFIG_LED_PIN, HIGH);
            delay(1000);
        } else {
            // Esperando conexión, LED parpadeando
            digitalWrite(CONFIG_LED_PIN, HIGH);
            delay(250);
            digitalWrite(CONFIG_LED_PIN, LOW);
            delay(250);
        }
    }
}

// Implementación de la configuración del servicio BLE
BLEService* BLEHandler::setupService(BLEServer* pServer) {
    // Crear el servicio de configuración utilizando el UUID definido
    BLEService* pService = pServer->createService(BLEUUID(BLE_SERVICE_UUID));

    // Característica del sistema - común para todos los tipos de dispositivo
    BLECharacteristic* pSystemChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_SYSTEM_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pSystemChar->setCallbacks(new SystemConfigCallback());

    // Para dispositivo analógico, se utilizan todas las callbacks
    
    // Característica para configuración NTC 100K
    BLECharacteristic* pNTC100KChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_NTC100K_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pNTC100KChar->setCallbacks(new NTC100KConfigCallback());
    
    // Característica para configuración NTC 10K
    BLECharacteristic* pNTC10KChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_NTC10K_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pNTC10KChar->setCallbacks(new NTC10KConfigCallback());
    
    // Característica para configuración de Conductividad
    BLECharacteristic* pCondChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_CONDUCTIVITY_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pCondChar->setCallbacks(new ConductivityConfigCallback());
    
    // Característica para configuración de pH
    BLECharacteristic* pPHChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_PH_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pPHChar->setCallbacks(new PHConfigCallback());

    // Característica para configuración de Sensores
    BLECharacteristic* pSensorsChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_SENSORS_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pSensorsChar->setCallbacks(new SensorsConfigCallback());
    
    // Característica para configuración de LoRa - común para todos los tipos
    BLECharacteristic* pLoRaConfigChar = pService->createCharacteristic(
        BLEUUID(BLE_CHAR_LORA_CONFIG_UUID),
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    pLoRaConfigChar->setCallbacks(new LoRaConfigCallback());
    
    pService->start();
    return pService;
}

// Implementación de SystemConfigCallback
void BLEHandler::SystemConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: SystemConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON de la forma: { "system": { "initialized": <bool>, "sleep_time": <valor>, "device_id": "<valor>" } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> doc;
    DeserializationError error = deserializeJson(doc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando System config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject obj = doc[NAMESPACE_SYSTEM];
    bool initialized = obj[KEY_INITIALIZED] | false;
    uint32_t sleepTime = obj[KEY_SLEEP_TIME] | DEFAULT_TIME_TO_SLEEP;
    String deviceId = obj[KEY_DEVICE_ID] | "";
    String stationId = obj[KEY_STATION_ID] | "";
    
    DEBUG_PRINT(F("DEBUG: Configuración de sistema parseada: initialized="));
    DEBUG_PRINT(initialized);
    DEBUG_PRINT(F(", sleepTime="));
    DEBUG_PRINT(sleepTime);
    DEBUG_PRINT(F(", deviceId="));
    DEBUG_PRINT(deviceId);
    DEBUG_PRINT(F(", stationId="));
    DEBUG_PRINTLN(stationId);
    
    ConfigManager::setSystemConfig(initialized, sleepTime, deviceId, stationId);
}

void BLEHandler::SystemConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    bool initialized;
    uint32_t sleepTime;
    String deviceId;
    String stationId;
    ConfigManager::getSystemConfig(initialized, sleepTime, deviceId, stationId);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> doc;
    JsonObject obj = doc.createNestedObject(NAMESPACE_SYSTEM);
    obj[KEY_INITIALIZED] = initialized;
    obj[KEY_SLEEP_TIME] = sleepTime;
    obj[KEY_DEVICE_ID] = deviceId;
    obj[KEY_STATION_ID] = stationId;

    String jsonString;
    serializeJson(doc, jsonString);
    DEBUG_PRINT(F("DEBUG: SystemConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de NTC100KConfigCallback
void BLEHandler::NTC100KConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: NTC100KConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());

    // Se espera un JSON de la forma: { "ntc_100k": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando NTC100K config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_NTC100K];
    DEBUG_PRINT(F("DEBUG: NTC100K valores parseados - T1: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T1] | 0.0);
    DEBUG_PRINT(F(", R1: "));
    DEBUG_PRINT(doc[KEY_NTC100K_R1] | 0.0);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T2] | 0.0);
    DEBUG_PRINT(F(", R2: "));
    DEBUG_PRINT(doc[KEY_NTC100K_R2] | 0.0);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_NTC100K_T3] | 0.0);
    DEBUG_PRINT(F(", R3: "));
    DEBUG_PRINTLN(doc[KEY_NTC100K_R3] | 0.0);
    
    ConfigManager::setNTC100KConfig(
        doc[KEY_NTC100K_T1] | 0.0,
        doc[KEY_NTC100K_R1] | 0.0,
        doc[KEY_NTC100K_T2] | 0.0,
        doc[KEY_NTC100K_R2] | 0.0,
        doc[KEY_NTC100K_T3] | 0.0,
        doc[KEY_NTC100K_R3] | 0.0
    );
}

void BLEHandler::NTC100KConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    double t1, r1, t2, r2, t3, r3;
    ConfigManager::getNTC100KConfig(t1, r1, t2, r2, t3, r3);
    
    DEBUG_PRINT(F("DEBUG: NTC100KConfigCallback onRead - Config: T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", R1="));
    DEBUG_PRINT(r1);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", R2="));
    DEBUG_PRINT(r2);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", R3="));
    DEBUG_PRINTLN(r3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    // Crear objeto anidado con el namespace "ntc_100k"
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_NTC100K);
    doc[KEY_NTC100K_T1] = t1;
    doc[KEY_NTC100K_R1] = r1;
    doc[KEY_NTC100K_T2] = t2;
    doc[KEY_NTC100K_R2] = r2;
    doc[KEY_NTC100K_T3] = t3;
    doc[KEY_NTC100K_R3] = r3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: NTC100KConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de NTC10KConfigCallback
void BLEHandler::NTC10KConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: NTC10KConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "ntc_10k": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando NTC10K config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_NTC10K];
    DEBUG_PRINT(F("DEBUG: NTC10K valores parseados - T1: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T1] | 0.0);
    DEBUG_PRINT(F(", R1: "));
    DEBUG_PRINT(doc[KEY_NTC10K_R1] | 0.0);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T2] | 0.0);
    DEBUG_PRINT(F(", R2: "));
    DEBUG_PRINT(doc[KEY_NTC10K_R2] | 0.0);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_NTC10K_T3] | 0.0);
    DEBUG_PRINT(F(", R3: "));
    DEBUG_PRINTLN(doc[KEY_NTC10K_R3] | 0.0);
    
    ConfigManager::setNTC10KConfig(
        doc[KEY_NTC10K_T1] | 0.0,
        doc[KEY_NTC10K_R1] | 0.0,
        doc[KEY_NTC10K_T2] | 0.0,
        doc[KEY_NTC10K_R2] | 0.0,
        doc[KEY_NTC10K_T3] | 0.0,
        doc[KEY_NTC10K_R3] | 0.0
    );
}

void BLEHandler::NTC10KConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    double t1, r1, t2, r2, t3, r3;
    ConfigManager::getNTC10KConfig(t1, r1, t2, r2, t3, r3);
    
    DEBUG_PRINT(F("DEBUG: NTC10KConfigCallback onRead - Config: T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", R1="));
    DEBUG_PRINT(r1);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", R2="));
    DEBUG_PRINT(r2);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", R3="));
    DEBUG_PRINTLN(r3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_NTC10K);
    doc[KEY_NTC10K_T1] = t1;
    doc[KEY_NTC10K_R1] = r1;
    doc[KEY_NTC10K_T2] = t2;
    doc[KEY_NTC10K_R2] = r2;
    doc[KEY_NTC10K_T3] = t3;
    doc[KEY_NTC10K_R3] = r3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: NTC10KConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de ConductivityConfigCallback
void BLEHandler::ConductivityConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: ConductivityConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON: { "cond": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando Conductivity config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_COND];
    
    DEBUG_PRINT(F("DEBUG: Conductivity valores parseados - CT: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_CT] | 0.0f);
    DEBUG_PRINT(F(", CC: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_CC] | 0.0f);
    DEBUG_PRINT(F(", V1: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V1] | 0.0f);
    DEBUG_PRINT(F(", T1: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_T1] | 0.0f);
    DEBUG_PRINT(F(", V2: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V2] | 0.0f);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_T2] | 0.0f);
    DEBUG_PRINT(F(", V3: "));
    DEBUG_PRINT(doc[KEY_CONDUCT_V3] | 0.0f);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINTLN(doc[KEY_CONDUCT_T3] | 0.0f);
    
    ConfigManager::setConductivityConfig(
        doc[KEY_CONDUCT_CT] | 0.0f,  // Temperatura de calibración
        doc[KEY_CONDUCT_CC] | 0.0f,  // Coeficiente de compensación
        doc[KEY_CONDUCT_V1] | 0.0f,
        doc[KEY_CONDUCT_T1] | 0.0f,
        doc[KEY_CONDUCT_V2] | 0.0f,
        doc[KEY_CONDUCT_T2] | 0.0f,
        doc[KEY_CONDUCT_V3] | 0.0f,
        doc[KEY_CONDUCT_T3] | 0.0f
    );
}

void BLEHandler::ConductivityConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    float calTemp, coefComp, v1, t1, v2, t2, v3, t3;
    ConfigManager::getConductivityConfig(calTemp, coefComp, v1, t1, v2, t2, v3, t3);
    
    DEBUG_PRINT(F("DEBUG: ConductivityConfigCallback onRead - Config: CT="));
    DEBUG_PRINT(calTemp);
    DEBUG_PRINT(F(", CC="));
    DEBUG_PRINT(coefComp);
    DEBUG_PRINT(F(", V1="));
    DEBUG_PRINT(v1);
    DEBUG_PRINT(F(", T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", V2="));
    DEBUG_PRINT(v2);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", V3="));
    DEBUG_PRINT(v3);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINTLN(t3);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_COND);
    doc[KEY_CONDUCT_CT] = calTemp;
    doc[KEY_CONDUCT_CC] = coefComp;
    doc[KEY_CONDUCT_V1] = v1;
    doc[KEY_CONDUCT_T1] = t1;
    doc[KEY_CONDUCT_V2] = v2;
    doc[KEY_CONDUCT_T2] = t2;
    doc[KEY_CONDUCT_V3] = v3;
    doc[KEY_CONDUCT_T3] = t3;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: ConductivityConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de PHConfigCallback
void BLEHandler::PHConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: PHConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "ph": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando pH config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_PH];
    DEBUG_PRINT(F("DEBUG: pH valores parseados - V1: "));
    DEBUG_PRINT(doc[KEY_PH_V1] | 0.0f);
    DEBUG_PRINT(F(", T1: "));
    DEBUG_PRINT(doc[KEY_PH_T1] | 0.0f);
    DEBUG_PRINT(F(", V2: "));
    DEBUG_PRINT(doc[KEY_PH_V2] | 0.0f);
    DEBUG_PRINT(F(", T2: "));
    DEBUG_PRINT(doc[KEY_PH_T2] | 0.0f);
    DEBUG_PRINT(F(", V3: "));
    DEBUG_PRINT(doc[KEY_PH_V3] | 0.0f);
    DEBUG_PRINT(F(", T3: "));
    DEBUG_PRINT(doc[KEY_PH_T3] | 0.0f);
    DEBUG_PRINT(F(", CT: "));
    DEBUG_PRINTLN(doc[KEY_PH_CT] | 25.0f);
    
    ConfigManager::setPHConfig(
        doc[KEY_PH_V1] | 0.0f,
        doc[KEY_PH_T1] | 0.0f,
        doc[KEY_PH_V2] | 0.0f,
        doc[KEY_PH_T2] | 0.0f,
        doc[KEY_PH_V3] | 0.0f,
        doc[KEY_PH_T3] | 0.0f,
        doc[KEY_PH_CT] | 25.0f
    );
}

void BLEHandler::PHConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    float v1, t1, v2, t2, v3, t3, calTemp;
    ConfigManager::getPHConfig(v1, t1, v2, t2, v3, t3, calTemp);
    
    DEBUG_PRINT(F("DEBUG: PHConfigCallback onRead - Config: V1="));
    DEBUG_PRINT(v1);
    DEBUG_PRINT(F(", T1="));
    DEBUG_PRINT(t1);
    DEBUG_PRINT(F(", V2="));
    DEBUG_PRINT(v2);
    DEBUG_PRINT(F(", T2="));
    DEBUG_PRINT(t2);
    DEBUG_PRINT(F(", V3="));
    DEBUG_PRINT(v3);
    DEBUG_PRINT(F(", T3="));
    DEBUG_PRINT(t3);
    DEBUG_PRINT(F(", CT="));
    DEBUG_PRINTLN(calTemp);
    
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_PH);
    doc[KEY_PH_V1] = v1;
    doc[KEY_PH_T1] = t1;
    doc[KEY_PH_V2] = v2;
    doc[KEY_PH_T2] = t2;
    doc[KEY_PH_V3] = v3;
    doc[KEY_PH_T3] = t3;
    doc[KEY_PH_CT] = calTemp;
    
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: PHConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de SensorsConfigCallback
void BLEHandler::SensorsConfigCallback::onWrite(BLECharacteristic *pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: SensorsConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera un JSON: { "sensors": [ {<sensor1>}, {<sensor2>}, ... ] }
    DynamicJsonDocument doc(JSON_DOC_SIZE_LARGE);
    DeserializationError error = deserializeJson(doc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando Sensors config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    
    std::vector<SensorConfig> configs;
    JsonArray sensorArray = doc[NAMESPACE_SENSORS];
    
    for (JsonVariant sensor : sensorArray) {
        SensorConfig config;
        strncpy(config.configKey, sensor[KEY_SENSOR] | "", sizeof(config.configKey));
        strncpy(config.sensorId, sensor[KEY_SENSOR_ID] | "", sizeof(config.sensorId));
        config.type = static_cast<SensorType>(sensor[KEY_SENSOR_TYPE] | 0);
        config.enable = sensor[KEY_SENSOR_ENABLE] | false;
        
        DEBUG_PRINT(F("DEBUG: Sensor config parsed - key: "));
        DEBUG_PRINT(config.configKey);
        DEBUG_PRINT(F(", sensorId: "));
        DEBUG_PRINT(config.sensorId);
        DEBUG_PRINT(F(", type: "));
        DEBUG_PRINT(static_cast<int>(config.type));
        DEBUG_PRINT(F(", enable: "));
        DEBUG_PRINTLN(config.enable ? "true" : "false");
        
        configs.push_back(config);
    }
    
    ConfigManager::setSensorsConfigs(configs);
}

void BLEHandler::SensorsConfigCallback::onRead(BLECharacteristic *pCharacteristic) {
    DynamicJsonDocument doc(JSON_DOC_SIZE_LARGE);
    JsonArray sensorArray = doc.createNestedArray(NAMESPACE_SENSORS);

    std::vector<SensorConfig> configs = ConfigManager::getAllSensorConfigs();
    
    DEBUG_PRINTLN(F("DEBUG: SensorsConfigCallback onRead - Configuraciones de sensores obtenidas:"));
    for (const auto& sensor : configs) {
        DEBUG_PRINT(F("DEBUG: Sensor config - key: "));
        DEBUG_PRINT(sensor.configKey);
        DEBUG_PRINT(F(", sensorId: "));
        DEBUG_PRINT(sensor.sensorId);
        DEBUG_PRINT(F(", type: "));
        DEBUG_PRINT(static_cast<int>(sensor.type));
        DEBUG_PRINT(F(", enable: "));
        DEBUG_PRINTLN(sensor.enable ? "true" : "false");

        JsonObject obj = sensorArray.createNestedObject();
        obj[KEY_SENSOR]             = sensor.configKey;
        obj[KEY_SENSOR_ID]          = sensor.sensorId;
        obj[KEY_SENSOR_TYPE]        = static_cast<int>(sensor.type);
        obj[KEY_SENSOR_ENABLE]      = sensor.enable;
    }

    String jsonString;
    serializeJson(doc, jsonString);
    DEBUG_PRINT(F("DEBUG: SensorsConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

// Implementación de LoRaConfigCallback
void BLEHandler::LoRaConfigCallback::onWrite(BLECharacteristic* pCharacteristic) {
    DEBUG_PRINTLN(F("DEBUG: LoRaConfigCallback onWrite - JSON recibido:"));
    DEBUG_PRINTLN(pCharacteristic->getValue().c_str());
    
    // Se espera JSON: { "lorawan": { <parámetros> } }
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    DeserializationError error = deserializeJson(fullDoc, pCharacteristic->getValue());
    if (error) {
        DEBUG_PRINT(F("Error deserializando LoRa config: "));
        DEBUG_PRINTLN(error.c_str());
        return;
    }
    JsonObject doc = fullDoc[NAMESPACE_LORAWAN];
    String joinEUI     = doc[KEY_LORA_JOIN_EUI]      | "";
    String devEUI     = doc[KEY_LORA_DEV_EUI]      | "";
    String nwkKey     = doc[KEY_LORA_NWK_KEY]      | "";
    String appKey     = doc[KEY_LORA_APP_KEY]      | "";
    
    DEBUG_PRINT(F("DEBUG: LoRa valores parseados - joinEUI: "));
    DEBUG_PRINT(joinEUI);
    DEBUG_PRINT(F(", devEUI: "));
    DEBUG_PRINT(devEUI);
    DEBUG_PRINT(F(", nwkKey: "));
    DEBUG_PRINT(nwkKey);
    DEBUG_PRINT(F(", appKey: "));
    DEBUG_PRINTLN(appKey);
    
    ConfigManager::setLoRaConfig(joinEUI, devEUI, nwkKey, appKey);
}

void BLEHandler::LoRaConfigCallback::onRead(BLECharacteristic* pCharacteristic) {
    LoRaConfig config = ConfigManager::getLoRaConfig();
    
    DEBUG_PRINTLN(F("DEBUG: LoRaConfigCallback onRead - Config obtenido:"));
    DEBUG_PRINT(F("joinEUI: "));
    DEBUG_PRINTLN(config.joinEUI);
    DEBUG_PRINT(F("devEUI: "));
    DEBUG_PRINTLN(config.devEUI);
    DEBUG_PRINT(F("nwkKey: "));
    DEBUG_PRINTLN(config.nwkKey);
    
    // Aumentamos el tamaño del documento para asegurarnos de incluir todas las claves
    StaticJsonDocument<JSON_DOC_SIZE_SMALL> fullDoc;
    JsonObject doc = fullDoc.createNestedObject(NAMESPACE_LORAWAN);
    doc[KEY_LORA_JOIN_EUI]     = config.joinEUI;
    doc[KEY_LORA_DEV_EUI]     = config.devEUI;
    doc[KEY_LORA_NWK_KEY]     = config.nwkKey;
    doc[KEY_LORA_APP_KEY]     = config.appKey;
    String jsonString;
    serializeJson(fullDoc, jsonString);
    DEBUG_PRINT(F("DEBUG: LoRaConfigCallback onRead - JSON enviado: "));
    DEBUG_PRINTLN(jsonString);
    pCharacteristic->setValue(jsonString.c_str());
}

================
File: src/LoRaManager.cpp
================
/*******************************************************************************************
 * Archivo: src/LoRaManager.cpp
 * Descripción: Implementación de la gestión de comunicaciones LoRa y LoRaWAN.
 *              Se ha modificado la forma de serializar los valores float a 3 decimales
 *              usando snprintf("%.3f", ...) antes de asignarlos al JSON.
 *******************************************************************************************/

#include "LoRaManager.h"
#include <Preferences.h>
#include "debug.h"
#include <RadioLib.h>
#include <ESP32Time.h>
#include "utilities.h"  // Incluido para acceder a formatFloatTo3Decimals
#include "config.h"     // Incluido para acceder a MAX_PAYLOAD
#include "sensor_types.h"  // Incluido para acceder a ModbusSensorReading
#include "config_manager.h"
#include "sensors/BatterySensor.h"

// Inicialización de variables estáticas
LoRaWANNode* LoRaManager::node = nullptr;
SX1262* LoRaManager::radioModule = nullptr;

// Referencias externas
extern RTC_DATA_ATTR uint8_t LWsession[RADIOLIB_LORAWAN_SESSION_BUF_SIZE];
extern ESP32Time rtc;

int16_t LoRaManager::begin(SX1262* radio, const LoRaWANBand_t* region, uint8_t subBand) {
    radioModule = radio;
    int16_t state = radioModule->begin();
    if (state != RADIOLIB_ERR_NONE) {
        return state;
    }
    
    // Crear el nodo LoRaWAN
    node = new LoRaWANNode(radio, region, subBand);
    return RADIOLIB_ERR_NONE;
}

int16_t LoRaManager::lwActivate(LoRaWANNode& node) {
    int16_t state = RADIOLIB_ERR_UNKNOWN;
    Preferences store;
    
    // Obtener configuración LoRa
    LoRaConfig loraConfig = ConfigManager::getLoRaConfig();
    
    // Convertir strings de EUIs a uint64_t
    uint64_t joinEUI = 0, devEUI = 0;
    if (!parseEUIString(loraConfig.joinEUI.c_str(), &joinEUI) ||
        !parseEUIString(loraConfig.devEUI.c_str(), &devEUI)) {
        return state;
    }
    
    // Parsear las claves
    uint8_t nwkKey[16], appKey[16];
    parseKeyString(loraConfig.nwkKey, nwkKey, 16);
    parseKeyString(loraConfig.appKey, appKey, 16);

    // Configurar la sesión OTAA
    node.beginOTAA(joinEUI, devEUI, nwkKey, appKey);

    store.begin("radiolib");

    // Intentar restaurar nonces si existen
    if (store.isKey("nonces")) {
        uint8_t buffer[RADIOLIB_LORAWAN_NONCES_BUF_SIZE];
        store.getBytes("nonces", buffer, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
        state = node.setBufferNonces(buffer);
        
        if (state == RADIOLIB_ERR_NONE) {
            // Intentar restaurar sesión desde RTC
            state = node.setBufferSession(LWsession);
            
            if (state == RADIOLIB_ERR_NONE) {
                state = node.activateOTAA();
                
                if (state == RADIOLIB_LORAWAN_SESSION_RESTORED) {
                    store.end();
                    DEBUG_PRINTLN("Sesión LoRaWAN restaurada");
                    return state;
                }
            }
        }
    } else {
        DEBUG_PRINTLN("No hay nonces guardados - iniciando nuevo join");
    }

    // Si llegamos aquí, necesitamos hacer un nuevo join
    state = RADIOLIB_ERR_NETWORK_NOT_JOINED;
    while (state != RADIOLIB_LORAWAN_NEW_SESSION) {
        state = node.activateOTAA();

        // Guardar nonces en flash si el join fue exitoso
        if (state == RADIOLIB_LORAWAN_NEW_SESSION) {
            uint8_t buffer[RADIOLIB_LORAWAN_NONCES_BUF_SIZE];
            uint8_t *persist = node.getBufferNonces();
            memcpy(buffer, persist, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
            store.putBytes("nonces", buffer, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);

            // Solicitar DeviceTime después de un join exitoso
            delay(1000); // Pausa para estabilización
            node.setDatarate(3);
            
            // Variable para controlar el número de intentos
            int rtcAttempts = 0;
            bool rtcUpdated = false;
            const int maxAttempts = 3; // Máximo número de intentos para actualizar RTC
            
            // Intentar solicitar y actualizar el tiempo del RTC hasta 3 veces
            while (!rtcUpdated && rtcAttempts < maxAttempts) {
                rtcAttempts++;
                
                bool macCommandSuccess = node.sendMacCommandReq(RADIOLIB_LORAWAN_MAC_DEVICE_TIME);
                if (macCommandSuccess) {
                    // Enviar mensaje vacío
                    uint8_t fPort = 1;
                    uint8_t downlinkPayload[255];
                    size_t downlinkSize = 0;
                    
                    int16_t rxState = node.sendReceive(nullptr, 0, fPort, downlinkPayload, &downlinkSize, true);
                    if (rxState == RADIOLIB_ERR_NONE) {
                        // Obtener y procesar DeviceTime
                        uint32_t unixEpoch;
                        uint8_t fraction;
                        int16_t dtState = node.getMacDeviceTimeAns(&unixEpoch, &fraction, true);
                        if (dtState == RADIOLIB_ERR_NONE) {
                            DEBUG_PRINTF("DeviceTime recibido: epoch = %lu s, fraction = %u\n", unixEpoch, fraction);
                            
                            // Configurar el RTC interno con el tiempo Unix
                            rtc.setTime(unixEpoch);
                            
                            // Verificar si se ajustó correctamente
                            if (abs((int32_t)rtc.getEpoch() - (int32_t)unixEpoch) < 10) {
                                DEBUG_PRINTLN("RTC actualizado exitosamente con tiempo del servidor");
                                rtcUpdated = true; // Marca como actualizado para salir del bucle
                            } else {
                                DEBUG_PRINTLN("Error al actualizar RTC con tiempo del servidor");
                                // Si estamos en el último intento, continuamos de todas formas
                                if (rtcAttempts >= maxAttempts) {
                                    DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                                } else {
                                    delay(1000); // Esperar un segundo antes del siguiente intento
                                }
                            }
                        } else {
                            DEBUG_PRINTF("Error al obtener DeviceTime: %d\n", dtState);
                            // Si estamos en el último intento, continuamos de todas formas
                            if (rtcAttempts >= maxAttempts) {
                                DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                            } else {
                                delay(1000); // Esperar un segundo antes del siguiente intento
                            }
                        }
                    } else {
                        DEBUG_PRINTF("Error al recibir respuesta DeviceTime: %d\n", rxState);
                        // Si estamos en el último intento, continuamos de todas formas
                        if (rtcAttempts >= maxAttempts) {
                            DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                        } else {
                            delay(1000); // Esperar un segundo antes del siguiente intento
                        }
                    }
                } else {
                    DEBUG_PRINTLN("Error al solicitar DeviceTime: comando no pudo ser encolado");
                    // Si estamos en el último intento, continuamos de todas formas
                    if (rtcAttempts >= maxAttempts) {
                        DEBUG_PRINTLN("Agotados los intentos de actualización de RTC");
                    } else {
                        delay(1000); // Esperar un segundo antes del siguiente intento
                    }
                }
            }
            
            // Si no se pudo actualizar el RTC después de los intentos máximos, retornar error
            if (!rtcUpdated) {
                DEBUG_PRINTLN("No se pudo actualizar el RTC después de los intentos máximos, entrando en deep sleep");
                store.end();
                return RADIOLIB_ERR_RTC_SYNC_FAILED; // Error personalizado para indicar fallo en sincronización RTC
            }
            
            store.end();
            return RADIOLIB_LORAWAN_NEW_SESSION;
        } else {
            DEBUG_PRINTF("Join falló: %d\n", state);
            store.end();
            return state;
        }
    }

    store.end();
    return state;
}

/**
 * @brief Crea un payload optimizado con formato delimitado por | y , en lugar de JSON.
 * @param readings Vector con lecturas de sensores.
 * @param deviceId ID del dispositivo.
 * @param stationId ID de la estación.
 * @param battery Valor de la batería.
 * @param timestamp Timestamp del sistema.
 * @param buffer Buffer donde se almacenará el payload.
 * @param bufferSize Tamaño del buffer.
 * @return Tamaño del payload generado.
 */
size_t LoRaManager::createDelimitedPayload(
    const std::vector<SensorReading>& readings,
    const String& deviceId,
    const String& stationId,
    float battery,
    uint32_t timestamp,
    char* buffer,
    size_t bufferSize
) {
    // Inicializar buffer
    buffer[0] = '\0';
    size_t offset = 0;
    
    // Formatear batería con hasta 3 decimales
    char batteryStr[16];
    formatFloatTo3Decimals(battery, batteryStr, sizeof(batteryStr));
    
    // Formato: st|d|vt|ts|sensor1_id,sensor1_type,val1,val2,...|sensor2_id,...
    
    // Añadir encabezado: st|d|vt|ts
    offset += snprintf(buffer + offset, bufferSize - offset, 
                      "%s|%s|%s|%lu", 
                      stationId.c_str(), 
                      deviceId.c_str(), 
                      batteryStr, 
                      timestamp);
    
    // Añadir cada sensor
    for (const auto& reading : readings) {
        if (offset >= bufferSize - 1) break; // Evitar desbordamiento
        
        // Añadir separador de sensor
        buffer[offset++] = '|';
        buffer[offset] = '\0';
        
        // Añadir ID y tipo del sensor
        offset += snprintf(buffer + offset, bufferSize - offset, 
                          "%s,%d", 
                          reading.sensorId, 
                          reading.type);
        
        // Añadir valores
        if (reading.subValues.empty()) {
            // Un solo valor
            char valStr[16];
            formatFloatTo3Decimals(reading.value, valStr, sizeof(valStr));
            offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
        } else {
            // Múltiples valores (subValues)
            for (const auto& sv : reading.subValues) {
                char valStr[16];
                formatFloatTo3Decimals(sv.value, valStr, sizeof(valStr));
                offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
            }
        }
    }
    
    return offset;
}

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
/**
 * @brief Crea un payload optimizado con formato delimitado para sensores normales y Modbus.
 * @param normalReadings Vector con lecturas de sensores normales.
 * @param modbusReadings Vector con lecturas de sensores Modbus.
 * @param deviceId ID del dispositivo.
 * @param stationId ID de la estación.
 * @param battery Valor de la batería.
 * @param timestamp Timestamp del sistema.
 * @param buffer Buffer donde se almacenará el payload.
 * @param bufferSize Tamaño del buffer.
 * @return Tamaño del payload generado.
 */
size_t LoRaManager::createDelimitedPayload(
    const std::vector<SensorReading>& normalReadings,
    const std::vector<ModbusSensorReading>& modbusReadings,
    const String& deviceId,
    const String& stationId,
    float battery,
    uint32_t timestamp,
    char* buffer,
    size_t bufferSize
) {
    // Inicializar buffer
    buffer[0] = '\0';
    size_t offset = 0;
    
    // Formatear batería con hasta 3 decimales
    char batteryStr[16];
    formatFloatTo3Decimals(battery, batteryStr, sizeof(batteryStr));
    
    // Formato: st|d|vt|ts|sensor1_id,sensor1_type,val1,val2,...|sensor2_id,...
    
    // Añadir encabezado: st|d|vt|ts
    offset += snprintf(buffer + offset, bufferSize - offset, 
                      "%s|%s|%s|%lu", 
                      stationId.c_str(), 
                      deviceId.c_str(), 
                      batteryStr, 
                      timestamp);
    
    // Añadir sensores normales
    for (const auto& reading : normalReadings) {
        if (offset >= bufferSize - 1) break; // Evitar desbordamiento
        
        // Añadir separador de sensor
        buffer[offset++] = '|';
        buffer[offset] = '\0';
        
        // Añadir ID y tipo del sensor
        offset += snprintf(buffer + offset, bufferSize - offset, 
                          "%s,%d", 
                          reading.sensorId, 
                          reading.type);
        
        // Añadir valores
        if (reading.subValues.empty()) {
            // Un solo valor
            char valStr[16];
            formatFloatTo3Decimals(reading.value, valStr, sizeof(valStr));
            offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
        } else {
            // Múltiples valores (subValues)
            for (const auto& sv : reading.subValues) {
                char valStr[16];
                formatFloatTo3Decimals(sv.value, valStr, sizeof(valStr));
                offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
            }
        }
    }
    
    // Añadir sensores Modbus
    for (const auto& reading : modbusReadings) {
        if (offset >= bufferSize - 1) break; // Evitar desbordamiento
        
        // Añadir separador de sensor
        buffer[offset++] = '|';
        buffer[offset] = '\0';
        
        // Añadir ID y tipo del sensor
        offset += snprintf(buffer + offset, bufferSize - offset, 
                          "%s,%d", 
                          reading.sensorId, 
                          reading.type);
        
        // Añadir valores
        for (const auto& sv : reading.subValues) {
            char valStr[16];
            formatFloatTo3Decimals(sv.value, valStr, sizeof(valStr));
            offset += snprintf(buffer + offset, bufferSize - offset, ",%s", valStr);
        }
    }
    
    return offset;
}
#endif

/**
 * @brief Envía el payload de sensores estándar usando formato delimitado.
 * @param readings Vector con todas las lecturas de sensores.
 * @param node Referencia al nodo LoRaWAN
 * @param deviceId ID del dispositivo
 * @param stationId ID de la estación
 * @param rtc Referencia al RTC para obtener timestamp
 */
void LoRaManager::sendDelimitedPayload(
    const std::vector<SensorReading>& readings, 
    LoRaWANNode& node,
    const String& deviceId, 
    const String& stationId, 
    ESP32Time& rtc) 
{
    char payloadBuffer[MAX_LORA_PAYLOAD + 1];
    
    // Crear payload delimitado
    float battery = BatterySensor::readVoltage();

    // Obtener timestamp
    uint32_t timestamp = rtc.getEpoch();

    // Crear payload
    size_t payloadSize = createDelimitedPayload(
        readings, 
        deviceId, 
        stationId, 
        battery, 
        timestamp, 
        payloadBuffer, 
        sizeof(payloadBuffer)
    );
    
    DEBUG_PRINTF("Enviando payload delimitado con tamaño %d bytes\n", payloadSize);
    DEBUG_PRINTLN(payloadBuffer);
    
    // Enviar
    uint8_t fPort = 1;
    uint8_t downlinkPayload[255];
    size_t downlinkSize = 0;
    
    int16_t state = node.sendReceive(
        (uint8_t*)payloadBuffer, 
        payloadSize, 
        fPort, 
        downlinkPayload, 
        &downlinkSize
    );
    
    if (state == RADIOLIB_ERR_NONE) {
        DEBUG_PRINTLN("Transmisión exitosa!");
        if (downlinkSize > 0) {
            DEBUG_PRINTF("Recibidos %d bytes de downlink\n", downlinkSize);
        }
    } else {
        DEBUG_PRINTF("Error en transmisión: %d\n", state);
    }
}

#if defined(DEVICE_TYPE_ANALOGIC) || defined(DEVICE_TYPE_MODBUS)
/**
 * @brief Envía el payload de sensores estándar y Modbus usando formato delimitado.
 * @param normalReadings Vector con lecturas de sensores estándar
 * @param modbusReadings Vector con lecturas de sensores Modbus
 * @param node Referencia al nodo LoRaWAN
 * @param deviceId ID del dispositivo
 * @param stationId ID de la estación
 * @param rtc Referencia al RTC para obtener timestamp
 */
void LoRaManager::sendDelimitedPayload(
    const std::vector<SensorReading>& normalReadings, 
    const std::vector<ModbusSensorReading>& modbusReadings,
    LoRaWANNode& node,
    const String& deviceId, 
    const String& stationId, 
    ESP32Time& rtc)
{
    char payloadBuffer[MAX_LORA_PAYLOAD + 1];
    
    // Crear payload delimitado
    float battery = BatterySensor::readVoltage();

    // Obtener timestamp
    uint32_t timestamp = rtc.getEpoch();

    // Crear payload
    size_t payloadSize = createDelimitedPayload(
        normalReadings, 
        modbusReadings, 
        deviceId, 
        stationId, 
        battery, 
        timestamp, 
        payloadBuffer, 
        sizeof(payloadBuffer)
    );
    
    DEBUG_PRINTF("Enviando payload delimitado con tamaño %d bytes\n", payloadSize);
    DEBUG_PRINTLN(payloadBuffer);
    
    // Enviar
    uint8_t fPort = 1;
    uint8_t downlinkPayload[255];
    size_t downlinkSize = 0;

    /*
    Lista de Data Rates (DR) para LoRaWAN US915

    - Cada DR define un conjunto específico de parámetros: 
        - SF (Spreading Factor): Cuanto mayor es, más alcance tiene pero menor velocidad de transmisión.
        - BW (Bandwidth): Mayor ancho de banda significa mayor velocidad pero menor alcance.
        - CR (Coding Rate): Relación de corrección de errores.
        - Payload Máximo: Tamaño máximo de datos en bytes que se pueden enviar en una sola transmisión.

    - NOTA: DR5, DR6 y DR7 no están definidos en US915.

    Índice | SF  | BW   | CR   | Payload Máximo | Comentario
    -------|-----|------|------|---------------|------------------------------------
    DR0    | SF10 | 125kHz | 4/5 | 19 bytes      | Mayor alcance, menor velocidad.
    DR1    | SF9  | 125kHz | 4/5 | 61 bytes      | Menor alcance, más velocidad que DR0.
    DR2    | SF8  | 125kHz | 4/5 | 133 bytes     | Velocidad media, menor alcance que DR1.
    DR3    | SF7  | 125kHz | 4/5 | 250 bytes     | Mayor velocidad en 125kHz, menor alcance.
    DR4    | SF8  | 500kHz | 4/5 | 250 bytes     | Mayor BW para mejorar la velocidad.
    DR5    | N/A  | N/A    | N/A | No definido   | No definido en US915.
    DR6    | N/A  | N/A    | N/A | No definido   | No definido en US915.
    DR7    | N/A  | N/A    | N/A | No definido   | No definido en US915.
    DR8    | SF12 | 500kHz | 4/5 | 41 bytes      | Mayor alcance en 500kHz, menor velocidad.
    DR9    | SF11 | 500kHz | 4/5 | 117 bytes     | Más velocidad que DR8, menos alcance.
    DR10   | SF10 | 500kHz | 4/5 | 230 bytes     | Más velocidad que DR9.
    DR11   | SF9  | 500kHz | 4/5 | 230 bytes     | Velocidad media en 500kHz.
    DR12   | SF8  | 500kHz | 4/5 | 230 bytes     | Más velocidad que DR11.
    DR13   | SF7  | 500kHz | 4/5 | 230 bytes     | Mayor velocidad en 500kHz, menor alcance.
    DR14   | N/A  | N/A    | N/A | No definido   | No definido en US915.

    - DR0 a DR3 se usan para **uplink** en los 64 canales de 125kHz.
    - DR4 se usa para **uplink** en los 8 canales de 500kHz.
    - DR8 a DR13 se usan para **downlink** en los 8 canales de 500kHz.
    - El payload máximo puede verse afectado por la opción **FOpt** en el MAC layer.
    */
    LoRaManager::setDatarate(node, 3);

    
    // int16_t state = node.sendReceive(
    //     (uint8_t*)payloadBuffer, 
    //     payloadLength, 
    //     fPort, 
    //     downlinkPayload, 
    //     &downlinkSize
    // );

    int16_t state = node.uplink(
        (uint8_t*)payloadBuffer, 
        payloadSize, 
        fPort
    );
    
    if (state == RADIOLIB_ERR_NONE) {
        DEBUG_PRINTLN("Transmisión exitosa!");
        if (downlinkSize > 0) {
            DEBUG_PRINTF("Recibidos %d bytes de downlink\n", downlinkSize);
        }
    } else {
        DEBUG_PRINTF("Error en transmisión: %d\n", state);
    }
}
#endif

void LoRaManager::prepareForSleep(SX1262* radio) {
    if (radio) {
        radio->sleep(true);
    }
}

void LoRaManager::setDatarate(LoRaWANNode& node, uint8_t datarate) {
    node.setDatarate(datarate);
}

================
File: src/sensors/CO2Sensor.cpp
================
#include "sensors/CO2Sensor.h"

// Variable externa definida en main.cpp
extern SCD4x scd4x;

/**
 * @brief Inicializa el sensor SCD4x.
 */
bool CO2Sensor::begin() {
    return scd4x.begin(false, true, false);
}

/**
 * @brief Lee CO2, temperatura y humedad del sensor SCD4x en modo single-shot.
 * 
 * @param outCO2 Variable donde se almacenará la concentración de CO2 en ppm.
 * @param outTemp Variable donde se almacenará la temperatura en °C.
 * @param outHum Variable donde se almacenará la humedad relativa en %.
 * @return true si la lectura fue exitosa, false en caso contrario.
 */
bool CO2Sensor::read(float &outCO2, float &outTemp, float &outHum) {
    // Iniciar valores en NAN en caso de error
    outCO2 = NAN;
    outTemp = NAN;
    outHum = NAN;
    
    // Iniciar una medición en modo single-shot
    if (!scd4x.measureSingleShot()) {
        return false;
    }
    
    // Esperar hasta que haya datos disponibles (con timeout)
    uint32_t counter = 0;
    const uint32_t maxAttempts = 200; // 200 intentos * 50ms = 10 segundos máximo
    
    while (counter < maxAttempts) {
        delay(50); // Esperar 50ms entre comprobaciones
        counter++;
        
        if (scd4x.readMeasurement()) {
            // Leer los valores medidos
            outCO2 = (float)scd4x.getCO2();
            outTemp = scd4x.getTemperature();
            outHum = scd4x.getHumidity();
            return true;
        }
    }
    
    // Si llegamos aquí, hubo timeout
    return false;
}

================
File: src/sensors/NtcManager.cpp
================
#include "sensors/NtcManager.h"
#include <cmath>  // Para fabs() y otras funciones matemáticas
#include "config_manager.h"
#include "debug.h"
#include "config.h"  // Para acceder a NTC_TEMP_MIN y NTC_TEMP_MAX

void NtcManager::calculateSteinhartHartCoeffs(double T1, double R1,
                                          double T2, double R2,
                                          double T3, double R3,
                                          double &A, double &B, double &C) 
{
    // Ecuación de Steinhart-Hart:
    // 1/T = A + B*ln(R) + C*(ln(R))^3
    
    double L1 = log(R1);
    double L2 = log(R2);
    double L3 = log(R3);
    
    double Y1 = 1.0 / T1;
    double Y2 = 1.0 / T2;
    double Y3 = 1.0 / T3;
    
    // Resolver sistema de ecuaciones para encontrar A, B, C
    double L1_3 = L1 * L1 * L1;
    double L2_3 = L2 * L2 * L2;
    double L3_3 = L3 * L3 * L3;
    
    double denominator = (L2 - L1) * (L3 - L1) * (L3 - L2);
    
    // Protección contra división por cero
    if (fabs(denominator) < 1e-10) {
        // Asignar NAN para indicar claramente el error
        A = NAN;
        B = NAN;
        C = NAN;
        return;
    }
    
    // Calcular C
    C = ((Y2 - Y1) * (L3 - L1) - (Y3 - Y1) * (L2 - L1)) / 
        ((L2_3 - L1_3) * (L3 - L1) - (L3_3 - L1_3) * (L2 - L1));
    
    // Calcular B
    B = ((Y2 - Y1) - C * (L2_3 - L1_3)) / (L2 - L1);
    
    // Calcular A
    A = Y1 - B * L1 - C * L1_3;
}

double NtcManager::steinhartHartTemperature(double resistance, double A, double B, double C) 
{
    if (resistance <= 0.0) {
        return NAN;
    }
    double lnR = log(resistance);
    double invT = A + B * lnR + C * lnR*lnR*lnR;  // 1/T en Kelvin^-1
    double tempK = 1.0 / invT;                   // Kelvin
    double tempC = tempK - 273.15;               // °C
    return tempC;
}

double NtcManager::computeNtcResistanceFromVoltageDivider(double voltage, double vRef, double rFixed, bool ntcTop)
{
    // Validación de rangos
    if (voltage <= 0.0 || voltage >= vRef) {
        return -1.0;  // Indica valor inválido
    }
    
    // Calcular resistencia del NTC
    double Rntc;
    
    if (ntcTop) {
        // NTC conectado a Vref (arriba) y resistencia fija a GND (abajo)
        // Fórmula: Rntc = rFixed * (vRef - voltage) / voltage
        Rntc = rFixed * ((vRef - voltage) / voltage);
    } else {
        // NTC conectado a GND (abajo) y resistencia fija a Vref (arriba)
        // Fórmula: Rntc = rFixed * voltage / (vRef - voltage)
        Rntc = rFixed * (voltage / (vRef - voltage));
    }
    
    return Rntc;
}

double NtcManager::readNtc100kTemperature(const char* configKey) {
    // Obtener calibración NTC100K de la configuración
    double t1=25.0, r1=100000.0, t2=35.0, r2=64770.0, t3=45.0, r3=42530.0;
    ConfigManager::getNTC100KConfig(t1, r1, t2, r2, t3, r3);

    // Pasar °C a Kelvin
    double T1K = t1 + 273.15;
    double T2K = t2 + 273.15;
    double T3K = t3 + 273.15;

    // Calcular coeficientes Steinhart-Hart
    double A=0, B=0, C=0;
    calculateSteinhartHartCoeffs(T1K, r1, T2K, r2, T3K, r3, A, B, C);
    
    // Seleccionar el pin correcto según el configKey
    int ntcPin = -1;
    if (strcmp(configKey, "0") == 0) {
        ntcPin = NTC100K_0_PIN;
    } else if (strcmp(configKey, "1") == 0) {
        ntcPin = NTC100K_1_PIN;
    } else {
        // Si no coincide con ninguna configuración, retornamos NAN
        return NAN;
    }

    //  
    int adcValue = analogReadMilliVolts(ntcPin);
    
    // Usar directamente el valor en milivoltios, convertido a voltios
    float voltage = adcValue / 1000.0f;
    
    if (isnan(voltage) || voltage <= 0.0f || voltage >= 3.0f) {
        return NAN;
    }

    // El NTC100K está conectado como parte de un divisor de voltaje:
    // 3V --- NTC100K --- [Punto de medición] --- 100K --- GND
    // A mayor temperatura, menor resistencia del NTC, mayor voltaje en el punto de medición
    double vRef = 3.0; // Voltaje de referencia (3V)
    double rFixed = 100000.0; // Resistencia fija (100k)
    bool ntcTop = true; // NTC está conectado a Vref (arriba)
    
    // Calcular la resistencia NTC en ohms
    double Rntc = computeNtcResistanceFromVoltageDivider(voltage, vRef, rFixed, ntcTop);
    if (Rntc <= 0.0) {
        return NAN;
    }

    // Usar Steinhart-Hart para calcular la temperatura en °C
    double tempC = steinhartHartTemperature(Rntc, A, B, C);
    
    // Validar que el valor de temperatura está dentro de los límites aceptables
    if (isnan(tempC) || tempC < NTC_TEMP_MIN || tempC > NTC_TEMP_MAX) {
        return NAN;
    }
    
    return tempC;
}

double NtcManager::readNtc10kTemperature() {
    // Obtener calibración NTC10K de la configuración
    // Usando valores por defecto para un NTC10K común
    double t1=25.0, r1=10000.0, t2=50.0, r2=3893.0, t3=85.0, r3=1218.0;
    ConfigManager::getNTC10KConfig(t1, r1, t2, r2, t3, r3);

    // Pasar °C a Kelvin
    double T1K = t1 + 273.15;
    double T2K = t2 + 273.15;
    double T3K = t3 + 273.15;

    // Calcular coeficientes Steinhart-Hart
    double A=0, B=0, C=0;
    calculateSteinhartHartCoeffs(T1K, r1, T2K, r2, T3K, r3, A, B, C);

    // Leer el valor analógico del pin NTC10K usando analogReadMilliVolts
    int adcValue = analogReadMilliVolts(NTC10K_PIN);
    
    // Convertir de milivoltios a voltios
    float voltage = adcValue / 1000.0f;
    
    if (isnan(voltage) || voltage <= 0.0f || voltage >= 3.0f) {
        return NAN;
    }

    // El NTC10K está conectado entre 3V y el punto medio con resistencia de 10k a GND
    // A mayor temperatura, menor resistencia del NTC, mayor voltaje en el punto de medición
    double vRef = 3.0; // Voltaje de referencia (3V)
    double rFixed = 10000.0; // Resistencia fija (10k)
    bool ntcTop = true; // NTC está conectado a Vref (arriba)
    
    double Rntc = computeNtcResistanceFromVoltageDivider(voltage, vRef, rFixed, ntcTop);
    if (Rntc <= 0.0) {
        return NAN;
    }

    // Usar Steinhart-Hart para calcular la temperatura en °C
    double tempC = steinhartHartTemperature(Rntc, A, B, C);
    
    // Validar que el valor de temperatura está dentro de los límites aceptables
    if (isnan(tempC) || tempC < NTC_TEMP_MIN || tempC > NTC_TEMP_MAX) {
        return NAN;
    }
    
    return tempC;
}

================
File: src/sensors/SHT4xSensor.cpp
================
#include "sensors/SHT4xSensor.h"

/**
 * @brief Inicializa el sensor SHT4x
 * 
 * @return true si se inicializó correctamente, false en caso contrario
 */
bool SHT4xSensor::begin() {
    // Inicializar el objeto SHT4x con el bus I2C y la dirección
    sht4xSensor.begin(Wire, SHT40_I2C_ADDR_44);
    
    // Hacer un reset para asegurar que el sensor está en un estado limpio
    int16_t error = sht4xSensor.softReset();
    if (error != 0) {
        return false;
    }
    
    // Realizar una lectura de prueba
    float temp, hum;
    error = sht4xSensor.measureHighPrecision(temp, hum);
    if (error != 0) {
        return false;
    }
    
    return true;
}

/**
 * @brief Lee temperatura y humedad del sensor SHT4x
 * 
 * @param outTemp Variable donde se almacenará la temperatura en °C
 * @param outHum Variable donde se almacenará la humedad relativa en %
 * @return true si la lectura fue exitosa, false en caso contrario
 */
bool SHT4xSensor::read(float &outTemp, float &outHum) {
    // Intentar hasta 3 veces obtener una lectura válida
    for (int i = 0; i < 3; i++) {
        int16_t error = sht4xSensor.measureHighPrecision(outTemp, outHum);
        
        if (error == 0) {
            // Verificar que los valores sean válidos (no cero y dentro de rangos razonables)
            if (!isnan(outTemp) && !isnan(outHum) && 
                outTemp > -40.0f && outTemp < 125.0f && 
                outHum >= 0.0f && outHum <= 100.0f) {
                return true; // Retornar inmediatamente con la primera lectura válida
            }
        }
        
        delay(5); // Pequeña pausa entre intentos
    }
    
    // Si no se encontró ninguna lectura válida
    outTemp = NAN;
    outHum = NAN;
    return false;
}

================
File: platformio.ini
================
; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:esp32-s3-devkitc-1]
platform = espressif32
board = esp32-s3-devkitc-1
framework = arduino
lib_deps = 
	SPI
	Wire
	BLE
	jgromes/RadioLib@^6.6.0
	bblanchon/ArduinoJson@^6.21.4
	sensirion/Sensirion I2C SHT3x@^1.0.1
	fbiego/ESP32Time@^2.0.6
	pstolarz/OneWireNg@^0.14.0
	adafruit/Adafruit MAX31865 library@^1.6.2
	sparkfun/SparkFun SCD4x Arduino Library@^1.1.2
	adafruit/Adafruit BME680 Library@^2.0.5
	adafruit/Adafruit BME280 Library@^2.2.4
	adafruit/Adafruit VEML7700 Library@^2.1.6
	sensirion/Sensirion I2C SHT4x@^1.1.2
upload_speed = 921600
monitor_speed = 115200

================
File: include/HardwareManager.h
================
/*******************************************************************************************
 * Archivo: include/HardwareManager.h
 * Descripción: Gestión de inicialización y configuración del hardware del sistema.
 * Incluye funciones para inicialización de periféricos y control de energía.
 *******************************************************************************************/

#ifndef HARDWARE_MANAGER_H
#define HARDWARE_MANAGER_H

#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include "config.h"
#include "PowerManager.h"
#include "SHT31.h"
#include "sensor_types.h"
#include <vector>
#include <Adafruit_BME680.h>
#include <Adafruit_BME280.h>
#include <Adafruit_VEML7700.h>
#include <SensirionI2cSht4x.h>
#include <map>
#include <string>

extern SHT31 sht30Sensor;
extern Adafruit_BME680 bme680Sensor;
extern Adafruit_BME280 bme280Sensor;
extern Adafruit_VEML7700 veml7700Sensor;
extern SensirionI2cSht4x sht4xSensor;
extern std::map<std::string, bool> sensorInitStatus;

class HardwareManager {
public:
    /**
     * @brief Inicializa el hardware básico del sistema: pines GPIO, buses I2C/SPI y Power Manager.
     * 
     * Este método configura el hardware de bajo nivel pero ya no inicializa sensores específicos,
     * esa responsabilidad se ha trasladado a SensorManager.
     * 
     * @param powerManager Referencia al gestor de energía
     * @param sht30Sensor Referencia al sensor SHT30 (no se inicializa aquí)
     * @param bme680Sensor Referencia al sensor BME680 (no se inicializa aquí)
     * @param bme280Sensor Referencia al sensor BME280 (no se inicializa aquí)
     * @param veml7700Sensor Referencia al sensor VEML7700 (no se inicializa aquí)
     * @param sht4xSensor Referencia al sensor SHT4x (no se inicializa aquí)
     * @param spiLora Referencia a la interfaz SPI para LoRa
     * @param enabledNormalSensors Vector con las configuraciones de sensores habilitados
     * @return true si la inicialización fue exitosa, false en caso contrario
     */
    static bool initHardware(PowerManager& powerManager, 
                           SHT31& sht30Sensor, 
                           Adafruit_BME680& bme680Sensor,
                           Adafruit_BME280& bme280Sensor,
                           Adafruit_VEML7700& veml7700Sensor,
                           SensirionI2cSht4x& sht4xSensor,
                           SPIClass& spiLora,
                           const std::vector<SensorConfig>& enabledNormalSensors);

    /**
     * @brief Inicializa los pines de selección SPI (SS)
     */
    static void initializeSPISSPins();

};

#endif // HARDWARE_MANAGER_H

================
File: src/sensors/BatterySensor.cpp
================
#include "sensors/BatterySensor.h"
#include "config.h"

/**
 * @brief Lee el voltaje de la batería
 * 
 * @return float Voltaje de la batería en voltios, o NAN si hay error
 */
float BatterySensor::readVoltage() {
    // Activar el pin de control para habilitar la medición
    pinMode(BATTERY_CONTROL_PIN, OUTPUT);
    digitalWrite(BATTERY_CONTROL_PIN, LOW);
    
    // Esperar un breve momento para estabilizar la lectura
    delay(10);
    
    // Leer el valor del pin analógico para la batería en milivoltios directamente
    int milliVolts = analogReadMilliVolts(BATTERY_SENSOR_PIN);

    // Desactivar el pin de control para ahorrar energía
    digitalWrite(BATTERY_CONTROL_PIN, HIGH);
    
    // Convertir de milivoltios a voltios
    float voltage = milliVolts / 1000.0f;
    
    // Comprobar si el voltaje es válido
    if (isnan(voltage) || voltage <= 0.0f || voltage >= 3.3f) {
        return NAN;
    }

    // Calcular el voltaje real de la batería
    float batteryVoltage = calculateBatteryVoltage(voltage);
    return batteryVoltage;
}

/**
 * @brief Calcula el voltaje real de la batería a partir de la lectura del ADC
 * 
 * El circuito es un divisor de voltaje con:
 * R1 = 100k (a GND)
 * R2 = 390k (a batería)
 * VBAT = VADC_IN1 * (R1 + R2) / R1 = VADC_IN1 * (100k + 390k) / 100k
 * 
 * @param adcVoltage Voltaje medido por el ADC
 * @return float Voltaje real de la batería
 */
float BatterySensor::calculateBatteryVoltage(float adcVoltage) {
    // VBAT = 100k / (100k+390k) * VADC_IN1 corregido a:
    // VBAT = VADC_IN1 / (100k / (100k+390k))
    return adcVoltage / (R1 / (R1 + R2));
}

================
File: include/SensorManager.h
================
#ifndef SENSOR_MANAGER_H
#define SENSOR_MANAGER_H

#include <Arduino.h>
#include <vector>
#include "sensor_types.h"
#include <ESP32Time.h>
#include "PowerManager.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include "SHT31.h"
#include "ModbusSensorManager.h"
#include "sensors/NtcManager.h"
#include <SPI.h>
#include <Adafruit_MAX31865.h>
#include <Adafruit_VEML7700.h>
#include <map>
#include <string>

// Variables y objetos globales declarados en main.cpp
extern ESP32Time rtc;
extern PowerManager powerManager;
extern SPIClass spiLora;
extern SPISettings spiAdcSettings;
extern OneWire oneWire;
extern DallasTemperature dallasTemp;
extern SHT31 sht30Sensor;
extern Adafruit_MAX31865 rtdSensor;
extern Adafruit_VEML7700 veml7700;
extern std::map<std::string, bool> sensorInitStatus; // Declaración externa del mapa de estado

/**
 * @brief Clase que maneja la inicialización y lecturas de todos los sensores
 *        incluyendo sensores normales y Modbus.
 */
class SensorManager {
  public:
    /**
     * @brief Inicializa todos los sensores habilitados en el sistema.
     * 
     * Este método se encarga de:
     * 1. Inicializar sensores I2C (SHT30, SHT4X, CO2, BME680, BME280, VEML7700)
     * 2. Inicializar sensores RTD si están habilitados
     * 3. Inicializar sensores DS18B20 si están habilitados
     * 4. Configurar pines analógicos para sensores específicos (NTC, pH, conductividad, etc.)
     * 5. Configurar el ADC interno
     * 
     * @param enabledNormalSensors Vector con las configuraciones de sensores habilitados
     */
    static void beginSensors(const std::vector<SensorConfig>& enabledNormalSensors);

    // Devuelve la lectura (o lecturas) de un sensor NO-Modbus según su configuración.
    static SensorReading getSensorReading(const SensorConfig& cfg);
    
    // Devuelve la lectura de un sensor Modbus según su configuración
    static ModbusSensorReading getModbusSensorReading(const ModbusSensorConfig& cfg);
    
    // Obtiene todas las lecturas de sensores (normales y Modbus) habilitados
    static void getAllSensorReadings(std::vector<SensorReading>& normalReadings,
                                    std::vector<ModbusSensorReading>& modbusReadings,
                                    const std::vector<SensorConfig>& enabledNormalSensors,
                                    const std::vector<ModbusSensorConfig>& enabledModbusSensors);

  private:
    // Métodos de lectura internos
    static float readSensorValue(const SensorConfig &cfg, SensorReading &reading);
};

#endif // SENSOR_MANAGER_H

================
File: src/SleepManager.cpp
================
#include "SleepManager.h"
#include "debug.h"
#include "LoRaManager.h"
#include "esp_sleep.h"
#include "driver/rtc_io.h"

void SleepManager::goToDeepSleep(uint32_t timeToSleep, 
                               PowerManager& powerManager,
                               SX1262* radio,
                               LoRaWANNode& node,
                               uint8_t* LWsession,
                               SPIClass& spiLora) {
    // Guardar sesión en RTC y otras rutinas de apagado
    uint8_t *persist = node.getBufferSession();
    memcpy(LWsession, persist, RADIOLIB_LORAWAN_SESSION_BUF_SIZE);
    
    // Flush Serial antes de dormir
    DEBUG_FLUSH();
    DEBUG_END();
    
    // Apagar módulos
    LoRaManager::prepareForSleep(radio);
    btStop();

    // Deshabilitar I2C y SPI
    Wire.end();
    spiLora.end();
    
    // Configurar pines para deep sleep (excepto CONFIG_PIN)
    configurePinsForDeepSleep();

    // --- INICIO: Configuración específica del pin de despertar ---
    gpio_num_t wakePin = (gpio_num_t)CONFIG_PIN;

    // 1. Desinicializar por si acaso (buena práctica)
    rtc_gpio_deinit(wakePin);

    // 2. Inicializar como RTC GPIO
    rtc_gpio_init(wakePin);

    // 3. Establecer dirección como ENTRADA
    rtc_gpio_set_direction(wakePin, RTC_GPIO_MODE_INPUT_ONLY);

    // 4. Habilitar PULL-UP (Incluso con externa, no hace daño y es robusto)
    rtc_gpio_pullup_en(wakePin);

    // 5. Deshabilitar PULL-DOWN explícitamente
    rtc_gpio_pulldown_dis(wakePin);

    // 6. Asegurarse de que el "hold" esté deshabilitado para este pin
    rtc_gpio_hold_dis(wakePin);
    // --- FIN: Configuración específica del pin de despertar ---

    // Configurar el temporizador y GPIO para despertar
    esp_sleep_enable_timer_wakeup(timeToSleep * 1000000ULL);
    esp_sleep_enable_ext0_wakeup(wakePin, 0); // 0 para nivel bajo

    esp_deep_sleep_start();
}

/**
 * @brief Configura los pines no utilizados en alta impedancia para reducir el consumo durante deep sleep.
 */
void SleepManager::configurePinsForDeepSleep() {
    // Configurar pines específicos del módulo LoRa como ANALOG
    pinMode(ONE_WIRE_BUS, ANALOG); //alta impedancia

    // Configurar pines I2C como ANALOG
    pinMode(I2C_SCL_PIN, ANALOG); //alta impedancia
    pinMode(I2C_SDA_PIN, ANALOG); //alta impedancia

    // Serial 1
    pinMode(SERIAL1_RX_PIN, ANALOG); //alta impedancia
    pinMode(SERIAL1_TX_PIN, ANALOG); //alta impedancia

    // Configurar pin de control de batería como salida
    pinMode(BATTERY_CONTROL_PIN, ANALOG); //alta impedancia

    // Configurar pines del módulo LoRa como ANALOG
    pinMode(LORA_RST_PIN, ANALOG); //alta impedancia
    pinMode(LORA_BUSY_PIN, ANALOG); //alta impedancia
    pinMode(LORA_DIO1_PIN, ANALOG); //alta impedancia
    pinMode(SPI_LORA_SCK_PIN, ANALOG); //alta impedancia
    pinMode(SPI_LORA_MISO_PIN, ANALOG); //alta impedancia
    pinMode(SPI_LORA_MOSI_PIN, ANALOG); //alta impedancia

    // SPI PARA RTD
    pinMode(SPI_SCK_PIN, ANALOG); //alta impedancia
    pinMode(SPI_MISO_PIN, ANALOG); //alta impedancia
    pinMode(SPI_MOSI_PIN, ANALOG); //alta impedancia

    // Configurar pines de sensores analógicos como ANALOG
    pinMode(NTC100K_0_PIN, ANALOG); //alta impedancia
    pinMode(NTC100K_1_PIN, ANALOG); //alta impedancia
    pinMode(NTC10K_PIN, ANALOG); //alta impedancia
    pinMode(PH_SENSOR_PIN, ANALOG); //alta impedancia
    pinMode(COND_SENSOR_PIN, ANALOG); //alta impedancia
    pinMode(HDS10_SENSOR_PIN, ANALOG); //alta impedancia
    pinMode(BATTERY_SENSOR_PIN, ANALOG); //alta impedancia
    pinMode(SOILH_SENSOR_PIN, ANALOG); //alta impedancia

    // Configurar pin de LED de configuración como alta impedancia
    pinMode(CONFIG_LED_PIN, ANALOG); //alta impedancia
    pinMode(LED1_PIN, ANALOG); //alta impedancia
    pinMode(LED2_PIN, ANALOG); //alta impedancia

    //Modbus
    pinMode(MODBUS_RX_PIN, ANALOG); //alta impedancia
    pinMode(MODBUS_TX_PIN, ANALOG); //alta impedancia

    // Alimentacion
    pinMode(POWER_3V3_PIN, ANALOG); //alta impedancia
    pinMode(POWER_12V_PIN, ANALOG); //alta impedancia

    // FlowSensor
    pinMode(FLOW_SENSOR_PIN, ANALOG); //alta impedancia


    digitalWrite(LORA_NSS_PIN, HIGH);
    gpio_hold_en((gpio_num_t)LORA_NSS_PIN);
    digitalWrite(PT100_CS_PIN, HIGH);
    gpio_hold_en((gpio_num_t)PT100_CS_PIN);
}

/**
 * @brief Libera el estado de retención (hold) de los pines que fueron configurados para deep sleep.
 * Esto permite que los pines puedan ser reconfigurados adecuadamente tras salir del deep sleep.
 */
void SleepManager::releaseHeldPins() {
    // Liberar otros pines si se ha aplicado retención
    gpio_hold_dis((gpio_num_t)LORA_NSS_PIN);
    gpio_hold_dis((gpio_num_t)PT100_CS_PIN);
}

================
File: src/HardwareManager.cpp
================
/*******************************************************************************************
 * Archivo: src/HardwareManager.cpp
 * Descripción: Implementación de la gestión de hardware del sistema.
 *******************************************************************************************/

#include "HardwareManager.h"
#include "debug.h"
#include <map>
#include <string>

// Variables externas
extern std::map<std::string, bool> sensorInitStatus;

// time execution < 10 ms
bool HardwareManager::initHardware(PowerManager& powerManager, 
                                 SHT31& sht30Sensor,
                                 Adafruit_BME680& bme680Sensor,
                                 Adafruit_BME280& bme280Sensor,
                                 Adafruit_VEML7700& veml7700Sensor,
                                 SensirionI2cSht4x& sht4xSensor,
                                 SPIClass& spiLora, 
                                 const std::vector<SensorConfig>& enabledNormalSensors) {
    // Configurar GPIO one wire con pull-up
    pinMode(ONE_WIRE_BUS, INPUT_PULLUP);
    
    // Inicializar el pin de control de batería y desactivar la medición
    pinMode(BATTERY_CONTROL_PIN, OUTPUT);
    digitalWrite(BATTERY_CONTROL_PIN, HIGH);
    pinMode(CONFIG_LED_PIN, OUTPUT);
    digitalWrite(CONFIG_LED_PIN, LOW); // Apagar LED inicialmente
    
    // Verificar si hay algún sensor I2C habilitado
    bool someI2cSensorEnabled = false;

    // Primero, determinar si algún sensor I2C está habilitado y marcar todos como no inicializados
    for (const auto& sensor : enabledNormalSensors) {
        if (sensor.enable) {
            if (sensor.type == SHT30 || sensor.type == SHT4X || sensor.type == CO2 || 
                sensor.type == BME680 || sensor.type == BME280 || 
                sensor.type == VEML7700) {
                someI2cSensorEnabled = true;
                // Asumir fallo inicial para todos los sensores habilitados
                sensorInitStatus[sensor.sensorId] = false;
            } else {
                // Asumir éxito para sensores no-I2C
                sensorInitStatus[sensor.sensorId] = true;
            }
        }
    }

    // Inicializar I2C solo si es necesario
    if (someI2cSensorEnabled) {
        Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
    }
    
    // Inicializar SPI para LORA con pines definidos
    spiLora.begin(SPI_LORA_SCK_PIN, SPI_LORA_MISO_PIN, SPI_LORA_MOSI_PIN);
    
    // Inicializar los pines de selección SPI (SS)
    initializeSPISSPins();
    
    //Inicializar PowerManager para control de energía
    powerManager.begin();
    
    return true;
}

void HardwareManager::initializeSPISSPins() {
    // Inicializar SS del LORA conectado directamente
    pinMode(LORA_NSS_PIN, OUTPUT);
    digitalWrite(LORA_NSS_PIN, HIGH);

    // Inicializar SS de PT100 como pin nativo
    pinMode(PT100_CS_PIN, OUTPUT);
    digitalWrite(PT100_CS_PIN, HIGH);
}

================
File: src/SensorManager.cpp
================
#include "SensorManager.h"
#include <Wire.h>
#include <SPI.h>
#include <cmath>  // Para fabs() y otras funciones matemáticas
#include <DallasTemperature.h>
#include "sensor_types.h"
#include "config.h"
#include <Preferences.h>
#include "config_manager.h"
#include "debug.h"
#include "utilities.h"
#include <map>
#include <string>

// Eliminadas las inclusiones de "ADS124S08.h" y "AdcUtilities.h"
#include "sensors/NtcManager.h"
#include "sensors/PHSensor.h"
#include "sensors/ConductivitySensor.h"
#include "sensors/HDS10Sensor.h"
// Se eliminó la variable externa ADC

// Inclusión de sensores
#include "sensors/SHT30Sensor.h"
#include "sensors/DS18B20Sensor.h"
#include "sensors/CO2Sensor.h" // Añadir inclusión para sensor CO2
#include "sensors/VEML7700Sensor.h" // Añadir inclusión para sensor VEML7700
#include "sensors/SHT4xSensor.h" // Añadir inclusión para sensor SHT4x
#include <Adafruit_BME680.h>
#include <Adafruit_BME280.h>
#include <Adafruit_VEML7700.h>

// Variables externas
extern Adafruit_BME680 bme680Sensor;
extern Adafruit_BME280 bme280Sensor;
extern Adafruit_VEML7700 veml7700;
extern std::map<std::string, bool> sensorInitStatus;

// -------------------------------------------------------------------------------------
// Métodos de la clase SensorManager
// -------------------------------------------------------------------------------------

void SensorManager::beginSensors(const std::vector<SensorConfig>& enabledNormalSensors) {
    // Encender alimentación 3.3V
    powerManager.power3V3On();
    
    // Inicializar sensores I2C habilitados
    for (const auto& sensor : enabledNormalSensors) {
        if (!sensor.enable) continue; // Saltar sensores deshabilitados

        // Obtener el identificador del sensor para mapear su estado
        std::string currentSensorId = sensor.sensorId;
        bool success = false;

        switch (sensor.type) {
            case SHT30:
                success = sht30Sensor.begin();
                if (success) sht30Sensor.reset();
                break;
            case SHT4X:
                success = SHT4xSensor::begin();
                break;
            case CO2:
                success = CO2Sensor::begin();
                break;
            case BME680:
                success = bme680Sensor.begin();
                if (success) {
                    bme680Sensor.setTemperatureOversampling(BME680_OS_8X);
                    bme680Sensor.setHumidityOversampling(BME680_OS_2X);
                    bme680Sensor.setPressureOversampling(BME680_OS_4X);
                    bme680Sensor.setIIRFilterSize(BME680_FILTER_SIZE_3);
                    bme680Sensor.setGasHeater(320, 150); // 320°C durante 150 ms
                }
                break;
            case BME280:
                success = bme280Sensor.begin(BME280_I2C_ADDR, &Wire);
                if (success) {
                    bme280Sensor.setSampling(Adafruit_BME280::MODE_FORCED,
                                          Adafruit_BME280::SAMPLING_X1, // temperature
                                          Adafruit_BME280::SAMPLING_X1, // pressure
                                          Adafruit_BME280::SAMPLING_X1, // humidity
                                          Adafruit_BME280::FILTER_OFF);
                }
                break;
            case VEML7700:
                success = VEML7700Sensor::begin();
                break;
            default:
                // Para sensores no-I2C, se manejará en las secciones correspondientes abajo
                continue;
        }
        
        // Actualizar el estado en el mapa global
        sensorInitStatus[currentSensorId] = success;
    }
    
    // Verificar si hay algún sensor RTD
    bool rtdSensorEnabled = false;
    for (const auto& sensor : enabledNormalSensors) {
        if (sensor.type == RTD && sensor.enable) {
            rtdSensorEnabled = true;
            break;
        }
    }
    
    // Inicializar RTD solo si está habilitado en la configuración
    if (rtdSensorEnabled) {
        rtdSensor.begin(MAX31865_4WIRE);
    }

    // Verificar si hay algún sensor DS18B20
    bool ds18b20SensorEnabled = false;
    for (const auto& sensor : enabledNormalSensors) {
        if (sensor.type == DS18B20 && sensor.enable) {
            ds18b20SensorEnabled = true;
            break;
        }
    }

    // Inicializar DS18B20 solo si está habilitado en la configuración
    if (ds18b20SensorEnabled) {
        // TIEMPO ejecución ≈ 65 ms
        // Inicializar DS18B20
        dallasTemp.begin();
        dallasTemp.requestTemperatures();
    }

    // Configurar los pines analógicos para cada sensor
    // NTC100K 0 - Pin A0
    pinMode(NTC100K_0_PIN, INPUT);
    // NTC100K 1 - Pin A3
    pinMode(NTC100K_1_PIN, INPUT);
    // NTC10K - Pin A4
    pinMode(NTC10K_PIN, INPUT);
    // PH Sensor - Pin A5
    pinMode(PH_SENSOR_PIN, INPUT);
    // Conductivity Sensor - Pin A6
    pinMode(COND_SENSOR_PIN, INPUT);
    // HDS10 Sensor - Pin A7
    pinMode(HDS10_SENSOR_PIN, INPUT);
    // Battery Sensor - Pin A8
    pinMode(BATTERY_SENSOR_PIN, INPUT);
    // Soil Humidity Sensor
    pinMode(SOILH_SENSOR_PIN, INPUT);

    // Configurar ADC interno
    analogReadResolution(13); // Resolución de 12 bits (0-4095)
    analogSetAttenuation(ADC_11db); // Atenuación para medir hasta 3.3V
}

SensorReading SensorManager::getSensorReading(const SensorConfig &cfg) {
    SensorReading reading;
    strncpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId) - 1);
    reading.sensorId[sizeof(reading.sensorId) - 1] = '\0';
    reading.type = cfg.type;
    reading.value = NAN;

    readSensorValue(cfg, reading);

    return reading;
}

/**
 * @brief Lógica principal para leer el valor de cada sensor normal (no Modbus) según su tipo.
 */
float SensorManager::readSensorValue(const SensorConfig &cfg, SensorReading &reading) {
    // Verificar si el sensor está en el mapa y si su estado es 'true'
    std::string currentSensorId = cfg.sensorId;
    
    if (sensorInitStatus.count(currentSensorId) == 0 || !sensorInitStatus[currentSensorId]) {
        // Si el sensor no está en el mapa o su estado es 'false'

        reading.value = NAN; // Asignar NAN al valor principal
        reading.subValues.clear(); // Limpiar subvalores

        // Para sensores multivalor, llenar subValues con NAN para mantener la estructura esperada
        size_t numSubValues = 0;
        switch(cfg.type) {
            case SHT30: numSubValues = 2; break;
            case CO2:
            case BME680:
            case BME280: numSubValues = 3; break;
            // El resto de sensores son de valor único
        }

        if (numSubValues > 0) {
            SubValue nanVal; nanVal.value = NAN;
            for(size_t i = 0; i < numSubValues; ++i) {
                reading.subValues.push_back(nanVal);
            }
        }

        return NAN; // Retornar NAN inmediatamente
    }

    // Si la inicialización fue exitosa, proceder con la lectura normal
    switch (cfg.type) {
        case N100K:
            // Usar NtcManager para obtener la temperatura
            reading.value = NtcManager::readNtc100kTemperature(cfg.configKey);
            break;

        case N10K:
            // Usar NtcManager para obtener la temperatura del NTC de 10k
            reading.value = NtcManager::readNtc10kTemperature();
            break;
            
        case HDS10:
            // Leer sensor HDS10 y obtener el porcentaje de humedad
            reading.value = HDS10Sensor::read();
            break;
            
        case PH:
            // Leer sensor de pH y obtener valor
            reading.value = PHSensor::read();
            break;

        case COND:
            // Leer sensor de conductividad y obtener valor en ppm
            reading.value = ConductivitySensor::read();
            break;
        
        case SOILH:
            {
                // Leer el valor del pin analógico
                int adcValue = analogRead(SOILH_SENSOR_PIN);
                
                // Convertir el valor ADC a voltaje (0-3.3V con resolución de 12 bits)
                float voltage = adcValue * (3.3f / 4095.0f);
                
                // Verificar si el voltaje está en rango válido
                if (voltage <= 0.0f || voltage >= 3.3f) {
                    reading.value = NAN;
                } else {
                    // Convertir el voltaje a porcentaje (0V = 0%, 3.3V = 100%)
                    reading.value = (voltage / 3.3f) * 100.0f;
                }
            }
            break;

        case RTD:
            {
                uint16_t rtdValue = rtdSensor.readRTD();
                float temp = rtdSensor.temperature(RNOMINAL, RREF);
                
                // Verificar si hay errores
                uint8_t fault = rtdSensor.readFault();
                if (fault) {
                    rtdSensor.clearFault();
                    reading.value = NAN;
                } else {
                    reading.value = temp;
                }
            }
            break;

        case DS18B20:
            reading.value = DS18B20Sensor::read();
            break;

        case SHT30:
        {
            float tmp = 0.0f, hum = 0.0f;
            SHT30Sensor::read(tmp, hum);
            reading.subValues.clear();
            
            // Agregar temperatura como primer valor [0]
            {
                SubValue sT; 
                sT.value = tmp;
                reading.subValues.push_back(sT);
            }
            
            // Agregar humedad como segundo valor [1]
            {
                SubValue sH; 
                sH.value = hum;
                reading.subValues.push_back(sH);
            }
            
            // Asignar el valor principal como NAN si alguno de los valores falló
            reading.value = (isnan(tmp) || isnan(hum)) ? NAN : tmp;
        }
        break;

        case SHT4X:
        {
            float tmp = 0.0f, hum = 0.0f;
            bool success = SHT4xSensor::read(tmp, hum);
            reading.subValues.clear();
            
            if (success) {
                // Agregar temperatura como primer valor [0]
                SubValue sT; 
                sT.value = tmp;
                reading.subValues.push_back(sT);
                
                // Agregar humedad como segundo valor [1]
                SubValue sH; 
                sH.value = hum;
                reading.subValues.push_back(sH);
                
                // Asignar temperatura como valor principal
                reading.value = tmp;
            } else {
                // En caso de error, rellenar con NAN
                SubValue nanVal; nanVal.value = NAN;
                reading.subValues.push_back(nanVal); // Temperatura
                reading.subValues.push_back(nanVal); // Humedad
                reading.value = NAN;
            }
        }
        break;

        // Caso para el sensor de CO2 (SCD4x)
        case CO2:
        {
            float co2 = NAN, temp = NAN, hum = NAN; // Inicializar a NAN
            if (CO2Sensor::read(co2, temp, hum)) {
                // Lectura exitosa
                reading.subValues.clear();

                // Agregar CO2 como primer valor [0]
                SubValue sCO2;
                sCO2.value = co2;
                reading.subValues.push_back(sCO2);

                // Agregar Temperatura como segundo valor [1]
                SubValue sTemp;
                sTemp.value = temp;
                reading.subValues.push_back(sTemp);

                // Agregar Humedad como tercer valor [2]
                SubValue sHum;
                sHum.value = hum;
                reading.subValues.push_back(sHum);

                // Asignar CO2 como valor principal
                reading.value = co2;
            } else {
                // Lectura fallida, asegurar que todo sea NAN
                reading.subValues.clear();
                SubValue nanVal; nanVal.value = NAN;
                reading.subValues.push_back(nanVal); // CO2
                reading.subValues.push_back(nanVal); // Temp
                reading.subValues.push_back(nanVal); // Hum
                reading.value = NAN;
            }
        }
        break;
        
        case BME680:
        {
            // performReading() puede tardar un poco
            if (!bme680Sensor.performReading()) {
                reading.value = NAN;
                reading.subValues.clear();
                // Rellenar con NANs para mantener la estructura
                SubValue nanVal; nanVal.value = NAN;
                reading.subValues.push_back(nanVal); // Temp
                reading.subValues.push_back(nanVal); // Hum
                reading.subValues.push_back(nanVal); // Press
                reading.subValues.push_back(nanVal); // Gas
            } else {
                reading.subValues.clear();
                float temp = bme680Sensor.temperature;
                float hum = bme680Sensor.humidity;
                float press = bme680Sensor.pressure / 100.0F; // Convertir Pa a hPa
                float gas = bme680Sensor.gas_resistance / 1000.0F; // Convertir Ohms a KOhms

                // Rellenar subValues en orden definido: [0]=Temp, [1]=Hum, [2]=Press, [3]=Gas
                SubValue svT; svT.value = temp; reading.subValues.push_back(svT);
                SubValue svH; svH.value = hum; reading.subValues.push_back(svH);
                SubValue svP; svP.value = press; reading.subValues.push_back(svP);
                SubValue svG; svG.value = gas; reading.subValues.push_back(svG);

                // Asignar un valor principal (ej. temperatura)
                reading.value = temp;
            }
        }
        break;

        case BME280:
        {
            // Forzar una medición (necesario en MODE_FORCED)
            bme280Sensor.takeForcedMeasurement();

            // Leer valores
            float temp = bme280Sensor.readTemperature();    // Lee Temperatura en °C
            float hum = bme280Sensor.readHumidity();       // Lee Humedad en %
            float press = bme280Sensor.readPressure();     // Lee Presión en Pa

            // Verificar si las lecturas son válidas (la librería suele devolver NAN en error)
            if (isnan(temp) || isnan(hum) || isnan(press)) {
                reading.value = NAN;
                reading.subValues.clear();
                // Rellenar con NANs para mantener la estructura
                SubValue nanVal; nanVal.value = NAN;
                reading.subValues.push_back(nanVal); // Temp
                reading.subValues.push_back(nanVal); // Hum
                reading.subValues.push_back(nanVal); // Press
            } else {
                // Convertir presión de Pa a hPa
                press = press / 100.0F;

                reading.subValues.clear();

                // Rellenar subValues en orden definido: [0]=Temp(°C), [1]=Hum(%), [2]=Press(hPa)
                SubValue svT; svT.value = temp; reading.subValues.push_back(svT);
                SubValue svH; svH.value = hum; reading.subValues.push_back(svH);
                SubValue svP; svP.value = press; reading.subValues.push_back(svP);

                // Asignar un valor principal (ej. temperatura)
                reading.value = temp;
            }
        }
        break;

        case VEML7700:
        {
            // Leer el valor de luz en lux
            float lux = VEML7700Sensor::read();
            
            // Verificar si la lectura es válida
            if (isnan(lux)) {
                reading.value = NAN;
                reading.subValues.clear();
                // Rellenar con NANs para mantener la estructura
                SubValue nanVal; nanVal.value = NAN;
                reading.subValues.push_back(nanVal); // Lux
            } else {
                reading.subValues.clear();
                
                // Rellenar subValues: [0]=Lux
                SubValue svL; svL.value = lux; reading.subValues.push_back(svL);
                
                // Asignar el valor de lux como valor principal
                reading.value = lux;
            }
        }
        break;

        default:
            reading.value = NAN;
            break;
    }
    return reading.value;
}

ModbusSensorReading SensorManager::getModbusSensorReading(const ModbusSensorConfig& cfg) {
    ModbusSensorReading reading;
    
    // Copiar el ID del sensor
    strlcpy(reading.sensorId, cfg.sensorId, sizeof(reading.sensorId));
    reading.type = cfg.type;
    
    // Leer sensor según su tipo
    switch (cfg.type) {
        case ENV4:
            reading = ModbusSensorManager::readEnvSensor(cfg);
            break;
        // Añadir casos para otros tipos de sensores Modbus
        default:
            DEBUG_PRINTLN("Tipo de sensor Modbus no soportado");
            break;
    }
    
    return reading;
}

void SensorManager::getAllSensorReadings(std::vector<SensorReading>& normalReadings,
                                        std::vector<ModbusSensorReading>& modbusReadings,
                                        const std::vector<SensorConfig>& enabledNormalSensors,
                                        const std::vector<ModbusSensorConfig>& enabledModbusSensors) {
    // Reservar espacio para los vectores
    normalReadings.reserve(enabledNormalSensors.size());
    modbusReadings.reserve(enabledModbusSensors.size());
    
    // Leer sensores normales
    for (const auto &sensor : enabledNormalSensors) {
        normalReadings.push_back(getSensorReading(sensor));
    }
    
    // Si hay sensores Modbus, inicializar comunicación, leerlos y finalizar
    if (!enabledModbusSensors.empty()) {
        // Determinar el tiempo máximo de estabilización necesario
        uint32_t maxStabilizationTime = 0;
        
        // Revisar cada sensor habilitado para encontrar el tiempo máximo
        for (const auto &sensor : enabledModbusSensors) {
            uint32_t sensorStabilizationTime = 0;
            
            // Obtener el tiempo de estabilización según el tipo de sensor
            switch (sensor.type) {
                case ENV4:
                    sensorStabilizationTime = MODBUS_ENV4_STABILIZATION_TIME;
                    break;
                // Añadir casos para otros tipos de sensores Modbus con sus respectivos tiempos
                default:
                    sensorStabilizationTime = 500; // Tiempo predeterminado si no se especifica
                    break;
            }
            
            // Actualizar el tiempo máximo si este sensor necesita más tiempo
            if (sensorStabilizationTime > maxStabilizationTime) {
                maxStabilizationTime = sensorStabilizationTime;
            }
        }
        
        // Encender alimentación de 12V para sensores Modbus
        powerManager.power12VOn();
        delay(maxStabilizationTime);
        
        // Inicializar comunicación Modbus antes de comenzar las mediciones
        ModbusSensorManager::beginModbus();
        
        // Leer todos los sensores Modbus
        for (const auto &sensor : enabledModbusSensors) {
            modbusReadings.push_back(getModbusSensorReading(sensor));
        }
        
        // Finalizar comunicación Modbus después de completar todas las lecturas
        ModbusSensorManager::endModbus();
        
        // Apagar alimentación de 12V después de completar las lecturas
        powerManager.power12VOff();
    }
}

================
File: include/config.h
================
#ifndef CONFIG_H
#define CONFIG_H

#define DEVICE_TYPE_ANALOGIC

// Configuración de depuración - Comentar para deshabilitar mensajes de depuración
#define DEBUG_ENABLED

// Pines one wire
#define ONE_WIRE_BUS        38

// Pines I2C
#define I2C_SDA_PIN         48
#define I2C_SCL_PIN         47

//Serial 1
#define SERIAL1_RX_PIN      43
#define SERIAL1_TX_PIN      44

// Pines para activar medición de batería
#define BATTERY_CONTROL_PIN 37

// Pines analógicos para sensores
#define NTC100K_0_PIN       3  // IO3
#define NTC100K_1_PIN       5  // IO5 
#define NTC10K_PIN          6  // IO6 
#define PH_SENSOR_PIN       17  // IO17 
#define COND_SENSOR_PIN     20  // IO20 
#define HDS10_SENSOR_PIN    7  // IO7 
#define BATTERY_SENSOR_PIN  1  // IO1 
#define SOILH_SENSOR_PIN    2  // IO2 // Pin para el sensor de humedad del suelo

// SPI PARA LORA
#define SPI_LORA_SCK_PIN        9
#define SPI_LORA_MISO_PIN       11
#define SPI_LORA_MOSI_PIN       10
#define LORA_NSS_PIN            8
#define LORA_BUSY_PIN           13
#define LORA_RST_PIN            12
#define LORA_DIO1_PIN           14

#define MAX_LORA_PAYLOAD        200

// SPI PARA RTD
#define SPI_SCK_PIN        39
#define SPI_MISO_PIN       40
#define SPI_MOSI_PIN       41

// SPI Clock
#define SPI_LORA_CLOCK       1000000
#define SPI_RTD_CLOCK        1000000

// PT100
#define PT100_CS_PIN        46

// Modo Config
#define CONFIG_PIN          2
#define CONFIG_TRIGGER_TIME 5000
#define CONFIG_TIMEOUT      30000
#define CONFIG_LED_PIN      35
#define CONFIG_BLE_WAIT_TIMEOUT     60000   // Tiempo máximo de espera para conexión BLE (60 segundos)
#define CONFIG_BLE_MAX_CONN_TIME    300000  // Tiempo máximo de conexión BLE activa (5 minutos)

//Leds
#define LED1_PIN      33
#define LED2_PIN      34

// Serial
#define SERIAL_BAUD_RATE         115200

// Deep Sleep
#define DEFAULT_TIME_TO_SLEEP   10

// Identificadores
#define DEFAULT_DEVICE_ID   "DEV01"
#define DEFAULT_STATION_ID  "ST001"

// LoRa (OTAA)
#define DEFAULT_JOIN_EUI    "00,00,00,00,00,00,00,00"
#define DEFAULT_DEV_EUI     "1f,d4,e6,68,46,8c,e1,b7"
#define DEFAULT_APP_KEY     "1d,fb,69,80,69,d6,a0,7e,5d,bf,29,ba,6b,37,d3,04"
#define DEFAULT_NWK_KEY     "82,91,e9,55,19,ab,c0,6c,86,25,63,68,e7,f4,5a,89"

// LoRa Region y SubBand
#define LORA_REGION         US915
#define LORA_SUBBAND        2       // For US915, use 2; for other regions, use 0

#define BLE_SERVICE_UUID             "180A"
#define BLE_CHAR_SYSTEM_UUID         "2A37"
#define BLE_CHAR_SENSORS_UUID        "2A40"
#define BLE_CHAR_LORA_CONFIG_UUID    "2A41"
#define BLE_CHAR_NTC100K_UUID        "2A38"
#define BLE_CHAR_NTC10K_UUID         "2A39"
#define BLE_CHAR_CONDUCTIVITY_UUID   "2A3C"
#define BLE_CHAR_PH_UUID             "2A3B"
#define BLE_DEVICE_PREFIX            "AGRICOS-"

// Calibración batería
const double R1 = 100000.0;
const double R2 = 390000.0;
const double conversionFactor = 1.0 / (R1 / (R1 + R2));

// Namespaces
#define NAMESPACE_SYSTEM        "system"
#define NAMESPACE_SENSORS       "sensors"
#define NAMESPACE_LORAWAN       "lorawan"
#define NAMESPACE_LORA_SESSION  "lorasession"
#define NAMESPACE_SENSORS_MODBUS "sensors_modbus"

// Claves
#define KEY_INITIALIZED         "initialized"
#define KEY_SLEEP_TIME          "sleep_time"
#define KEY_STATION_ID          "stationId"
#define KEY_DEVICE_ID           "deviceId"
#define KEY_VOLT                "volt"
#define KEY_SENSOR              "k"
#define KEY_SENSOR_ID           "id"
#define KEY_SENSOR_ID_TEMPERATURE_SENSOR "ts"
#define KEY_SENSOR_TYPE         "t"
#define KEY_SENSOR_ENABLE       "e"
#define KEY_LORA_JOIN_EUI       "joinEUI"
#define KEY_LORA_DEV_EUI        "devEUI"
#define KEY_LORA_NWK_KEY        "nwkKey"
#define KEY_LORA_APP_KEY        "appKey"
#define KEY_LORAWAN_SESSION     "lorawan_session"

// Claves para Modbus
#define KEY_MODBUS_SENSOR_ID    "id"
#define KEY_MODBUS_SENSOR_TYPE  "t"
#define KEY_MODBUS_SENSOR_ADDR  "a"
#define KEY_MODBUS_SENSOR_ENABLE "e"

// Configuración Modbus
#define MODBUS_RX_PIN           21
#define MODBUS_TX_PIN           26
#define MODBUS_BAUD_RATE        9600
#define MODBUS_SERIAL_CONFIG    SERIAL_8N1
#define MODBUS_RESPONSE_TIMEOUT 300  // Tiempo de espera para respuesta en ms
#define MODBUS_MAX_RETRY        3     // Número máximo de intentos de lectura Modbus

// Dirección I2C para BME280
#define BME280_I2C_ADDR 0x76 

// Tamaños de documentos JSON - Centralizados
#define JSON_DOC_SIZE_SMALL   300
#define JSON_DOC_SIZE_MEDIUM  1024
#define JSON_DOC_SIZE_LARGE   2048

// Batería
#define POWER_3V3_PIN           36
#define POWER_12V_PIN           19
#define POWER_STABILIZE_DELAY   1

// FlowSensor
#define FLOW_SENSOR_PIN         4

// Namespaces analógicos
#define NAMESPACE_NTC100K   "ntc_100k"
#define NAMESPACE_NTC10K    "ntc_10k"
#define NAMESPACE_COND      "cond"
#define NAMESPACE_PH        "ph"

// Calibración NTC 100K
#define DEFAULT_T1_100K     25.0
#define DEFAULT_R1_100K     100000.0
#define DEFAULT_T2_100K     35.0
#define DEFAULT_R2_100K     64770.0
#define DEFAULT_T3_100K     45.0
#define DEFAULT_R3_100K     42530.0

// Calibración NTC 10K
#define DEFAULT_T1_10K      25.0
#define DEFAULT_R1_10K      10000.0
#define DEFAULT_T2_10K      35.0
#define DEFAULT_R2_10K      6477.0
#define DEFAULT_T3_10K      45.0
#define DEFAULT_R3_10K      4253.0

// Calibración Conductividad
#define CONDUCTIVITY_DEFAULT_V1    0.010314f
#define CONDUCTIVITY_DEFAULT_T1    84.0f
#define CONDUCTIVITY_DEFAULT_V2    0.175384f
#define CONDUCTIVITY_DEFAULT_T2    1413.0f
#define CONDUCTIVITY_DEFAULT_V3    1.407745f
#define CONDUCTIVITY_DEFAULT_T3    12880.0f
#define TEMP_COEF_COMPENSATION     0.02f
#define CONDUCTIVITY_DEFAULT_TEMP  24.22f

// Calibración pH
#define PH_DEFAULT_V1          0.4425
#define PH_DEFAULT_T1          4.01
#define PH_DEFAULT_V2          0.001
#define PH_DEFAULT_T2          6.86
#define PH_DEFAULT_V3         -0.32155
#define PH_DEFAULT_T3          9.18
#define PH_DEFAULT_TEMP        25.0

// Claves NTC100K
#define KEY_NTC100K_T1         "n100k_t1"
#define KEY_NTC100K_R1         "n100k_r1"
#define KEY_NTC100K_T2         "n100k_t2"
#define KEY_NTC100K_R2         "n100k_r2"
#define KEY_NTC100K_T3         "n100k_t3"
#define KEY_NTC100K_R3         "n100k_r3"

// Claves NTC10K
#define KEY_NTC10K_T1          "n10k_t1"
#define KEY_NTC10K_R1          "n10k_r1"
#define KEY_NTC10K_T2          "n10k_t2"
#define KEY_NTC10K_R2          "n10k_r2"
#define KEY_NTC10K_T3          "n10k_t3"
#define KEY_NTC10K_R3          "n10k_r3"

// Claves Conductividad
#define KEY_CONDUCT_CT         "c_ct"
#define KEY_CONDUCT_CC         "c_cc"
#define KEY_CONDUCT_V1         "c_v1"
#define KEY_CONDUCT_T1         "c_t1"
#define KEY_CONDUCT_V2         "c_v2"
#define KEY_CONDUCT_T2         "c_t2"
#define KEY_CONDUCT_V3         "c_v3"
#define KEY_CONDUCT_T3         "c_t3"

// Claves pH
#define KEY_PH_V1              "ph_v1"
#define KEY_PH_T1              "ph_t1"
#define KEY_PH_V2              "ph_v2"
#define KEY_PH_T2              "ph_t2"
#define KEY_PH_V3              "ph_v3"
#define KEY_PH_T3              "ph_t3"
#define KEY_PH_CT              "ph_ct"


// // Configuración default sensores
// #define  DEFAULT_SENSOR_CONFIGS { \
//     {"0", "NTC1",  N100K, true}, \
//     {"1", "NTC2",  N100K, true}, \
//     {"2", "NTC3",  N10K, true}, \
//     {"3", "HDS10",  HDS10, true}, \
//     {"4", "COND",  COND, true}, \
//     {"5", "SM1",   SOILH, true}, \
//     {"8", "PH",    PH, true}, \
//     {"R", "RTD1",  RTD, true}, \
//     {"D", "DS1",   DS18B20, true}, \
//     {"I2C", "SHT30", SHT30, true} \
// }

// Configuración default sensores
#define DEFAULT_SENSOR_CONFIGS { \
    {"B", "BME1", BME680, false}, \
    {"C", "CO2_1", CO2, false}, \
    {"B2", "BME280_1", BME280, false}, \
    {"L", "LUX1", VEML7700, false}, \
    {"SH4", "SHT4X_1", SHT4X, true} \
}

// Sin sensores Modbus registrados
#define DEFAULT_MODBUS_SENSOR_CONFIGS { \
    {"ModbusEnv1", ENV4, 1, false} \
}


// Límites de temperatura NTC para evitar lecturas erróneas cuando esta desconectado
#define NTC_TEMP_MIN           -20.0   // Temperatura mínima válida en °C
#define NTC_TEMP_MAX            100.0   // Temperatura máxima válida en °C

// Configuración MAX31865 para RTD (PT100/PT1000)
#define RREF      430.0         // Resistencia de referencia en ohms
#define RNOMINAL  100.0         // Resistencia nominal del sensor a 0°C (100.0 para PT100, 1000.0 para PT1000)

#endif // CONFIG_H

================
File: src/main.cpp
================
#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include <Preferences.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <vector>
#include <ArduinoJson.h>
#include <cmath>
#include <map>
#include <string>

#include "config.h"
#include "debug.h"
#include "PowerManager.h"
#include <RadioLib.h>
#include <ESP32Time.h>
#include "sensor_types.h"
#include "SensorManager.h"
#include "nvs_flash.h"
#include "esp_sleep.h"
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEAdvertising.h>
#include "config_manager.h"
#include "utilities.h"
#include <SensirionI2cSht3x.h>
#include "SparkFun_SCD4x_Arduino_Library.h"
#include "LoRaManager.h"
#include "BLE.h"
#include "HardwareManager.h"
#include "SleepManager.h"
#include "SHT31.h"
#include <Adafruit_MAX31865.h>
#include <Adafruit_BME680.h>
#include <Adafruit_BME280.h>
#include <Adafruit_VEML7700.h>
#include <SensirionI2cSht4x.h>

// --- INICIO: Añadir bandera global ---
bool wokeFromConfigPin = false;
// --- FIN: Añadir bandera global ---

//--------------------------------------------------------------------------------------------
// Variables globales
//--------------------------------------------------------------------------------------------
const LoRaWANBand_t Region = LORA_REGION;
const uint8_t subBand = LORA_SUBBAND;

// Mapa para rastrear el estado de inicialización de los sensores
std::map<std::string, bool> sensorInitStatus;

Preferences preferences;
uint32_t timeToSleep;
String deviceId;
String stationId;
bool systemInitialized;
unsigned long setupStartTime; // Variable para almacenar el tiempo de inicio

// Configuraciones de sensores
std::vector<SensorConfig> enabledNormalSensors;
std::vector<ModbusSensorConfig> enabledModbusSensors;

ESP32Time rtc;
PowerManager powerManager;

SPIClass spiLora(FSPI);
SPISettings spiRadioSettings(SPI_LORA_CLOCK, MSBFIRST, SPI_MODE0);

Adafruit_MAX31865 rtdSensor = Adafruit_MAX31865(PT100_CS_PIN, SPI_MOSI_PIN, SPI_MISO_PIN, SPI_SCK_PIN);

SHT31 sht30Sensor(0x44, &Wire);
SCD4x scd4x(SCD4x_SENSOR_SCD41);
Adafruit_BME680 bme680Sensor(&Wire);
Adafruit_BME280 bme280Sensor;
Adafruit_VEML7700 veml7700;
SensirionI2cSht4x sht4xSensor;

SX1262 radio = new Module(LORA_NSS_PIN, LORA_DIO1_PIN, LORA_RST_PIN, LORA_BUSY_PIN, spiLora, spiRadioSettings);
LoRaWANNode node(&radio, &Region, subBand);

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature dallasTemp(&oneWire);

RTC_DATA_ATTR uint8_t LWsession[RADIOLIB_LORAWAN_SESSION_BUF_SIZE];
Preferences store;

//--------------------------------------------------------------------------------------------
// setup()
//--------------------------------------------------------------------------------------------
void setup() {
    setCpuFrequencyMhz(40); // 40MHz O 80MHz FUNCIONAN BIEN EN BAJO CONSUMO
    // Inicializar contador de tiempo y log
    setupStartTime = millis();
    DEBUG_BEGIN(SERIAL_BAUD_RATE);
    // --- INICIO: Comprobar causa del despertar ---
    esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
    if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
        DEBUG_PRINTLN("INFO: Despertado por EXT0 (CONFIG_PIN)");
        wokeFromConfigPin = true;
        // Opcional: Pequeño delay para estabilizar/debounce inicial
        delay(50);
    } else if (wakeup_reason == ESP_SLEEP_WAKEUP_TIMER) {
        DEBUG_PRINTLN("INFO: Despertado por Timer");
        wokeFromConfigPin = false;
    } else {
        DEBUG_PRINTF("INFO: Despertado por otra razón: %d\n", wakeup_reason);
        wokeFromConfigPin = false;
    }
    // --- FIN: Comprobar causa del despertar ---

    // Liberar pines que se mantuvieron en estado específico durante el deep sleep
    SleepManager::releaseHeldPins();

    // // Inicialización del NVS y de hardware I2C/IO
    // preferences.clear();       // Comentado para evitar borrar los nonces guardados
    // nvs_flash_erase();         // Comentado para evitar borrar los nonces guardados
    // nvs_flash_init();          // Comentado para preservar datos NVS entre boots

    // Inicialización de configuración
    if (!ConfigManager::checkInitialized()) {
        ConfigManager::initializeDefaultConfig();
    }
    ConfigManager::getSystemConfig(systemInitialized, timeToSleep, deviceId, stationId);

    // Obtener configuraciones de sensores habilitados
    enabledNormalSensors = ConfigManager::getEnabledSensorConfigs();
    enabledModbusSensors = ConfigManager::getEnabledModbusSensorConfigs();

    // Inicialización de hardware básico (GPIO, I2C, SPI, etc.)
    if (!HardwareManager::initHardware(powerManager, 
                                     sht30Sensor, 
                                     bme680Sensor, 
                                     bme280Sensor, 
                                     veml7700,
                                     sht4xSensor,
                                     spiLora, 
                                     enabledNormalSensors)) {
        SleepManager::goToDeepSleep(timeToSleep, powerManager, &radio, node, LWsession, spiLora);
    }

    // Verificar y entrar en modo configuración BLE si es necesario
    if (BLEHandler::checkConfigMode()) {
        return;
    }

    // Comprobar si tenemos un timestamp válido
    struct tm timeinfo;
    if (!getLocalTime(&timeinfo)) {
        // Establecer una fecha/hora predeterminada si el RTC no está configurado
        rtc.setTime(0, 0, 0, 1, 1, 2023);  // 01/01/2023 00:00:00
    }

    // Tiempo hasta que se inicializan los sensores = 4ms
    // Inicializar sensores
    SensorManager::beginSensors(enabledNormalSensors);

    DEBUG_PRINTLN("Tiempo después de iniciar sensores: " + String(millis() - setupStartTime));

    // Inicializar y activar radio LoRa = 61ms
    int16_t state = radio.begin();
    if (state != RADIOLIB_ERR_NONE) {
        SleepManager::goToDeepSleep(timeToSleep, powerManager, &radio, node, LWsession, spiLora);
    }

    // Activar LoRaWAN
    state = LoRaManager::lwActivate(node);
    if (state != RADIOLIB_LORAWAN_NEW_SESSION && 
        state != RADIOLIB_LORAWAN_SESSION_RESTORED) {
        SleepManager::goToDeepSleep(timeToSleep, powerManager, &radio, node, LWsession, spiLora);
    } 
    ///

    DEBUG_PRINTLN("Tiempo después de activar radio: " + String(millis() - setupStartTime));
}

//--------------------------------------------------------------------------------------------
// loop()
//--------------------------------------------------------------------------------------------
void loop() {

    // Verificar si se mantiene presionado para modo config
    if (BLEHandler::checkConfigMode()) {
        return;
    }

    // Obtener todas las lecturas de sensores (normales y Modbus)
    std::vector<SensorReading> normalReadings;
    std::vector<ModbusSensorReading> modbusReadings;

    SensorManager::getAllSensorReadings(normalReadings, modbusReadings, enabledNormalSensors, enabledModbusSensors);

    //Apgar las fuentes de alimentacion de sensores antes de enviar datos
    powerManager.allPowerOff();
    LoRaManager::sendDelimitedPayload(normalReadings, modbusReadings, node, deviceId, stationId, rtc);

    // Calcular y mostrar el tiempo transcurrido antes de dormir
    unsigned long elapsedTime = millis() - setupStartTime;
    DEBUG_PRINTF("Tiempo transcurrido antes de sleep: %lu ms\n", elapsedTime);
    delay(10);

    // Dormir
    SleepManager::goToDeepSleep(timeToSleep, powerManager, &radio, node, LWsession, spiLora);
}



================================================================
End of Codebase
================================================================
